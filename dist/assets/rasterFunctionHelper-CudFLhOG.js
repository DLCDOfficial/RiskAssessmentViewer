const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./intersectsOperator-D5-3o_-_.js","./ProjectionTransformation-CSOGIsAN.js","./Envelope2D-Da8Eb6by.js","./Point2D-C8Vjr_uf.js","./Transformation2D-a6U1dcm_.js","./SimpleGeometryCursor-B92kdZ15.js","./index-DzoQLc5A.js","./index-FMl8DCyv.css","./OperatorDefinitions-DP7_WWTp.js","./jsonConverter-6QX7GqU9.js","./intersectsOperator-CsR9KFxS.js","./OperatorIntersects-DExe29Qj.js","./apiConverter-C4nPBqvs.js","./containsOperator-DVp64wjh.js","./containsOperator-DtOcLQkz.js","./projectOperator-B4Tn6_hc.js","./geographicTransformationUtils-O55nPRI-.js","./GeographicTransformation-x1sRZ3X1.js"])))=>i.map(i=>d[i]);
import{U as gs}from"./colorUtils-DpzmtTt4.js";import{B as h,F as f,J as N,w as Hs,dE as Js,aS as rt,aT as nt,a5 as J,X as vn,aU as An,_ as de,R as Bt,dS as jt,W as K,V as Ks,K as Tn,L as Pn,bw as Rn,s as Gt,ky as et,kz as tt,aC as $n,kA as Nn,eg as Fn,kB as ys,kC as kn,jO as _n,bl as oe,jN as Xs,dp as Ae,ct as lt,jW as pe}from"./index-DzoQLc5A.js";import{m as In,c as R,$ as Sn,a0 as Ys,Y as ft,a1 as W,a2 as Cn,a3 as Mn,a4 as Mt,a5 as Bn,a6 as Zs,w as Se,a7 as Qs,a8 as tn,a9 as en,aa as Pe,ab as jn,ac as Gn,ad as ls,ae as ie,af as zn,ag as sn,ah as ge,ai as nn,aj as rn,i as Re,ak as on,al as En,am as Yt,an as On,ao as Dn,ap as Vn,aq as Un,ar as Ln,as as Wn,at as qn,au as Hn,av as $e,aw as Jn,ax as Kn,ay as Xn}from"./dataUtils-DLw1lbIZ.js";let he=class extends Hs{constructor(){super(...arguments),this.raster=void 0}};h([f({json:{write:!0}})],he.prototype,"raster",void 0),he=h([N("esri.layers.support.rasterFunctions.BaseFunctionArguments")],he);const O=he;var Ce;let Ot=Ce=class extends O{constructor(){super(...arguments),this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Ce({raster:this.raster,raster2:this.raster2,operation:this.operation})}};h([f({json:{write:!0}})],Ot.prototype,"operation",void 0),h([f({json:{write:!0}})],Ot.prototype,"raster2",void 0),h([f({readOnly:!0})],Ot.prototype,"rasters",null),Ot=Ce=h([N("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")],Ot);const Yn=Ot,Zn=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let E=class extends Hs{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this.isRoot=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){var u;const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let o=s.rasters||s.raster&&[s.raster];for(;o!=null&&o.length;){e.unshift(...o);const l=[];for(let c=0;c<o.length;c++){const{parameters:p}=o[c],m=p.rasters||p.raster&&[p.raster];m!=null&&m.length&&l.push(...m)}o=l}for(let l=e.length-1;l>=0;l--)e[l].isNoopProcess&&e.splice(l,1);let r=!1;for(let l=0;l<e.length;l++){const c=e[l];c.id=e.length-l-1;const{rasters:p}=c.parameters;r=r||p!=null&&p.length>1}const a=e.some((({name:l})=>Zn.has(l.toLowerCase()))),{rawSourceRasterInfos:i}=this;return{functions:e,hasBranches:r,hasFocalFunction:a,isSourceSingleBand:((u=i==null?void 0:i[0])==null?void 0:u.bandCount)===1}}bind(t,e=!1,s=-1){this.id=s+1;const o=this._getRasterValues();let r=!0;for(let a=0;a<o.length;a++){const i=o[a];if(i!=null&&this._isRasterFunctionValue(i)){const u=i.bind(t,e,this.id+a);if(!u.success)return this._bindingResult=u,u;r=r&&u.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),r&&(r=this._bindingResult.supportsGPU),this._bindingResult.success&&(this._patchRasterInfo(),r&&this.isRoot)&&(this.processInputBandIds(),this.swizzleInputBandIds(this.rawInputBandIds)||(r=this.rawInputBandIds.length<=3)),this._bindingResult.supportsGPU=r,this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this._bindingResult)}process(t){const e=this._getRasterValues(),s=e.length===0?t.pixelBlocks??t.primaryPixelBlocks:e.map((o=>this._readRasterValue(o,t)));return this._processPixels({...t,pixelBlocks:s})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);if(t.length>1){const r=t.map((a=>a.processInputBandIds()));return this.rawInputBandIds=[...new Set(r.flat())],this.rawInputBandIds}const e=t[0];if(e)return this.rawInputBandIds=e.processInputBandIds(),this.rawInputBandIds;const{bandCount:s}=this.sourceRasterInfos[0],o=Array.from({length:s},((r,a)=>a));return this.rawInputBandIds=this._getInputBandIds(o),this.rawInputBandIds}swizzleInputBandIds(t){const e=this._getRasterValues().filter(this._isRasterFunctionValue);let s=!0;for(const o of e)s=o.swizzleInputBandIds(t)&&s;return!!s&&this._swizzleBandIds(t)}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map((o=>this._isRasterFunctionValue(o)?o.getWebGLProcessorDefinition():typeof o=="number"?{name:"Constant",parameters:{value:o},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:o},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((o=>o!=null))||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const t=[];this.functionName==="Clip"&&t.push(this.functionArguments);const{raster:e,rasters:s}=this.functionArguments;if(s&&Array.isArray(s)&&s.length)s.forEach((o=>{if(this._isRasterFunctionValue(o)){const r=o.getClippingGeometries();t.push(...r)}}));else if(this._isRasterFunctionValue(e)){const o=e.getClippingGeometries();t.push(...o)}return t}_getOutputPixelType(t){return this.outputPixelType==="unknown"?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_swizzleBandIds(t){return!0}_isInputRasterPrimaryOrConstant(){return!this._getRasterValues().some((t=>t&&typeof t=="object"&&"rasterFunction"in t&&t.rasterFunction))}_removeStatsHistColormapVAT(t){var e;t.statistics=null,t.histograms=null,t.colormap=null,t.attributeTable=null,(e=t.multidimensionalInfo)==null||e.variables.forEach((s=>{s.statistics=void 0,s.histograms=void 0}))}_getRasterValues(){const{rasterArgumentNames:t}=this;return t[0]==="rasters"?this.functionArguments.rasters??[]:t.flatMap((e=>this.functionArguments[e]))}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:o}=t;if(e.length===0)return s;const r=e.map((i=>i&&typeof i=="object"&&"bind"in i&&i.rasterInfo?i.rasterInfo:typeof i=="string"&&o.includes(i)?s[o.indexOf(i)]:typeof i!="number"?s[0]:void 0)),a=r.find((i=>i))??s[0];return r.forEach(((i,u)=>{i===void 0&&(r[u]=a)})),r}_getPrimaryRasterId(t){return t==null?void 0:t.rasterId}_getPrimaryRasters(t,e=[],s=[]){for(let o=0;o<t.sourceRasters.length;o++){const r=t.sourceRasters[o];if(typeof r!="number")if("bind"in r)this._getPrimaryRasters(r,e,s);else{const a=r,i=this._getPrimaryRasterId(a);if(i==null)continue;s.includes(i)||(this.mainPrimaryRasterId===i?(e.unshift(a),s.unshift(i)):(e.push(a),s.push(i)))}}}_isRasterFunctionValue(t){return t!=null&&typeof t=="object"&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,e){const{primaryPixelBlocks:s}=e;if(t==null||t==="$$"){const o=s[0];return o==null?null:o.clone()}if(typeof t=="string"){const o=e.primaryRasterIds.indexOf(t);return o===-1?null:s[o]}if(typeof t=="number"){const o=s[0];if(o==null)return null;const{width:r,height:a,pixelType:i}=o,u=new Float32Array(r*a);u.fill(t);const l=this.sourceRasterInfos[0].bandCount,c=new Array(l).fill(u);return new R({width:r,height:a,pixelType:i,pixels:c})}return t.process(e)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!(t!=null&&t.keyProperties))return;const{bandCount:e,keyProperties:s,statistics:o,histograms:r}=t,a=s.BandProperties;a&&a.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),o&&o.length!==e&&(t.statistics=o.length>e?o.slice(0,e):null),r&&r.length!==e&&(t.histograms=r.length>e?r.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:typeof s.BAND_COUNT=="string"?String(e):e})}};h([f({json:{write:!0}})],E.prototype,"functionName",void 0),h([f({json:{write:!0}})],E.prototype,"functionArguments",void 0),h([f()],E.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}}),Js((n=>n==null?void 0:n.toLowerCase()))],E.prototype,"outputPixelType",void 0),h([f({json:{write:!0}})],E.prototype,"mainPrimaryRasterId",void 0),h([f()],E.prototype,"sourceRasters",void 0),h([f({type:[In],json:{write:!0}})],E.prototype,"sourceRasterInfos",void 0),h([f({json:{write:!0}})],E.prototype,"rasterInfo",void 0),h([f({json:{write:!0}})],E.prototype,"readingBufferSize",void 0),h([f({json:{write:!0}})],E.prototype,"id",void 0),h([f()],E.prototype,"isNoopProcess",void 0),h([f()],E.prototype,"supportsGPU",null),h([f()],E.prototype,"rawInputBandIds",void 0),h([f()],E.prototype,"rawSourceRasterInfos",void 0),h([f()],E.prototype,"isInputBandIdsSwizzled",void 0),h([f()],E.prototype,"swizzledBandSelection",void 0),h([f()],E.prototype,"isBranch",void 0),h([f()],E.prototype,"isRoot",void 0),h([f({readOnly:!0})],E.prototype,"flatWebGLFunctionChain",null),h([f()],E.prototype,"_bindingResult",void 0),E=h([N("esri.layers.support.rasterFunctions.BaseRasterFunction")],E);const z=E,C={userDefined:-1,lineDetectionHorizontal:0,lineDetectionVertical:1,lineDetectionLeftDiagonal:2,lineDetectionRightDiagonal:3,gradientNorth:4,gradientWest:5,gradientEast:6,gradientSouth:7,gradientNorthEast:8,gradientNorthWest:9,smoothArithmeticMean:10,smoothing3x3:11,smoothing5x5:12,sharpening3x3:13,sharpening5x5:14,laplacian3x3:15,laplacian5x5:16,sobelHorizontal:17,sobelVertical:18,sharpen:19,sharpen2:20,pointSpread:21,none:255},Qn={plus:1,minus:2,times:3,sqrt:4,power:5,abs:10,divide:23,exp:25,exp10:26,exp2:27,int:30,float:32,ln:35,log10:36,log2:37,mod:44,negate:45,roundDown:48,roundUp:49,square:53,floatDivide:64,floorDivide:65},q={bitwiseAnd:11,bitwiseLeftShift:12,bitwiseNot:13,bitwiseOr:14,bitwiseRightShift:15,bitwiseXOr:16,booleanAnd:17,booleanNot:18,booleanOr:19,booleanXOr:20,equalTo:24,greaterThan:28,greaterThanEqual:29,lessThan:33,lessThanEqual:34,isNull:31,notEqual:46},Z={acos:6,asin:7,atan:8,atanh:9,cos:21,cosh:22,sin:51,sinh:52,tan:56,tanh:57,acosh:59,asinh:60,atan2:61},tr={majority:38,max:39,mean:40,med:41,min:42,minority:43,range:47,stddev:54,sum:55,variety:58,majorityIgnoreNoData:66,maxIgnoreNoData:67,meanIgnoreNoData:68,medIgnoreNoData:69,minIgnoreNoData:70,minorityIgnoreNoData:71,rangeIgnoreNoData:72,stddevIgnoreNoData:73,sumIgnoreNoData:74,varietyIgnoreNoData:75},an={setNull:50,conditional:78},xs={...Qn,...q,...Z,...tr,...an},un=new Map([[Z.acos,{domain:[0,Math.PI],isInteger:!1}],[Z.asin,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.atan,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.cos,{domain:[-1,1],isInteger:!1}],[Z.sin,{domain:[-1,1],isInteger:!1}],[q.booleanAnd,{domain:[0,1],isInteger:!0}],[q.booleanNot,{domain:[0,1],isInteger:!0}],[q.booleanOr,{domain:[0,1],isInteger:!0}],[q.booleanXOr,{domain:[0,1],isInteger:!0}],[q.equalTo,{domain:[0,1],isInteger:!0}],[q.notEqual,{domain:[0,1],isInteger:!0}],[q.greaterThan,{domain:[0,1],isInteger:!0}],[q.greaterThanEqual,{domain:[0,1],isInteger:!0}],[q.lessThan,{domain:[0,1],isInteger:!0}],[q.lessThanEqual,{domain:[0,1],isInteger:!0}],[q.isNull,{domain:[0,1],isInteger:!0}]]);function ws(n){return un.get(n)}const bs=[0,2,2,2,1,2,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,999,999,999,999,999,999,2,1,2,999,1,1,2,1,1,1,999,999,1,1,999,1,1,2,999,999,2,2,999,999,999,999,999,999,999,999,999,999,3,999,3];function er(n,t=!1){const e=n.map((i=>i.mask)),s=e.filter((i=>i!=null)),o=n[0].pixels[0].length;if(s.length===0||t&&s.length!==e.length)return new Uint8Array(o).fill(255);const r=s[0],a=new Uint8Array(r);if(s.length===1)return a;if(!t){for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]&&(a[l]=u[l]?255:0)}return a}for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]===0&&(a[l]=u[l]?255:0)}return a}function sr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]+o[i]);return a}function nr(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand("f32",o);return r.set(s),r}function rr(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(r[a]=s[a]*s[a]);return r}function or(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]-o[i]);return a}function ir(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]*o[i]);return a}function ar(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(r[a]=Math.sign(s[a])*Math.floor(Math.abs(s[a])));return r}function ln(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]/o[i]);return a}function ur(n,t,e){return ln(n,t,"f32")}function lr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=Math.floor(s[i]/o[i]));return a}function cr(n,t,e,s){const o=n[0],r=o.length,a=R.createEmptyBand(e,r);if(s===Z.atanh){for(let u=0;u<r;u++)if(t[u]){const l=o[u];Math.abs(l)>=1?t[u]=0:a[u]=Math.atanh(l)}return a}const i=s===Z.asin?Math.asin:Math.acos;for(let u=0;u<r;u++)if(t[u]){const l=o[u];Math.abs(l)>1?t[u]=0:a[u]=i(l)}return a}function pr(n,t,e,s){const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s(o[i]));return a}function hr(n,t,e,s){const[o,r]=n,a=o.length,i=R.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s(o[u],r[u]));return i}function mr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]&o[i]);return a}function fr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]<<o[i]);return a}function dr(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(r[a]=~s[a]);return r}function gr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]|o[i]);return a}function yr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]>>o[i]);return a}function xr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]^o[i]);return a}function wr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]&&o[i]?1:0);return a}function br(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(r[a]=s[a]?0:1);return r}function vr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]||o[i]?1:0);return a}function Ar(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=(s[i]?1:0)^(o[i]?1:0));return a}function Tr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]===o[i]?1:0);return a}function cs(n,t,e,s){const[o]=n,r=o.length,a=R.createEmptyBand(e,r),i=s===Math.E;for(let u=0;u<r;u++)t&&!t[u]||(a[u]=i?Math.exp(o[u]):s**o[u]);return a}function Pr(n,t,e){return cs(n,t,e,10)}function Rr(n,t,e){return cs(n,t,e,2)}function $r(n,t,e){return cs(n,t,e,Math.E)}function ps(n,t,e,s){const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(o[i]<=0?t[i]=0:a[i]=s(o[i]));return a}function Nr(n,t,e){return ps(n,t,e,Math.log10)}function Fr(n,t,e){return ps(n,t,e,Math.log2)}function kr(n,t,e){return ps(n,t,e,Math.log)}function _r(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]>o[i]?1:0);return a}function Ir(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]>=o[i]?1:0);return a}function Sr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]<o[i]?1:0);return a}function Cr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]<=o[i]?1:0);return a}function Mr(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);if(!t)return r;for(let a=0;a<o;a++)r[a]=t[a]?0:1;return r}function Br(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]%o[i]);return a}function jr(n,t,e){const[s]=n,o=s.length,r=R.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(r[a]=-s[a]);return r}function Gr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]===o[i]?0:1);return a}function zr(n,t,e){const[s,o]=n,r=s.length,a=R.createEmptyBand(e,r),i=new Uint8Array(r);for(let u=0;u<r;u++)t!=null&&!t[u]||s[u]!==0||(a[u]=o[u],i[u]=255);return{band:a,mask:i}}function vs(n,t,e){const[s,o,r]=n,a=s.length,i=R.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s[u]?o[u]:r[u]);return i}function As(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i]){let u=o[i];for(let l=1;l<s;l++){const c=n[l][i];u<c&&(u=c)}a[i]=u}return a}function Ts(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i]){let u=o[i];for(let l=1;l<s;l++){const c=n[l][i];u>c&&(u=c)}a[i]=u}return a}function Ps(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i]){let u=o[i],l=u;for(let c=1;c<s;c++){const p=n[c][i];l<p?l=p:u>p&&(u=p)}a[i]=l-u}return a}function Rs(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i]){let u=0;for(let l=0;l<s;l++)u+=n[l][i];a[i]=u/s}return a}function $s(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i])for(let u=0;u<s;u++){const l=n[u];a[i]+=l[i]}return a}function Ns(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)if(!t||t[i]){const u=new Float32Array(s);let l=0;for(let p=0;p<s;p++){const m=n[p];l+=m[i],u[p]=m[i]}l/=s;let c=0;for(let p=0;p<s;p++)c+=(u[p]-l)**2;a[i]=Math.sqrt(c/s)}return a}function Fs(n,t,e){const s=n.length;if(s<2)return n[0];const o=Math.floor(s/2),[r]=n,a=r.length,i=R.createEmptyBand(e,a),u=new Float32Array(s),l=s%2==1;for(let c=0;c<a;c++)if(!t||t[c]){for(let p=0;p<s;p++)u[p]=n[p][c];u.sort(),i[c]=l?u[o]:(u[o]+u[o-1])/2}return i}function cn(n,t,e){const[s,o]=n;if(o==null)return s;const r=s.length,a=R.createEmptyBand(e,r);for(let i=0;i<r;i++)t&&!t[i]||(a[i]=s[i]<o[i]?s[i]:o[i]);return a}function ks(n,t,e){const s=n.length;if(s<=2)return cn(n,t,e);const o=n[0].length,r=R.createEmptyBand(e,o),a=new Map;for(let i=0;i<o;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=n[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=0;const c=[];for(const p of a.keys())u=a.get(p),u>l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort(((p,m)=>p-m)),r[i]=c[0]}return r}function _s(n,t,e){const s=n.length;if(s<=2)return cn(n,t,e);const o=n[0].length,r=R.createEmptyBand(e,o),a=new Map;for(let i=0;i<o;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=n[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=n.length;const c=[];for(const p of a.keys())u=a.get(p),u<l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort(((p,m)=>p-m)),r[i]=c[0]}return r}function Is(n,t,e){const s=n.length;if(s<2)return n[0];const[o]=n,r=o.length,a=R.createEmptyBand(e,r),i=new Set;for(let u=0;u<r;u++)if(!t||t[u]){let l;i.clear();for(let c=0;c<s;c++)l=n[c][u],i.add(l);a[u]=i.size}return a}const D=new Map,ye=new Map,I=new Map,G=new Map;function Er(){D.size||(D.set(4,Math.sqrt),D.set(6,Math.acos),D.set(7,Math.asin),D.set(8,Math.atan),D.set(9,Math.atanh),D.set(10,Math.abs),D.set(21,Math.cos),D.set(22,Math.cosh),D.set(48,Math.floor),D.set(49,Math.ceil),D.set(51,Math.sin),D.set(52,Math.sinh),D.set(56,Math.tan),D.set(57,Math.tanh),D.set(59,Math.acosh),D.set(60,Math.asinh),D.set(65,Math.floor),ye.set(5,Math.pow),ye.set(61,Math.atan2),I.set(1,sr),I.set(2,or),I.set(3,ir),I.set(11,mr),I.set(12,fr),I.set(13,dr),I.set(14,gr),I.set(15,yr),I.set(16,xr),I.set(17,wr),I.set(18,br),I.set(19,vr),I.set(20,Ar),I.set(23,ln),I.set(24,Tr),I.set(25,$r),I.set(26,Pr),I.set(27,Rr),I.set(28,_r),I.set(29,Ir),I.set(30,ar),I.set(31,Mr),I.set(32,nr),I.set(33,Sr),I.set(34,Cr),I.set(35,kr),I.set(36,Nr),I.set(37,Fr),I.set(44,Br),I.set(45,jr),I.set(46,Gr),I.set(53,rr),I.set(64,ur),I.set(65,lr),I.set(76,vs),I.set(78,vs),G.set(38,ks),G.set(39,As),G.set(40,Rs),G.set(41,Fs),G.set(42,Ts),G.set(43,_s),G.set(47,Ps),G.set(54,Ns),G.set(55,$s),G.set(58,Is),G.set(66,ks),G.set(67,As),G.set(68,Rs),G.set(69,Fs),G.set(70,Ts),G.set(71,_s),G.set(72,Ps),G.set(73,Ns),G.set(74,$s),G.set(75,Is))}function pn(n,t,e={}){Er();let s=er(n,t>=66&&t<=75);const{outputPixelType:o="f32"}=e,r=!G.has(t)||e.processAsMultiband,a=r?n[0].pixels.length:1,i=[];for(let l=0;l<a;l++){const c=G.has(t)&&!r?n.flatMap((d=>d.pixels)):n.map((d=>d.pixels[l]));let p,m=!0;if(t===an.setNull){const d=zr(c,s,o);p=d.band,s=d.mask,m=!1}else I.has(t)?p=I.get(t)(c,s,"f64"):D.has(t)?p=t===Z.asin||t===Z.acos||t===Z.atanh?cr(c,s,"f64",t):pr(c,s,"f64",D.get(t)):ye.has(t)?p=hr(c,s,"f64",ye.get(t)):G.has(t)?p=G.get(t)(c,s,"f64"):(p=c[0],m=!1);if(m&&t!==q.isNull&&!un.has(t)){const d=R.createEmptyBand(o,p.length);s||(s=new Uint8Array(p.length).fill(255)),Sn(p,s),Ys(p,s,o,d),p=d}i.push(p)}const u=n[0];return new R({width:u.width,height:u.height,pixelType:o,mask:t===q.isNull?null:s,pixels:i})}function Or(n,t,e){return pn(n,t=[null,1,2,3,23,5,44][t]??1,{outputPixelType:e})}let Dt=class extends z{constructor(){super(...arguments),this.functionName="Arithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{operation:t}=this.functionArguments;if(t<1||t>6)return{success:!1,supportsGPU:!1,error:"unsupported operation"};const e=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:e.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return(e==null?void 0:e[0])==null||(e==null?void 0:e[1])==null?null:Or(e,this.functionArguments.operation,this.outputPixelType)}_getWebGLParameters(){const{operation:t}=this.functionArguments,e=["","plus","minus","times","divide","power","mod"][t],s=this.outputPixelType??"f32";let[o,r]=ft(s);const a=W(s);return a&&(o-=1e-4,r+=1e-4),{imageCount:2,operationName:e,domainRange:[o,r],isOutputRounded:a}}};h([f({json:{write:!0,name:"rasterFunction"}})],Dt.prototype,"functionName",void 0),h([f({type:Yn,json:{write:!0,name:"rasterFunctionArguments"}})],Dt.prototype,"functionArguments",void 0),h([f()],Dt.prototype,"rasterArgumentNames",void 0),Dt=h([N("esri.layers.support.rasterFunctions.ArithmeticFunction")],Dt);const Dr=Dt;var Me;let Be=Me=class extends O{clone(){return new Me({raster:this.raster})}};Be=Me=h([N("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Be);const Vr=Be;let dt=class extends z{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var s;const t=this.sourceRasterInfos[0];this.isGCS=((s=t.spatialReference)==null?void 0:s.isGeographic)??!1,this.outputPixelType=this._getOutputPixelType("f32");const e=t.clone();return e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),e.statistics=[{min:-1,max:360,avg:180,stddev:30}],e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){var i;const e=(i=t.pixelBlocks)==null?void 0:i[0];if(e==null)return null;const{extent:s,primaryPixelSizes:o}=t,r=o==null?void 0:o[0],a=r??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1});return Cn(e,{resolution:a})}};h([f({json:{write:!0,name:"rasterFunction"}})],dt.prototype,"functionName",void 0),h([f({type:Vr,json:{write:!0,name:"rasterFunctionArguments"}})],dt.prototype,"functionArguments",void 0),h([f()],dt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],dt.prototype,"isGCS",void 0),dt=h([N("esri.layers.support.rasterFunctions.AspectFunction")],dt);const Ur=dt,Lr=new Set(["+","-","*","/","(",")"]);function Wr(n,t){(n=n.replaceAll(" ","")).startsWith("-")&&(n="0"+n),n.startsWith("+")&&(n=n.slice(1));const e=n.split(""),s=[],o=[];let r="";for(let a=0;a<e.length;a++){const i=e[a];Lr.has(i)?(r.length&&o.push(Ss(r,t)),s.push(i),r=""):r=r.concat(i)}return r.length&&o.push(Ss(r,t)),{ops:s,nums:o}}function Ss(n,t){return n.toLowerCase().startsWith("b")?t[parseInt(n.slice(1),10)-1]:parseFloat(n)}function qr(n,t,e,s){if(typeof e=="number"&&typeof s=="number")return e+s;let o,r,a;typeof e=="number"?(a=s,o=a.length,r=new Float32Array(o),r.fill(e)):(o=e.length,r=e,s.constructor===Number?(a=new Float32Array(o),a.fill(s)):a=s);const i=new Float32Array(o);switch(t){case"+":for(let u=0;u<o;u++)(n==null||n[u])&&(i[u]=r[u]+a[u]);break;case"-":for(let u=0;u<o;u++)(n==null||n[u])&&(i[u]=r[u]-a[u]);break;case"*":for(let u=0;u<o;u++)(n==null||n[u])&&(i[u]=r[u]*a[u]);break;case"/":for(let u=0;u<o;u++)(n==null||n[u])&&a[u]&&(i[u]=r[u]/a[u]);break;case"(":case")":throw new Error("encountered error with custom band index equation")}return i}function Hr(n,t){n.splice(t,1);let e=0,s=0;do{e=0,s=0;for(let o=0;o<n.length;o++)if(n[o]==="(")e=o;else if(n[o]===")"){s=o;break}s===e+1&&n.splice(e,2)}while(s===e+1);return n}function Jr(n){if(n.length===1)return{opIndex:0,numIndex:0};let t=0,e=0;for(let a=0;a<n.length;a++)if(n[a]==="(")t=a;else if(n[a]===")"){e=a;break}const s=e===0?n:n.slice(t+1,e);let o=-1;for(let a=0;a<s.length;a++)if(s[a]==="*"||s[a]==="/"){o=a;break}if(o>-1)e>0&&(o+=t+1);else{for(let a=0;a<s.length;a++)if(s[a]==="+"||s[a]==="-"){o=a;break}e>0&&(o+=t+1)}let r=0;for(let a=0;a<o;a++)n[a]==="("&&r++;return{opIndex:o,numIndex:o-r}}function Kr(n,t,e){let s,{ops:o,nums:r}=Wr(e,t);if(o.length===0){const a=r.length===1?r[0]:t[0];if(a instanceof Float32Array)return[a];const i=new Float32Array(t[0].length);return typeof a=="number"?i.fill(a):i.set(a),[i]}for(;o.length>0;){const{numIndex:a,opIndex:i}=Jr(o);if(s=qr(n,o[i],r[a],r[a+1]),o.length===1)break;o=Hr(o,i),r.splice(a,2,s)}return[s]}const Xr=new rt({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function Yr(n,t){if(!Mn(n))return n;const{equation:e,method:s}=t,o=t.bandIndexes.map((m=>m-1)),{pixels:r,mask:a}=n;let i;switch(s){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":i=Cs(a,r[o[0]],r[o[1]]);break;case"ndwi":i=Cs(a,r[o[1]],r[o[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":i=Qr(a,r[o[0]],r[o[1]]);break;case"ci-g":case"ci-re":i=to(a,r[o[0]],r[o[1]]);break;case"savi":i=eo(a,r[o[0]],r[o[1]],o[2]+1);break;case"tsavi":i=so(a,r[o[0]],r[o[1]],o[2]+1,o[3]+1,o[4]+1);break;case"msavi":i=no(a,r[o[0]],r[o[1]]);break;case"gemi":i=ro(a,r[o[0]],r[o[1]]);break;case"pvi":i=oo(a,r[o[0]],r[o[1]],o[2]+1,o[3]+1);break;case"gvitm":i=io(a,[r[o[0]],r[o[1]],r[o[2]],r[o[3]],r[o[4]],r[o[5]]]);break;case"sultan":i=ao(a,[r[o[0]],r[o[1]],r[o[2]],r[o[3]],r[o[4]]]);break;case"vari":i=uo(a,[r[o[0]],r[o[1]],r[o[2]]]);break;case"mtvi2":i=lo(a,[r[o[0]],r[o[1]],r[o[2]]]);break;case"rtvi-core":i=co(a,[r[o[0]],r[o[1]],r[o[2]]]);break;case"evi":i=po(a,[r[o[0]],r[o[1]],r[o[2]]]);break;case"wndwi":i=ho(a,[r[o[0]],r[o[1]],r[o[2]]],o[3]?o[3]+1:.5);break;case"bai":i=mo(a,r[o[0]],r[o[1]]);break;case"custom":i=Kr(a,r,e);break;default:return n}const{outputPixelType:u="f32"}=t,l=u!=null&&W(u);let c;a?(c=new Uint8Array(n.width*n.height),c.set(a)):l&&(c=new Uint8Array(n.width*n.height).fill(255)),l&&(i=i.map((m=>{const d=R.createEmptyBand(u,m.length);return Ys(m,c,u,d),d})));const p=new R({width:n.width,height:n.height,pixelType:u,pixels:i,mask:c});return p.updateStatistics(),p}function Zr(n,t,e,s){const{mask:o,pixels:r,width:a,height:i}=n,u=r[e],l=r[t],c=l.length,p=s?new Uint8Array(c):new Float32Array(c),m=s?100:1,d=s?100.5:0;for(let x=0;x<c;x++)if(o==null||o[x]){const g=u[x],A=l[x],w=g+A;w&&(p[x]=(g-A)/w*m+d)}const y=new R({width:a,height:i,mask:o,pixelType:s?"u8":"f32",pixels:[p]});return y.updateStatistics(),y}function U(n){const t=new Float32Array(9);return t[3*n[0]]=1,t[3*n[1]+1]=1,t[3*n[2]+2]=1,t}function Cs(n,t,e){const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r]){const a=t[r],i=e[r],u=a+i;u&&(o[r]=(a-i)/u)}return[o]}function Qr(n,t,e){const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r]){const a=t[r],i=e[r];i&&(o[r]=a/i)}return[o]}function to(n,t,e){const s=t.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r]){const a=t[r],i=e[r];i&&(o[r]=a/i-1)}return[o]}function eo(n,t,e,s){const o=e.length,r=new Float32Array(o);for(let a=0;a<o;a++)if(n==null||n[a]){const i=e[a],u=t[a],l=u+i+s;l&&(r[a]=(u-i)/l*(1+s))}return[r]}function so(n,t,e,s,o,r){const a=e.length,i=new Float32Array(a),u=-o*s+r*(1+s*s);for(let l=0;l<a;l++)if(n==null||n[l]){const c=e[l],p=t[l],m=o*p+c+u;m&&(i[l]=s*(p-s*c-o)/m)}return[i]}function no(n,t,e){const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r]){const a=e[r],i=t[r],u=2*i+1;o[r]=.5*(u-Math.sqrt(u*u-8*(i-a)))}return[o]}function ro(n,t,e){const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r]){const a=e[r],i=t[r];if(a!==1&&i+a+.5!==0){const u=(2*(i*i-a*a)+1.5*i+.5*a)/(i+a+.5);o[r]=u*(1-.25*u)-(a-.125)/(1-a)}}return[o]}function oo(n,t,e,s,o){const r=e.length,a=new Float32Array(r),i=1/Math.sqrt(1+s*s);for(let u=0;u<r;u++)if(n==null||n[u]){const l=e[u],c=t[u];a[u]=(c-s*l-o)*i}return[a]}function io(n,t){const[e,s,o,r,a,i]=t,u=e.length,l=new Float32Array(u);for(let c=0;c<u;c++)(n==null||n[c])&&(l[c]=-.2848*e[c]-.2435*s[c]-.5436*o[c]+.7243*r[c]+.084*a[c]-.18*i[c]);return[l]}function ao(n,t){const[e,s,o,r,a]=t,i=e.length,u=new Float32Array(i),l=new Float32Array(i),c=new Float32Array(i);for(let p=0;p<i;p++)(n==null||n[p])&&(u[p]=a[p]?r[p]/a[p]*100:0,l[p]=e[p]?r[p]/e[p]*100:0,c[p]=o[p]?s[p]/o[p]*(r[p]/o[p])*100:0);return[u,l,c]}function uo(n,t){const[e,s,o]=t,r=e.length,a=new Float32Array(r);for(let i=0;i<r;i++)if(n==null||n[i])for(i=0;i<r;i++){const u=e[i],l=s[i],c=l+u-o[i];c&&(a[i]=(l-u)/c)}return[a]}function lo(n,t){const[e,s,o]=t,r=e.length,a=new Float32Array(r);for(let i=0;i<r;i++)if(n==null||n[i])for(i=0;i<r;i++){const u=e[i],l=s[i],c=o[i],p=Math.sqrt((2*u+1)**2-(6*u-5*Math.sqrt(l))-.5);if(p){const m=1.5*(1.2*(u-c)-2.5*(l-c));a[i]=m/p}}return[a]}function co(n,t){const[e,s,o]=t,r=e.length,a=new Float32Array(r);for(let i=0;i<r;i++)if(n==null||n[i])for(i=0;i<r;i++){const u=e[i],l=s[i],c=o[i];a[i]=100*(u-l)-10*(u-c)}return[a]}function po(n,t){const[e,s,o]=t,r=e.length,a=new Float32Array(r);for(let i=0;i<r;i++)if(n==null||n[i])for(i=0;i<r;i++){const u=e[i],l=s[i],c=u+6*l-7.5*o[i]+1;c&&(a[i]=2.5*(u-l)/c)}return[a]}function ho(n,t,e=.5){const[s,o,r]=t,a=o.length,i=new Float32Array(a);for(let u=0;u<a;u++)if(n==null||n[u])for(u=0;u<a;u++){const l=s[u],c=o[u],p=r[u],m=l+e*c+(1-e)*p;m&&(i[u]=(l-e*c-(1-e)*p)/m)}return[i]}function mo(n,t,e){const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)if(n==null||n[r])for(r=0;r<s;r++){const a=(.1-t[r])**2+(.06-e[r])**2;a&&(o[r]=1/a)}return[o]}var je;let ee=je=class extends O{constructor(){super(...arguments),this.method="custom"}clone(){return new je({method:this.method,bandIndexes:this.bandIndexes,raster:J(this.raster)})}};h([f({json:{type:String,write:!0}})],ee.prototype,"bandIndexes",void 0),h([nt(Xr)],ee.prototype,"method",void 0),ee=je=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],ee);const fo=ee,go=new Set(["vari","mtvi2","rtvi-core","evi"]);let Vt=class extends z{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0];if(t.bandCount<2)return{success:!1,supportsGPU:!1,error:"band-arithmetic-function: source raster has insufficient amount of raster bands"};const e=t.clone();return e.pixelType=this.outputPixelType,e.bandCount=this.functionArguments.method==="sultan"?3:1,this._removeStatsHistColormapVAT(e),e.keyProperties={...e.keyProperties,BandProperties:void 0},this.rasterInfo=e,{success:!0,supportsGPU:!["custom","gvitm","sultan"].includes(this.functionArguments.method)}}_processPixels(t){var a;const e=(a=t.pixelBlocks)==null?void 0:a[0];if(e==null)return e;const{method:s,bandIndexes:o}=this.functionArguments,r=o.split(" ").map((i=>parseFloat(i)));return Yr(e,{method:s,bandIndexes:r,equation:o,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=this.functionArguments.bandIndexes.split(" ").map((i=>parseFloat(i)-1));t.length===2&&t.push(0);const e=this.isInputBandIdsSwizzled?[0,1,2]:t;let s,o;const r=new Float32Array(3),{method:a}=this.functionArguments;switch(a){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":s=U([e[0],e[1],0]),o="ndxi";break;case"ndwi":s=U([e[1],e[0],0]),o="ndxi";break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":s=U([e[0],e[1],0]),o="sr";break;case"ci-g":case"ci-re":s=U([e[0],e[1],0]),o="ci";break;case"savi":s=U([e[0],e[1],0]),o="savi",r[0]=t[2]+1;break;case"tsavi":s=U([e[0],e[1],0]),o="tsavi",r[0]=t[2]+1,r[1]=t[3]+1,r[2]=t[4]+1;break;case"msavi":s=U([e[0],e[1],0]),o="msavi";break;case"gemi":s=U([e[0],e[1],0]),o="gemi";break;case"pvi":s=U([e[0],e[1],0]),o="tsavi",r[0]=t[2]+1,r[1]=t[3]+1;break;case"vari":s=U([e[0],e[1],e[2]]),o="vari";break;case"mtvi2":s=U([e[0],e[1],e[2]]),o="mtvi";break;case"rtvi-core":s=U([e[0],e[1],e[2]]),o="rtvicore";break;case"evi":s=U([e[0],e[1],e[2]]),o="evi";break;case"wndwi":s=U([e[0],e[1],0]),o="wndwi",r[0]=t[3]?t[3]+1:.5;break;case"bai":s=U([e[1],e[0],0]),o="bai";break;default:s=U([0,1,2]),o="custom"}return{bandIndexMat3:s,indexType:o,adjustments:r,isOutputRounded:W(this.outputPixelType)}}_getInputBandIds(t){if(this.functionArguments.method==="custom")return t;const e=this.functionArguments.bandIndexes.split(" ").map((i=>parseFloat(i)-1)),s=t.length,o=e.map((i=>i>=s?s-1:i)),r=go.has(this.functionArguments.method)?3:2,a=o.slice(0,r).map((i=>t[i]));return a.length===2&&a.push(0),a}_swizzleBandIds(t){const e=this.functionArguments.bandIndexes.split(" ").map((r=>parseFloat(r)-1));e.length===2&&e.push(0);const{method:s}=this.functionArguments,o=(["vari","mtvi2","rtvi-core","evi"].includes(s)?e.slice(0,3):s==="bai"||s==="ndwi"?[e[1],e[0]]:e.slice(0,2)).map((r=>t.indexOf(r)));return o[2]??(o[2]=o[1]),this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=o,!1}};h([f({json:{write:!0,name:"rasterFunction"}})],Vt.prototype,"functionName",void 0),h([f({type:fo,json:{write:!0,name:"rasterFunctionArguments"}})],Vt.prototype,"functionArguments",void 0),h([f()],Vt.prototype,"rasterArgumentNames",void 0),Vt=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunction")],Vt);const yo=Vt;var Ge;const Ms=new rt({1:"outside",2:"inside"},{useNumericKeys:!0});let se=Ge=class extends O{constructor(){super(...arguments),this.clippingType="outside"}clone(){return new Ge({clippingGeometry:this.clippingGeometry.clone(),clippingType:this.clippingType})}};h([f({types:An,json:{read:vn,write:!0}})],se.prototype,"clippingGeometry",void 0),h([f({json:{read:Ms.read,write:Ms.write}})],se.prototype,"clippingType",void 0),se=Ge=h([N("esri.layers.support.rasterFunctions.ClipFunctionArguments")],se);const xo=se;function wo(n,t){if(n.spatialReference.equals(t))return n;const e=jt(n.spatialReference),s=jt(t);if(e===s)return n;const o=e/s;return{x:n.x*o,y:n.y*o}}async function xa(n,t,e){if(e.type==="extent")return To(n,t,e);const{width:s,height:o}=n,r=new Uint8Array(s*o);return(await de(async()=>{const{execute:a}=await import("./intersectsOperator-D5-3o_-_.js");return{execute:a}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12]),import.meta.url)).execute(t,e)?e.type==="polyline"?Po(n,t,e):(await de(async()=>{const{execute:a}=await import("./containsOperator-DVp64wjh.js");return{execute:a}},__vite__mapDeps([13,1,2,3,4,5,6,7,8,9,14,12]),import.meta.url)).execute(e,t)?n:bo(n,t,e):new R({pixelType:n.pixelType,width:s,height:o,mask:r,maskIsAlpha:!1,pixels:[...n.pixels]})}function bo(n,t,e){if(!n)return n;const{width:s,height:o}=n,r=vo({geometry:e,size:[s,o],srcExtent:t,srcMask:n.mask});return new R({pixelType:n.pixelType,width:s,height:o,mask:r,maskIsAlpha:!1,pixels:[...n.pixels]})}function vo(n){const{geometry:t,size:e,srcExtent:s,srcMask:o}=n,[r,a]=e;let i;const u=s.width/r,l=s.height/a,{xmin:c,ymax:p}=s;if(t.type==="extent"){const m=(t.xmin-c)/u,d=(t.xmax-c)/u,y=(p-t.ymax)/l,x=(p-t.ymin)/l;i=[[[m,y],[m,x],[d,x],[d,y],[m,y]]]}else i=t.rings.map((m=>m.map((([d,y])=>[(d-c)/u,(p-y)/l]))));return Ao(i,e,o)}function Ao(n,t,e){const[s,o]=t,r=new OffscreenCanvas(s,o).getContext("2d");r.fillStyle="#f00",r.beginPath(),n.forEach((c=>{r.moveTo(c[0][0],c[0][1]);for(let p=0;p<c.length;p++)r.lineTo(c[p][0],c[p][1]);r.closePath()})),r.fill();const a=r.getImageData(0,0,s,o).data,i=s*o,u=new Uint8Array(i);let l=!1;for(let c=0;c<i;c++)e&&!e[c]||(a[4*c+3]>127?u[c]=255:l=!0);return l||e?u:void 0}function To(n,t,e){const{width:s,height:o}=n,r=new Uint8Array(s*o),a=t.width/s,i=t.height/o;if(e.width/a<.5||e.height/i<.5)return new R({pixelType:n.pixelType,width:s,height:o,mask:r,pixels:[...n.pixels]});const{xmin:u,xmax:l,ymin:c,ymax:p}=t,{xmin:m,xmax:d,ymin:y,ymax:x}=e,g=Math.max(u,m),A=Math.min(l,d),w=Math.max(c,y),v=Math.min(p,x),b=.5*a,T=.5*i;if(A-g<b||v-w<T||A<u+b||g>l-b||w>p-T||v<c+T)return new R({pixelType:n.pixelType,width:s,height:o,mask:r,pixels:[...n.pixels]});const P=Math.max(0,(g-u)/a),$=Math.min(s,Math.max(0,(A-u)/a)),F=Math.max(0,(p-v)/i),k=Math.min(o,Math.max(0,(p-w)/i)),_=Math.round(P),S=Math.round($)-1,B=Math.round(F),X=Math.round(k)-1;if(_===S&&P%1>.5&&$%1<.5||B===X&&F%1>.5&&k%1<.5)return new R({pixelType:n.pixelType,width:s,height:o,mask:r,pixels:[...n.pixels]});if(_===0&&B===0&&S===s&&X===o)return n;const ue=n.mask;for(let Zt=B;Zt<=X;Zt++)for(let Et=_;Et<=S;Et++){const le=Zt*s+Et;r[le]=ue?ue[le]:255}return new R({pixelType:n.pixelType,width:s,height:o,mask:r,pixels:[...n.pixels]})}function Po(n,t,e){const{width:s,height:o}=n,r=new Uint8Array(s*o),a=t.width/s,i=t.height/o,{xmin:u,ymax:l}=t,{paths:c}=e,p=n.mask;for(let m=0;m<c.length;m++){const d=c[m];for(let y=0;y<d.length-1;y++){const[x,g]=d[y],[A,w]=d[y+1];let v=Math.floor((l-g)/i),b=Math.floor((l-w)/i);if(b<v){const P=v;v=b,b=P}v=Math.max(0,v),b=Math.min(o-1,b);const T=(A-x)/(w-g);for(let P=v;P<=b;P++){const $=P===v?Math.max(g,w):(o+1-P)*i,F=P===b?Math.min(g,w):$-i;let k=Math.floor(w===g?(x-u)/a:(T*($-g)+x-u)/a),_=Math.floor(w===g?(A-u)/a:(T*(F-g)+x-u)/a);if(_<k){const B=k;k=_,_=B}const S=P*s;k=Math.max(0,k),_=Math.min(s-1,_);for(let B=S+k;B<=S+_;B++)r[B]=p?p[B]:255}}}return new R({pixelType:n.pixelType,width:s,height:o,mask:r,pixels:[...n.pixels]})}function Ro(n,t){const{extent:e}=$o(n,t,new K({x:n.pixelSize.x,y:n.pixelSize.y,spatialReference:n.spatialReference})),{extent:s}=n.extent;if(e.xmax=Math.min(e.xmax,s.xmax),e.ymax=Math.min(e.ymax,s.ymax),e.xmin<e.xmax&&e.ymin<e.ymax){const{x:o,y:r}=n.pixelSize,a=Math.round(e.width/o),i=Math.round(e.height/r);n.extent=e,n.width=a,n.height=i}}function $o(n,t,e,s=!0){const{spatialReference:o}=n,{x:r,y:a}=wo(e,o);let i,u,l;const c=t.type==="extent"?t:t.extent;let{xmin:p,xmax:m,ymax:d,ymin:y}=c;const{xmin:x,ymax:g}=n.extent;return s?(p=x+(p>x?r*Math.round((p-x)/r):0),d=g-(d<g?a*Math.round((g-d)/a):0),m=x+(m>x?r*Math.round((m-x)/r):0),y=g-(y<g?a*Math.round((g-y)/a):0),i=new Bt({xmin:p,ymax:d,xmax:m,ymin:y,spatialReference:o}),u=Math.round(i.width/r),l=Math.round(i.height/a)):(u=Math.floor((m-p)/r+.8),l=Math.floor((d-y)/a+.8),p=x+(p>x?r*Math.floor((p-x)/r+.1):0),d=g-(d<g?a*Math.floor((g-d)/a+.1):0),m=p+u*r,y=d-l*a,i=new Bt({xmin:p,ymax:d,xmax:m,ymin:y,spatialReference:o})),{extent:i,width:u,height:l}}var ze;function ae(){if(!hn)throw new Gt("rasterprojectionhelper-project","projection operator is not loaded")}(function(n){n[n.None=0]="None",n[n.North=1]="North",n[n.South=2]="South",n[n.Both=3]="Both"})(ze||(ze={}));const Bs=(n,t,e,s=0)=>{if(e[0]===1)return[0,0];let o=1,r=-1,a=1,i=-1;for(let g=0;g<n.length;g+=2)isNaN(n[g])||(o=o>n[g]?n[g]:o,r=r>n[g]?r:n[g],a=a>n[g+1]?n[g+1]:a,i=i>n[g+1]?i:n[g+1]);const{cols:u,rows:l}=t,c=(r-o)/u/e[0],p=(i-a)/l/e[1],m=2*s;let d=0,y=!1,x=[0,0];for(let g=0;g<u-3;g++){for(let A=0;A<l-3;A++){const w=g*l*2+2*A,v=(n[w]+n[w+4]+n[w+4*l]+n[w+4*l+4])/4,b=(n[w+1]+n[w+5]+n[w+4*l+1]+n[w+4*l+5])/4,T=Math.abs((v-n[w+2*l+2])/c),P=Math.abs((b-n[w+2*l+3])/p);if(T+P>d&&(d=T+P,x=[T,P]),m&&d>m){y=!0;break}}if(y)break}return x},No={3395:20037508342789244e-9,3410:17334193943686873e-9,3857:20037508342788905e-9,3975:17367530445161372e-9,4087:20037508342789244e-9,4088:20015108787169147e-9,6933:17367530445161372e-9,32662:20037508342789244e-9,53001:2001508679602057e-8,53002:1000754339801029e-8,53003:2001508679602057e-8,53004:2001508679602057e-8,53016:14152803599503474e-9,53017:17333573624304302e-9,53034:2001508679602057e-8,53079:20015114352186374e-9,53080:20015114352186374e-9,54001:20037508342789244e-9,54002:10018754171394624e-9,54003:20037508342789244e-9,54004:20037508342789244e-9,54016:14168658027268292e-9,54017:1736753044516137e-8,54034:20037508342789244e-9,54079:20037508342789244e-9,54080:20037508342789244e-9,54100:20037508342789244e-9,54101:20037508342789244e-9},xe=32,we=4,Ne=we,Fe=new Map,ke=new Map,be=500;let ce,st,_e,hn=!1;async function wa(){return ce||(ce=Tn(),st=await de(()=>import("./projectOperator-B4Tn6_hc.js"),__vite__mapDeps([15,6,7,5]),import.meta.url),_e=await de(()=>import("./geographicTransformationUtils-O55nPRI-.js"),__vite__mapDeps([16,6,7,17]),import.meta.url),st.isLoaded()||await st.load(),_e.isLoaded()||await _e.load(),hn=!0,ce.resolve()),ce.promise}function ba(n,t,e,s){const o=n.spatialReference;if(!o||!t||o.equals(t))return n;ae();const r=e.center,a=new Bt({xmin:r.x-n.x/2,xmax:r.x+n.x/2,ymin:r.y-n.y/2,ymax:r.y+n.y/2,spatialReference:o}),i=st.execute(a,t,{geographicTransformation:s}),u=ut(t);return i==null||u!=null&&i.width>=u?Fo(n,o,t):{x:i.width,y:i.height}}function Fo(n,t,e){const s=jt(t)/jt(e);return{x:n.x*s,y:n.y*s}}function H(n,t=.01){return jt(n)?t/jt(n):0}function js(n,t,e,s=!0){const o=n.spatialReference;if(o.equals(t))return n;ae();const r=st.execute(n,t,{geographicTransformation:e});return s&&r&&mn([n],[r],o,t),r}function mn(n,t,e,s){const o=ve(e,!0),r=ve(s,!0),a=H(e,be),i=H(s,be);if(a&&o!=null&&r!=null)for(let u=0;u<n.length;u++){const l=t[u];if(!l)continue;const{x:c}=n[u],{x:p}=l;p>=r[1]-i&&Math.abs(c-o[0])<a?l.x-=r[1]-r[0]:p<=r[0]+i&&Math.abs(c-o[1])<a&&(l.x+=r[1]-r[0])}}function ko(n){const{inSR:t,outSR:e,preferPE:s}=n;if(t.equals(e)){const{points:o}=hs(n,null);return o}return t.isWebMercator&&e.isWGS84||t.isWGS84&&e.isWebMercator?Io(n):s&&(t.isGeographic||zt(t)!=null)?Gs(n):_o(n)}function _o(n){const{points:t}=hs(n,null),{inSR:e,outSR:s,datumTransformation:o}=n,r=t.map((i=>new K(i[0],i[1],e))),a=st.executeMany(r,s,{geographicTransformation:o});return o&&mn(r,a,e,s),a.map((i=>i?[i.x,i.y]:[NaN,NaN]))}function Gs(n){const{inSR:t,outSR:e,datumTransformation:s}=n,o=zt(t),{points:r,mask:a}=hs(n,o);if(!t.isGeographic){const u=t.wkid?et.coordsys(t.wkid):et.fromString(t.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,t.wkt2||t.wkt);ys.projToGeog(u,r.length,r)}if(s!=null&&s.steps.length){let u;if(e.isGeographic&&(u=r.map((([c])=>c>179.9955?1:c<-179.9955?-1:0))),s.steps.forEach((c=>{const p=c.wkid?et.geogtran(c.wkid):et.fromString(tt.PE_TYPE_GEOGTRAN,c.wkt);kn.geogToGeog(p,r.length,r,null,c.isInverse?tt.PE_TRANSFORM_2_TO_1:tt.PE_TRANSFORM_1_TO_2)})),u)for(let c=0;c<r.length;c++){const p=u[c],m=r[c][0],d=m>179.9955?1:m<-179.9955?-1:0;p&&d&&p!==d&&(r[c][0]=p>0?m+360:m-360)}}if(!e.isGeographic){const u=zt(e,!0),l=u!=null&&u.isEnvelope?[u.bbox[1],u.bbox[3]]:[-90,90];So(r,l);const c=e.wkid?et.coordsys(e.wkid):et.fromString(e.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,e.wkt2||e.wkt);ys.geogToProj(c,r.length,r)}let i=r;if(a&&r.length!==a.length){i=[];for(let u=0,l=0;u<a.length;u++)a[u]?i.push(r[l++]):i.push([NaN,NaN])}return i}function Io(n){const{cols:t,rows:e,xres:s,yres:o,usePixelCenter:r,inSR:a,outSR:i}=n;let{xmin:u,ymax:l}=n;r&&(u+=s/2,l-=o/2);const c=[],p=[],m=Math.max(t,e);for(let y=0;y<m;y++){const x=u+s*Math.min(t,y),g=l-o*Math.min(e,y),A=Fn(new K({x,y:g,spatialReference:a}),a,i);y<=t&&c.push(A.x),y<=e&&p.push(A.y)}const d=[];for(let y=0;y<t;y++)for(let x=0;x<e;x++)d.push([c[y],p[x]]);return d}function zt(n,t=!1){let e=n.wkid||n.wkt2||n.wkt;if(!e||n.isGeographic)return null;if(e=String(e),Fe.has(e)){const a=Fe.get(e);return t?a==null?void 0:a.gcs:a==null?void 0:a.pcs}const s=n.wkid?et.coordsys(n.wkid):et.fromString(n.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,n.wkt2||n.wkt),o=zs(s,H(n,1e-4)),r=zs(s,0,!0);return Fe.set(e,{pcs:o,gcs:r}),t?r:o}function zs(n,t=0,e=!1){const s=Nn.generate(n),o=e?n.horizonGcsGenerate():n.horizonPcsGenerate();if(!s||!(o!=null&&o.length))return null;let r=!1,a=o.find((g=>g.getInclusive()===1&&g.getKind()===1));if(!a){if(a=o.find((g=>g.getInclusive()===1&&g.getKind()===0)),!a)return null;r=!0}const i=e?0:(s.getNorthPoleLocation()===2?1:0)|(s.getSouthPoleLocation()===2?2:0),u=s.isPannableRectangle(),l=a.getCoord();if(r)return{isEnvelope:r,isPannable:u,vertices:l,coef:null,bbox:[l[0][0]-t,l[0][1]-t,l[1][0]+t,l[1][1]+t],poleLocation:i};let c=0;const p=[];let[m,d]=l[0],[y,x]=l[0];for(let g=0,A=l.length;g<A;g++){c++,c===A&&(c=0);const[w,v]=l[g],[b,T]=l[c];if(T===v)p.push([w,b,v,T,2]);else{const P=(b-w)/(T-v||1e-4),$=w-P*v;v<T?p.push([P,$,v,T,0]):p.push([P,$,T,v,1])}m=m<w?m:w,d=d<v?d:v,y=y>w?y:w,x=x>v?x:v}return{isEnvelope:!1,isPannable:u,vertices:l,coef:p,bbox:[m,d,y,x],poleLocation:i}}function hs(n,t){const e=[],{cols:s,rows:o,xres:r,yres:a,usePixelCenter:i}=n;let{xmin:u,ymax:l}=n;if(i&&(u+=r/2,l-=a/2),t==null){for(let d=0;d<s;d++)for(let y=0;y<o;y++)e.push([u+r*d,l-a*y]);return{points:e}}const c=new Uint8Array(s*o);if(t.isEnvelope){const{bbox:[d,y,x,g]}=t;for(let A=0,w=0;A<s;A++){const v=u+r*A,b=t.isPannable||v>=d&&v<=x;for(let T=0;T<o;T++,w++){const P=l-a*T;b&&P>=y&&P<=g&&(e.push([v,P]),c[w]=1)}}return{points:e,mask:c}}const p=t.coef,m=[];for(let d=0;d<o;d++){const y=l-a*d,x=[],g=[];for(let w=0;w<p.length;w++){const[v,b,T,P,$]=p[w];if(y===T&&T===P)x.push(v),x.push(b),g.push(2),g.push(2);else if(y>=T&&y<=P){const F=v*y+b;x.push(F),g.push($)}}let A=x;if(x.length>2){let w=g[0]===2?0:g[0],v=x[0];A=[];for(let b=1;b<g.length;b++)g[b]===2&&b!==g.length-1||(g[b]!==w&&(A.push(w===0?Math.min(v,x[b-1]):Math.max(v,x[b-1])),w=g[b],v=x[b]),b===g.length-1&&A.push(g[b]===0?Math.min(v,x[b]):Math.max(v,x[b])));A.sort(((b,T)=>b-T))}else x[0]>x[1]&&(A=[x[1],x[0]]);m.push(A)}for(let d=0,y=0;d<s;d++){const x=u+r*d;for(let g=0;g<o;g++,y++){const A=l-a*g,w=m[g];if(w.length===2)x>=w[0]&&x<=w[1]&&(e.push([x,A]),c[y]=1);else if(w.length>2){let v=!1;for(let b=0;b<w.length;b+=2)if(x>=w[b]&&x<=w[b+1]){v=!0;break}v&&(e.push([x,A]),c[y]=1)}}}return{points:e,mask:c}}function So(n,t){const[e,s]=t;for(let o=0;o<n.length;o++){const r=n[o][1];(r<e||r>s)&&(n[o]=[NaN,NaN])}}function Co(n,t){const e=ut(n[0].spatialReference);if(n.length<2||e==null||(t=t??H(n[0].spatialReference),(n=n.filter((i=>i.width>t))).length===1))return n[0];let{xmin:s,xmax:o,ymin:r,ymax:a}=n[0];for(let i=1;i<n.length;i++){const u=n[i];o=u.xmax+e*i,r=Math.min(r,u.ymin),a=Math.max(a,u.ymax)}return new Bt({xmin:s,xmax:o,ymin:r,ymax:a,spatialReference:n[0].spatialReference})}function fn(n,t,e=null,s=!0){const o=n.spatialReference;if(o.equals(t)||!t)return n;const r=jo(n),a=ut(o,!0),i=ut(t);if(r===0||a==null||i==null){const c=Es(n,t,e,s);if(c&&a==null&&i!=null&&Math.abs(c.width-i)<H(t)&&st.isLoaded()){const p=zt(o);if(p!=null&&p.poleLocation===ze.None&&n.width<(p.bbox[2]-p.bbox[0])/2)return Bo(n,t)||c}return c}const u=n.clone().normalize();if(u.length===1&&n.xmax<a&&n.xmax-a/2>H(o)){const{xmin:c,xmax:p}=n;for(let m=0;m<=r;m++){const d=m===0?c:-a/2,y=m===r?p-a*m:a/2;u[m]=new Bt({xmin:d,xmax:y,ymin:n.ymin,ymax:n.ymax,spatialReference:o})}}const l=u.map((c=>Es(c,t,e,s))).filter(Pn);return l.length===0?null:Co(l)}function Mo(n,t,e){if(n.type==="extent"){const{xmin:s,ymin:o,xmax:r,ymax:a,spatialReference:i}=n;n=new Ks({rings:[[[s,a],[r,a],[r,o],[s,o],[s,a]]],spatialReference:i})}return n.spatialReference.equals(t)?n:(ae(),st.execute(n,t,{geographicTransformation:e}))}function Bo(n,t){const e=ut(t);if(e==null)return null;let{xmin:s,ymin:o,xmax:r,ymax:a}=n;const i=n.spatialReference,u=new Ks({spatialReference:i,rings:[[[s,o],[r,o],[r,a],[s,a],[s,o]]]}),l=st.execute(u,t);if(l.rings.length!==2||!l.rings[0].length||!l.rings[1].length)return null;const{rings:c}=l,p=H(i),m=new Bt({spatialReference:t});for(let d=0;d<2;d++){s=r=c[d][0][0],o=a=c[d][0][1];for(let y=0;y<c[d].length;y++)s=s>c[d][y][0]?c[d][y][0]:s,r=r<c[d][y][0]?c[d][y][0]:r,o=o>c[d][y][1]?c[d][y][1]:o,a=a<c[d][y][1]?c[d][y][1]:a;if(d===0)m.ymin=o,m.ymax=a,m.xmin=s,m.xmax=r;else if(m.ymin=Math.min(m.ymin,o),m.ymax=Math.max(m.ymax,a),Math.abs(r-e/2)<p)m.xmin=s,m.xmax=m.xmax+e;else{if(!(Math.abs(s+e/2)<p))return null;m.xmax=r+e}}return m}function Es(n,t,e,s=!0,o=!0){const r=n.spatialReference;if(r.equals(t)||!t)return n;ae();const a=st.execute(n,t,{geographicTransformation:e});if(o&&t.isWebMercator&&a&&(a.ymax=Math.min(20037508342787e-6,a.ymax),a.ymin=Math.max(-20037508342787e-6,a.ymin),a.ymin>=a.ymax))return null;if(!s||!a)return a;const i=ve(r,!0),u=ve(t,!0);if(i==null||u==null)return a;const l=H(r,.001),c=H(r,be),p=H(t,.001);if(Math.abs(a.xmin-u[0])<p&&Math.abs(a.xmax-u[1])<p){const m=Math.abs(n.xmin-i[0]),d=Math.abs(i[1]-n.xmax);if(m<l&&d>c){a.xmin=u[0];const y=[];y.push(new K(n.xmax,n.ymin,r)),y.push(new K(n.xmax,(n.ymin+n.ymax)/2,r)),y.push(new K(n.xmax,n.ymax,r));const x=y.map((g=>js(g,t,e))).filter((g=>!isNaN(g==null?void 0:g.x))).map((g=>g.x));a.xmax=Math.max.apply(null,x)}if(d<l&&m>c){a.xmax=u[1];const y=[];y.push(new K(n.xmin,n.ymin,r)),y.push(new K(n.xmin,(n.ymin+n.ymax)/2,r)),y.push(new K(n.xmin,n.ymax,r));const x=y.map((g=>js(g,t,e))).filter((g=>!isNaN(g==null?void 0:g.x))).map((g=>g.x));a.xmin=Math.min.apply(null,x)}}else{const m=H(t,.001);Math.abs(a.xmin-u[0])<m&&(a.xmin=u[0]),Math.abs(a.xmax-u[1])<m&&(a.xmax=u[1])}return a}function ut(n,t=!1){if(!n)return null;const e=t?20037508342787e-6:20037508342788905e-9;return n.isWebMercator?2*e:n.wkid&&n.isGeographic?360:2*No[n.wkid]||null}function ve(n,t=!1){if(n.isGeographic)return[-180,180];const e=ut(n,t);return e!=null?[-e/2,e/2]:null}function Os(n,t,e,s){let o=(n-t)/e;return o-Math.floor(o)!==0?o=Math.floor(o):s&&(o-=1),o}function jo(n,t=!1){const e=ut(n.spatialReference);if(e==null)return 0;const s=t?0:-(e/2),o=H(n.spatialReference),r=!t&&Math.abs(n.xmax-e/2)<o?e/2:n.xmax,a=!t&&Math.abs(n.xmin+e/2)<o?-e/2:n.xmin;return Os(r,s,e,!0)-Os(a,s,e,!1)}function va(n){const t=n.storageInfo.origin.x,e=ut(n.spatialReference,!0);if(e==null)return{originX:t,halfWorldWidth:null,pyramidsInfo:null};const s=e/2,{nativePixelSize:o,storageInfo:r,extent:a}=n,{maximumPyramidLevel:i,blockWidth:u,pyramidScalingFactor:l}=r;let c=o.x;const p=[],m=n.transform!=null&&n.transform.type==="gcs-shift",d=t+(m?0:s),y=m?e-t:s-t;for(let x=0;x<=i;x++){const g=(a.xmax-t)/c/u,A=g-Math.floor(g)===0?g:Math.ceil(g),w=y/c/u,v=w-Math.floor(w)===0?w:Math.ceil(w),b=Math.floor(d/c/u),T=Math.round(d/c)%u,P=(u-Math.round(y/c)%u)%u;p.push({resolutionX:c,blockWidth:u,datasetColumnCount:A,worldColumnCountFromOrigin:v,leftMargin:T,rightPadding:P,originColumnOffset:b}),c*=l}return{originX:t,halfWorldWidth:s,pyramidsInfo:p,hasGCSSShiftTransform:m}}function Go(n){if(!n||n.isGeographic)return n;const t=String(n.wkid||n.wkt2||n.wkt);let e;return ke.has(t)?e=ke.get(t):(e=(n.wkid?et.coordsys(n.wkid):et.fromString(tt.PE_TYPE_PROJCS,n.wkt2||n.wkt)).getGeogcs().getCode(),ke.set(t,e)),new $n({wkid:e})}function Aa(n){const t=n.isAdaptive&&n.spacing==null;let e=n.spacing||[xe,xe],s=Ie(n),o={cols:s.size[0]+1,rows:s.size[1]+1};const r=s.outofBoundPointCount>0&&s.outofBoundPointCount<s.offsets.length/2;let a=s.outofBoundPointCount===s.offsets.length/2||t&&r?[0,0]:Bs(s.offsets,o,e,Ne);const i=(a[0]+a[1])/2,u=n.projectedExtent.spatialReference,l=n.srcBufferExtent.spatialReference;if(t&&(r||i>Ne)&&(u.isGeographic||zt(u),e=[we,we],s=Ie({...n,spacing:e}),o={cols:s.size[0]+1,rows:s.size[1]+1},a=Bs(s.offsets,o,e,Ne)),s.error=a,e[0]>1&&(s.coefficients=Ds(s.offsets,o,r)),n.includeGCSGrid&&!u.isGeographic&&!u.isWebMercator)if(l.isGeographic)s.gcsGrid={offsets:s.offsets,coefficients:s.coefficients,spacing:e};else{const c=zt(u);if(c!=null&&!c.isEnvelope){const p=Go(u),m=fn(n.projectedExtent,p),{offsets:d}=Ie({...n,srcBufferExtent:m,spacing:e}),y=Ds(d,o,r);s.gcsGrid={offsets:d,coefficients:y,spacing:e}}}return s}function Ie(n){const{projectedExtent:t,srcBufferExtent:e,pixelSize:s,datumTransformation:o,rasterTransform:r}=n,a=t.spatialReference,i=e.spatialReference;ae();const{xmin:u,ymin:l,xmax:c,ymax:p}=t,m=ut(i),d=m!=null&&(n.hasWrapAround||(r==null?void 0:r.type)==="gcs-shift"),y=n.spacing||[xe,xe],x=y[0]*s.x,g=y[1]*s.y,A=y[0]===1,w=Math.ceil((c-u)/x-.1/y[0])+(A?0:1),v=Math.ceil((p-l)/g-.1/y[1])+(A?0:1),b=ko({cols:w,rows:v,xmin:u,ymax:p,xres:x,yres:g,inSR:a,outSR:i,datumTransformation:o,preferPE:y[0]<=we,usePixelCenter:A}),T=[];let P,$=0;const F=A?-1:NaN,{xmin:k,xmax:_,ymax:S,width:B,height:X}=e,ue=H(i,be),Zt=m!=null&&k>0&&_>m/2,Et=zt(a),le=Et!=null&&Et.poleLocation>0;for(let Qt=0;Qt<w;Qt++){const Te=[];for(let te=0;te<v;te++){let V=b[Qt*v+te];if(d&&V[0]>_&&V[0]>m/2-ue?V[0]-=m:d&&Qt===0&&V[0]<0&&Zt&&!r&&(V[0]+=m),!V||isNaN(V[0])||isNaN(V[1]))T.push(F),T.push(F),Te.push(null),$++;else{if(r){const ds=r.inverseTransform(new K({x:V[0],y:V[1],spatialReference:i}));V=[ds.x,ds.y]}Te.push(V),Qt>0&&d&&P[te]&&V[0]<P[te][0]&&(V[0]+=m,le&&V[0]>_&&V[0]>m&&(V[0]-=m)),T.push((V[0]-k)/B),T.push((S-V[1])/X)}}P=Te}return{offsets:T,error:null,coefficients:null,outofBoundPointCount:$,spacing:y,size:A?[w,v]:[w-1,v-1]}}function Ds(n,t,e){const{cols:s,rows:o}=t,r=new Float32Array((s-1)*(o-1)*2*6),a=new Float32Array([-0,-1,1,-1,1,-0,1,-0,-0]),i=new Float32Array([-1,1,0,0,-1,1,1,0,0]);for(let u=0;u<s-1;u++){for(let l=0;l<o-1;l++){let c=u*o*2+2*l;const p=n[c],m=n[c+1],d=n[c+2],y=n[c+3];c+=2*o;const x=n[c],g=n[c+1],A=n[c+2],w=n[c+3];let v=0,b=12*(l*(s-1)+u);for(let T=0;T<3;T++)r[b++]=a[v++]*p+a[v++]*d+a[v++]*A;v=0;for(let T=0;T<3;T++)r[b++]=a[v++]*m+a[v++]*y+a[v++]*w;v=0;for(let T=0;T<3;T++)r[b++]=i[v++]*p+i[v++]*x+i[v++]*A;v=0;for(let T=0;T<3;T++)r[b++]=i[v++]*m+i[v++]*g+i[v++]*w}if(e)for(let l=0;l<r.length;l++)isNaN(r[l])&&(r[l]=-1)}return r}function Ta(n){const{spatialReference:t}=n,e=Rn(t);if(!e)return n;const[s,o]=e.valid,r=o-s;let a=0;if(n.xmin<s){const i=s-n.xmin;a=Math.ceil(i/r)}else if(n.xmin>o){const i=n.xmin-o;a=-Math.ceil(i/r)}return new Bt({spatialReference:n.spatialReference,xmin:n.xmin+a*r,ymin:n.ymin,xmax:n.xmax+a*r,ymax:n.ymax})}function Pa(n,t,e){var y;const{storageInfo:s,pixelSize:o}=t;let r=0,a=!1;const{pyramidResolutions:i}=s,u=((y=s.tileInfo.format)==null?void 0:y.toLowerCase())==="mixed"?Math.max(1,Math.min(3,s.tileInfo.dpi/96)):1,l=(n.x+n.y)/2/u;if(i!=null&&i.length){const x=i[i.length-1],g=(x.x+x.y)/2,A=(o.x+o.y)/2;if(l<=A)r=0;else if(l>=g)r=i.length,a=l/g>8;else{let v,b=A;for(let T=1;T<=i.length;T++){if(v=(i[T-1].x+i[T-1].y)/2,l<=v){l===v?r=T:e==="down"?(r=T-1,a=l/b>8):r=e==="up"||l-b>v-l||l/b>2?T:T-1;break}b=v}}const w=r===0?o:i[r-1];return a&&Math.min(w.x,w.y)*jt(t.spatialReference)>19567&&(a=!1),{pyramidLevel:r,pyramidResolution:new K({x:w.x,y:w.y,spatialReference:t.spatialReference}),excessiveReading:a}}const c=Math.log(n.x/o.x)/Math.LN2,p=Math.log(n.y/o.y)/Math.LN2,m=t.storageInfo.maximumPyramidLevel||0;r=e==="down"?Math.floor(Math.min(c,p)):e==="up"?Math.ceil(Math.max(c,p)):Math.round((c+p)/2),r<0?r=0:r>m&&(a=r>m+3,r=m);const d=2**r;return{pyramidLevel:r,pyramidResolution:new K({x:d*t.nativePixelSize.x,y:d*t.nativePixelSize.y,spatialReference:t.spatialReference}),excessiveReading:a}}let gt=class extends z{constructor(){super(...arguments),this.functionName="Clip",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{functionArguments:e}=this,{clippingGeometry:s,clippingType:o}=e;if(!s)return{success:!1,supportsGPU:!1,error:"missing clipping geometry"};if(o==="outside")try{const{spatialReference:r}=t,a=s.type==="extent"?fn(s,r):Mo(s,r).extent;a&&Ro(t,a)}catch{}return{success:!0,supportsGPU:!0}}_processPixels(t){var e;return(e=t.pixelBlocks)==null?void 0:e[0]}_getWebGLParameters(){const{clippingGeometry:t,clippingType:e}=this.functionArguments;return{clippingGeometry:t.toJSON(),clippingType:e}}};h([f({json:{write:!0,name:"rasterFunction"}})],gt.prototype,"functionName",void 0),h([f({type:xo,json:{write:!0,name:"rasterFunctionArguments"}})],gt.prototype,"functionArguments",void 0),h([f()],gt.prototype,"rasterArgumentNames",void 0),h([f()],gt.prototype,"isNoopProcess",void 0),gt=h([N("esri.layers.support.rasterFunctions.ClipFunction")],gt);const zo=gt;var Ee;let Q=Ee=class extends O{castColormapName(n){if(!n)return null;const t=n.toLowerCase();return Bn.includes(t)?t:null}readColorRamp(n){return Xs(n)}readColorRampName(n,t){if(!n)return null;const e=Mt.jsonValues.find((s=>s.toLowerCase()===n.toLowerCase()));return e?Mt.fromJSON(e):null}clone(){var n;return new Ee({colormap:J(this.colormap),colormapName:this.colormapName,colorRamp:(n=this.colorRamp)==null?void 0:n.clone(),colorRampName:this.colorRampName})}};h([f({type:[[Number]],json:{write:!0}})],Q.prototype,"colormap",void 0),h([f({type:String,json:{write:!0}})],Q.prototype,"colormapName",void 0),h([Js("colormapName")],Q.prototype,"castColormapName",null),h([f({types:_n,json:{write:!0}})],Q.prototype,"colorRamp",void 0),h([oe("colorRamp")],Q.prototype,"readColorRamp",null),h([f({type:Mt.apiValues,json:{type:Mt.jsonValues,write:Mt.write}})],Q.prototype,"colorRampName",void 0),h([oe("colorRampName")],Q.prototype,"readColorRampName",null),Q=Ee=h([N("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],Q);const Eo=Q,Oo=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[112,75,3],[113,76,3],[114,77,3],[115,77,3],[116,78,3],[117,79,3],[118,79,3],[119,80,3],[121,81,4],[122,82,4],[123,82,4],[124,83,4],[125,84,4],[126,84,4],[127,85,4],[128,86,4],[129,86,4],[130,87,4],[131,88,4],[132,89,4],[133,89,4],[134,90,4],[135,91,4],[136,91,4],[137,92,4],[138,93,4],[139,94,4],[140,94,4],[142,95,5],[143,96,5],[144,96,5],[145,97,5],[146,98,5],[147,99,5],[148,99,5],[149,100,5],[150,101,5],[151,101,5],[152,102,5],[153,103,5],[154,104,5],[155,104,5],[156,105,5],[157,106,5],[158,106,5],[159,107,5],[160,108,5],[161,108,5],[162,109,5],[164,110,6],[165,111,6],[166,111,6],[167,112,6],[168,113,6],[169,113,6],[170,114,6],[171,115,6],[172,116,6],[173,116,6],[174,117,6],[245,0,0],[245,5,0],[245,10,0],[246,15,0],[246,20,0],[246,25,0],[246,30,0],[247,35,0],[247,40,0],[247,45,0],[247,50,0],[247,55,0],[248,60,0],[248,65,0],[248,70,0],[248,75,0],[249,81,0],[249,86,0],[249,91,0],[249,96,0],[250,101,0],[250,106,0],[250,111,0],[250,116,0],[250,121,0],[251,126,0],[251,131,0],[251,136,0],[251,141,0],[252,146,0],[252,151,0],[252,156,0],[252,156,0],[251,159,0],[250,162,0],[249,165,0],[248,168,0],[247,171,0],[246,174,0],[245,177,0],[245,179,0],[244,182,0],[243,185,0],[242,188,0],[241,191,0],[240,194,0],[239,197,0],[238,200,0],[237,203,0],[236,206,0],[235,209,0],[234,212,0],[233,215,0],[232,218,0],[231,221,0],[230,224,0],[230,226,0],[229,229,0],[228,232,0],[227,235,0],[226,238,0],[225,241,0],[224,244,0],[223,247,0],[165,247,0],[163,244,0],[161,240,0],[158,237,0],[156,233,1],[154,230,1],[152,227,1],[149,223,1],[147,220,1],[145,216,1],[143,213,1],[140,210,2],[138,206,2],[136,203,2],[134,200,2],[132,196,2],[129,193,2],[127,189,2],[125,186,3],[123,183,3],[120,179,3],[118,176,3],[116,172,3],[114,169,3],[111,166,3],[109,162,4],[107,159,4],[105,155,4],[103,152,4],[100,149,4],[98,145,4],[96,142,4],[94,138,5],[91,135,5],[89,132,5],[87,128,5],[85,125,5],[82,121,5],[80,118,5],[78,115,6],[76,111,6],[73,108,6],[71,105,6],[69,101,6],[67,98,6],[65,94,6],[62,91,7],[60,88,7],[58,84,7],[56,81,7],[53,77,7],[51,74,7],[49,71,7],[47,67,8],[44,64,8],[42,60,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8]],Do=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[245,20,0],[245,24,0],[245,29,0],[245,31,0],[247,33,0],[247,33,0],[247,37,0],[247,41,0],[247,41,0],[247,41,0],[247,45,0],[247,45,0],[247,47,0],[247,49,0],[247,49,0],[247,54,0],[247,54,0],[247,56,0],[247,58,0],[247,58,0],[250,62,0],[250,62,0],[250,62,0],[250,67,0],[250,67,0],[250,67,0],[250,69,0],[250,71,0],[250,71,0],[250,75,0],[250,75,0],[250,78,0],[250,79,0],[250,79,0],[250,79,0],[250,81,0],[250,83,0],[250,83,0],[250,87,0],[250,87,0],[250,90,0],[250,92,0],[252,93,0],[252,93,0],[252,97,0],[252,97,0],[252,97,0],[252,97,0],[252,101,0],[252,101,0],[252,101,0],[252,101,0],[252,105,0],[252,105,0],[252,107,0],[252,109,0],[252,109,0],[252,113,13],[255,118,20],[255,119,23],[255,121,25],[255,126,33],[255,132,38],[255,133,40],[255,135,43],[255,141,48],[255,144,54],[255,150,59],[255,152,61],[255,153,64],[255,159,69],[255,163,77],[255,165,79],[255,168,82],[255,174,87],[255,176,92],[255,181,97],[255,183,99],[255,186,102],[255,191,107],[255,197,115],[255,201,120],[255,203,123],[255,205,125],[255,209,130],[255,214,138],[255,216,141],[255,218,143],[255,224,150],[255,228,156],[255,234,163],[255,236,165],[255,238,168],[255,243,173],[255,248,181],[255,252,186],[253,252,186],[250,252,187],[244,250,180],[238,247,176],[234,246,173],[231,245,169],[223,240,163],[217,237,157],[211,235,150],[205,233,146],[200,230,142],[195,227,136],[189,224,132],[184,222,126],[180,220,123],[174,217,119],[169,214,114],[163,212,108],[160,210,105],[154,207,101],[148,204,96],[143,201,93],[138,199,88],[134,197,84],[130,194,81],[126,191,77],[117,189,70],[115,186,68],[112,184,64],[106,181,60],[100,179,55],[94,176,49],[92,174,47],[90,173,45],[81,168,37],[75,166,33],[71,163,28],[66,160,24],[62,158,21],[56,156,14],[51,153,0],[51,153,0],[51,153,0],[50,150,0],[50,150,0],[50,150,0],[50,150,0],[49,148,0],[49,148,0],[49,148,0],[48,145,0],[48,145,0],[48,145,0],[48,145,0],[48,143,0],[48,143,0],[48,143,0],[48,143,0],[47,140,0],[47,140,0],[47,140,0],[47,140,0],[46,138,0],[46,138,0],[46,138,0],[46,138,0],[45,135,0],[45,135,0],[45,135,0],[45,135,0],[44,133,0],[44,133,0],[44,133,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[42,128,0],[42,128,0],[42,128,0],[42,125,0],[42,125,0],[42,125,0],[42,125,0],[41,122,0],[41,122,0],[41,122,0],[41,122,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[39,117,0],[39,117,0],[39,117,0],[39,117,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0]];function ms(n,t){const e=[],s=[];for(let r=0;r<n.length-1;r++)e.push({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:n[r].slice(1),toColor:n[r+1].slice(1)}),s.push(n[r+1][0]-n[r][0]);const o=n[n.length-1][0];return Zs({type:"multipart",colorRamps:e},{numColors:o,weights:t=t??s})}function Vo(){return ms([[0,0,191,191],[51,0,0,255],[102,255,0,255],[153,255,0,127],[204,191,63,127],[256,20,20,20]])}function Uo(){const n=ms([[0,255,255,255],[70,0,255,0],[80,205,173,193],[100,150,150,150],[110,120,51,100],[130,120,100,200],[140,28,3,144],[160,6,0,55],[180,10,25,30],[201,6,7,27]]);for(let t=n.length;t<256;t++)n.push([6,27,7]);return n}function Lo(){return Zs({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:[0,0,0],toColor:[255,255,255]})}function Wo(){const n=[];for(let t=0;t<256;t++){const e=[];for(let s=0;s<3;s++)e.push(Math.round(255*Math.random()));n.push(e)}return n}function qo(){return ms([[0,38,41,54],[69,79,82,90],[131,156,156,156],[256,253,253,241]],[.268,.238,.495])}function Ho(n){let t;switch(n){case"elevation":t=Vo();break;case"gray":t=Lo();break;case"hillshade":t=qo();break;case"ndvi":t=Oo;break;case"ndvi2":t=Uo();break;case"ndvi3":t=Do;break;case"random":t=Wo()}return t?(t=t.map(((e,s)=>[s,...e])),t):null}let ot=class extends z{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"colormap-function: source data must be single band"};let{colormap:e,colormapName:s,colorRamp:o,colorRampName:r}=this.functionArguments;if(!(e!=null&&e.length))if(o)this.colorRamp=o,e=Se(o,{interpolateAlpha:!0});else if(r){const u=Qs(r);u&&(e=Se(u),this.colorRamp=Xs(u))}else s&&(e=Ho(s));if(!(e!=null&&e.length))return{success:!1,supportsGPU:!1,error:"colormap-function: missing colormap argument"};const a=this._getOutputPixelType(t.pixelType);this.outputPixelType=a.startsWith("f")?"s32":a;const i=t.clone();return i.pixelType=this.outputPixelType,i.colormap=e,i.bandCount=1,this.rasterInfo=i,{success:!0,supportsGPU:!0}}_processPixels(t){var s;let e=(s=t.pixelBlocks)==null?void 0:s[0];return!e||W(e.pixelType)||(e=e.clone(),e.clamp(this.outputPixelType)),e}};h([f({json:{write:!0,name:"rasterFunction"}})],ot.prototype,"functionName",void 0),h([f({type:Eo,json:{write:!0,name:"rasterFunctionArguments"}})],ot.prototype,"functionArguments",void 0),h([f()],ot.prototype,"rasterArgumentNames",void 0),h([f()],ot.prototype,"isNoopProcess",void 0),h([f({json:{write:!0}})],ot.prototype,"indexedColormap",void 0),h([f()],ot.prototype,"colorRamp",void 0),ot=h([N("esri.layers.support.rasterFunctions.ColormapFunction")],ot);const Jo=ot;var Oe;let De=Oe=class extends O{clone(){return new Oe({raster:this.raster})}};De=Oe=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")],De);const Ko=De;let yt=class extends z{constructor(){super(...arguments),this.functionName="ColormapToRGB",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){var a;const t=this.sourceRasterInfos[0];if(t.bandCount>1||!((a=t.colormap)!=null&&a.length))return{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: source data must be single band with a colormap"};const e=t.clone();e.pixelType=this.outputPixelType=this._getOutputPixelType("u8"),this._removeStatsHistColormapVAT(e),e.bandCount=3,e.statistics=[{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20}],this.rasterInfo=e;const s=[...t.colormap].sort(((i,u)=>i[0]-u[0])),{indexedColormap:o,offset:r}=tn({colormap:s});return o?(this.lookup={indexedColormap:o,offset:r},{success:!0,supportsGPU:en(o)}):{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: the colormap is not supported"}}_processPixels(t){var p;let e=(p=t.pixelBlocks)==null?void 0:p[0];if(!e||!this.lookup)return e;e=e.clone();const s=e.pixels[0],o=e.mask??new Uint8Array(s.length).fill(255),r=new Uint8Array(s.length),a=new Uint8Array(s.length),i=new Uint8Array(s.length),{indexedColormap:u,offset:l}=this.lookup,c=u.length;for(let m=0;m<s.length;m++)if(o[m]){let d=4*(s[m]-l);d<0||d>c-4?o[m]=0:(r[m]=u[d++],a[m]=u[d++],i[m]=u[d++])}return e.pixels=[r,a,i],e.statistics=[new Pe(0,255),new Pe(0,255),new Pe(0,255)],e.pixelType=this.outputPixelType,e}_getWebGLParameters(){return this.lookup}};h([f({json:{write:!0,name:"rasterFunction"}})],yt.prototype,"functionName",void 0),h([f({type:Ko,json:{write:!0,name:"rasterFunctionArguments"}})],yt.prototype,"functionArguments",void 0),h([f()],yt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],yt.prototype,"lookup",void 0),yt=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunction")],yt);const Xo=yt;var Ve;let ne=Ve=class extends O{constructor(){super(...arguments),this.rasters=[]}writeRasters(n,t){t.rasters=n.map((e=>typeof e=="number"||typeof e=="string"?e:e.toJSON()))}clone(){return new Ve({rasters:J(this.rasters)})}};h([f({json:{write:!0}})],ne.prototype,"rasters",void 0),h([Ae("rasters")],ne.prototype,"writeRasters",null),ne=Ve=h([N("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],ne);const Yo=ne;let Ut=class extends z{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();if(s.attributeTable=null,s.colormap=null,s.pixelType=this.outputPixelType,s.bandCount=t.map((({bandCount:r})=>r)).reduce(((r,a)=>r+a)),t.every((({statistics:r})=>r!=null&&r.length))){const r=[];t.forEach((({statistics:a})=>a!=null&&r.push(...a))),s.statistics=r}if(t.every((({histograms:r})=>r!=null&&r.length))){const r=[];t.forEach((({histograms:a})=>a!=null&&r.push(...a))),s.histograms=r}s.multidimensionalInfo&&s.multidimensionalInfo.variables.forEach((r=>{const a=t.map((l=>{var c;return(c=l.multidimensionalInfo)==null?void 0:c.variables.find((({name:p})=>p===r.name))})),i=a.map((l=>{var c;return(c=l==null?void 0:l.statistics)!=null&&c.length?l.statistics:null})),u=a.map((l=>{var c;return(c=l==null?void 0:l.histograms)!=null&&c.length?l.histograms:null}));r.statistics=i.every((l=>l!=null))?i.flat():null,r.histograms=u.every((l=>l!=null))?u.flat():null})),s.bandCount>1&&(s.colormap=null,s.attributeTable=null);const o=t.every((r=>{var a;return(a=r.keyProperties.BandProperties)==null?void 0:a.length}))?t.flatMap((r=>r.keyProperties.BandProperties)):void 0;return s.keyProperties={...s.keyProperties,BandProperties:o},this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e?(e==null?void 0:e[0])==null?null:jn(e):null}_getWebGLParameters(){return{bandCount:this.rasterInfo.bandCount}}};h([f({json:{write:!0,name:"rasterFunction"}})],Ut.prototype,"functionName",void 0),h([f({type:Yo,json:{write:!0,name:"rasterFunctionArguments"}})],Ut.prototype,"functionArguments",void 0),h([f()],Ut.prototype,"rasterArgumentNames",void 0),Ut=h([N("esri.layers.support.rasterFunctions.CompositeBandFunction")],Ut);const Zo=Ut,Qo=new rt({0:"difference",1:"relative-difference",2:"categorical",3:"euclidean-distance",4:"angle-difference",5:"band-with-most-change"},{useNumericKeys:!0}),ti=new rt({0:"all",1:"changed",2:"unchanged"},{useNumericKeys:!0});function ei(n,t,e,s){const[o,r]=n,a=W(e)&&!W(o.pixelType)&&!W(r.pixelType),i=[o.mask,r.mask].filter((y=>y)),u=R.combineBandMasks(i),l=n.map((y=>y.pixels[0])),{width:c,height:p}=o,m=R.createEmptyBand(e,c*p);switch(t){case"difference":case"relative-difference":si({bands:l,mask:u,outBand:m,isRoundingNeeded:a,isRelative:t==="relative-difference"});break;case"categorical":ni({bands:l,mask:u,outBand:m,...s});break;case"euclidean-distance":ri({pixels:n.map((y=>y.pixels)),mask:u,outBand:m});break;case"angle-difference":oi({pixels:n.map((y=>y.pixels)),mask:u,outBand:m});break;case"band-with-most-change":ii({pixels:n.map((y=>y.pixels)),mask:u,outBand:m})}const d=new R({width:c,height:p,pixels:[m],pixelType:e,mask:u});return d.updateStatistics(),d}function si(n){const{bands:[t,e],mask:s,isRelative:o,isRoundingNeeded:r,outBand:a}=n,i=t.length;for(let u=0;u<i;u++)if(!s||s[u]){let l=t[u]-e[u];if(o){const c=Math.max(Math.abs(t[u])-Math.abs(e[u]));l=c>0?l/c:0}a[u]=r?Math.round(l):l}}function ni(n){const{bands:[t,e],categoryIndexLookups:[s,o],classNames:[r,a],mask:i,keepMethod:u,outBand:l}=n,c=t.length,p=r.length,m=a.length,d=p*m,y=d+1,x=d+2;for(let g=0;g<c;g++)if(!i||i[g]){const A=t[g],w=e[g],v=s[A],b=o[w],T=r[v],P=a[b];l[g]=v==null||b==null?d:u==="changed"&&T===P?y:u==="unchanged"&&T!==P?x:v*m+b}}function ri(n){const{pixels:[t,e],mask:s,outBand:o}=n,r=t[0].length,a=t.length;for(let i=0;i<r;i++)if(!s||s[i]){let u=0;for(let l=0;l<a;l++){const c=t[l][i]-e[l][i];u+=c*c}o[i]=Math.sqrt(u)}}function oi(n){const{pixels:[t,e],mask:s,outBand:o}=n,r=t[0].length,a=t.length;for(let i=0;i<r;i++)if(!s||s[i]){let u=0,l=0,c=0;for(let m=0;m<a;m++){const d=t[m][i],y=e[m][i];u+=d*y,l+=d*d,c+=y*y}const p=Math.sqrt(l*c);o[i]=p?Math.acos(u/p):1.5707963267948966}}function ii(n){const{pixels:[t,e],mask:s,outBand:o}=n,r=t[0].length,a=t.length;for(let i=0;i<r;i++)if(!s||s[i]){let u=0,l=0;for(let c=0;c<a;c++){const p=Math.abs(t[c][i]-e[c][i]);p>u&&(u=p,l=c)}o[i]=l}}var Ue;let xt=Ue=class extends O{constructor(){super(...arguments),this.method="difference",this.keepMethod="all",this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Ue({raster:this.raster,raster2:this.raster2,method:this.method,keepMethod:this.keepMethod})}};h([nt(Qo)],xt.prototype,"method",void 0),h([nt(ti)],xt.prototype,"keepMethod",void 0),h([f({json:{write:!0}})],xt.prototype,"raster2",void 0),h([f({readOnly:!0})],xt.prototype,"rasters",null),xt=Ue=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")],xt);const ai=xt;let wt=class extends z{constructor(){super(...arguments),this.functionName="ComputeChange",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{method:t}=this.functionArguments,e=this.sourceRasterInfos[0].clone();if(this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),t==="categorical"){const s=this.sourceRasterInfos.map((a=>a.attributeTable)),o=this._getFieldNames(s,"value"),r=s.map((a=>this._getClassFieldName(a)));if(o[0]==null||o[1]==null||r[0]==null||r[1]==null)return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};this._updateAttributeTable(e,o,r)}return e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:t==="difference"||t==="relative-difference"}}_processPixels(t){const{pixelBlocks:e}=t;if((e==null?void 0:e[0])==null||(e==null?void 0:e[1])==null)return null;const{method:s}=this.functionArguments;return ei(e,s,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){const t=this.outputPixelType??"f32";let[e,s]=ft(t);const o=W(t);return o&&(e-=1e-4,s+=1e-4),{method:this.functionArguments.method,domainRange:[e,s],isOutputRounded:o}}_updateAttributeTable(t,e,s){const o=this.sourceRasterInfos.map((b=>b.attributeTable)),r=o.map(((b,T)=>b.features.map((P=>P.attributes[e[T]])))),a=o.map(((b,T)=>b.features.map((P=>P.attributes[s[T]])))),i=r.map((b=>{const T=[];return b.forEach(((P,$)=>T[P]=$)),T})),{keepMethod:u}=this.functionArguments;this._categoryConfig={categoryIndexLookups:i,classNames:a,keepMethod:u};const l=o[0].clone();l.fields=[new lt({name:"OID",type:"oid"}),new lt({name:"Value",type:"integer"}),new lt({name:"ClassName",type:"string"}),new lt({name:"Class_From",type:"string"}),new lt({name:"Class_To",type:"string"})];const c=this._getFieldNames(o,"red"),p=this._getFieldNames(o,"green"),m=this._getFieldNames(o,"blue"),d=[],y=c.length===2&&p.length===2&&m.length===2;y&&(d.push(...o.map(((b,T)=>b.features.map((P=>[P.attributes[c[T]],P.attributes[p[T]],P.attributes[m[T]]]))))),l.fields.push(new lt({name:"Red",type:"integer"}),new lt({name:"Green",type:"integer"}),new lt({name:"Blue",type:"integer"})));const x=l.features[0].clone();x.geometry=null;const g=[],[A,w]=r.map((b=>b.length));let v=1;for(let b=0;b<A;b++){const T=a[0][b];for(let P=0;P<w;P++){const $=a[1][P];if(u==="changed"&&T===$||u==="unchanged"&&T!==$)continue;const F=x.clone();F.attributes={OID:v++,Value:b*w+P,ClassName:T===$?T:`${T} -> ${$}`,Class_From:T,Class_To:$},y&&(F.attributes.Red=d[0][b][0]+d[1][P][0]>>1,F.attributes.Green=d[0][b][1]+d[1][P][1]>>1,F.attributes.Blue=d[0][b][2]+d[1][P][2]>>1),g.push(F)}}if(u==="changed"){const b=x.clone();b.attributes={OID:v++,Value:A*w+1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},g.push(b)}else if(u==="unchanged"){const b=x.clone();b.attributes={OID:v++,Value:A*w+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},g.push(b)}l.features=g,t.attributeTable=l}_getFieldNames(t,e){return t.map((({fields:s})=>{var o;return(o=s.find((r=>r.name.toLowerCase()===e)))==null?void 0:o.name})).filter((s=>s))}_getClassFieldName(t){const e=t.fields.find((s=>s.type==="string"&&s.name.toLowerCase().startsWith("class")))??t.fields.find((s=>s.type==="string"&&s.name.toLowerCase().includes("class")||s.name.toLowerCase().includes("type")||s.name.toLowerCase().includes("name")))??t.fields.find((s=>s.type==="string"));return e==null?void 0:e.name}};h([f({json:{write:!0,name:"rasterFunction"}})],wt.prototype,"functionName",void 0),h([f({type:ai,json:{write:!0,name:"rasterFunctionArguments"}})],wt.prototype,"functionArguments",void 0),h([f()],wt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],wt.prototype,"_categoryConfig",void 0),wt=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunction")],wt);const ui=wt;var Le;let re=Le=class extends O{constructor(){super(...arguments),this.contrastOffset=0,this.brightnessOffset=0}clone(){return new Le({contrastOffset:this.contrastOffset,brightnessOffset:this.brightnessOffset,raster:this.raster})}};h([f({json:{write:!0}})],re.prototype,"contrastOffset",void 0),h([f({json:{write:!0}})],re.prototype,"brightnessOffset",void 0),re=Le=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")],re);const li=re;let bt=class extends z{constructor(){super(...arguments),this.functionName="ContrastBrightness",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];if(e.pixelType!=="u8")return{success:!1,supportsGPU:!1,error:"Only unsigned 8 bit raster is supported by ContrastBrightness function."};this.outputPixelType=this._getOutputPixelType("u8");const s=e.clone();this._removeStatsHistColormapVAT(s),this.rasterInfo=s;const{contrastOffset:o,brightnessOffset:r}=this.functionArguments;return this.lookup=Gn(o,r),{success:!0,supportsGPU:!0}}_processPixels(t){var s;const e=(s=t.pixelBlocks)==null?void 0:s[0];return e==null?null:ls(e,{lut:e.pixels.map((()=>this.lookup)),offset:0,outputPixelType:"u8"})}_getWebGLParameters(){const{contrastOffset:t,brightnessOffset:e}=this.functionArguments;return{contrastOffset:t,brightnessOffset:e}}};h([f({json:{write:!0,name:"rasterFunction"}})],bt.prototype,"functionName",void 0),h([f({type:li,json:{write:!0,name:"rasterFunctionArguments"}})],bt.prototype,"functionArguments",void 0),h([f()],bt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],bt.prototype,"lookup",void 0),bt=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")],bt);const ci=bt;function fs(n,t,e,s,o){const r=Math.floor(s/2);for(let i=0;i<r;i++)for(let u=0;u<t;u++)n[i*t+u]=n[(o-1-i)*t+u],n[(e-1-i)*t+u]=n[(e-o+i)*t+u];const a=Math.floor(o/2);for(let i=0;i<e;i++){const u=i*t;for(let l=0;l<a;l++)n[u+l]=n[u+o-1-l],n[u+t-l-1]=n[u+t+l-o]}}const j=new Map;function pi(n){const t=Math.sqrt(n.length),e=n.slice(0,t),s=[1];for(let o=1;o<t;o++){let r=null;for(let a=0;a<t;a++){const i=n[a+o*t],u=n[a];if(r==null)if(u===0){if(i)return{separable:!1,row:null,col:null}}else r=i/u;else if(i/u!==r)return{separable:!1,row:null,col:null}}if(r==null)return{separable:!1,row:null,col:null};s.push(r)}return{separable:!0,row:e,col:s}}function Vs(n,t,e,s,o,r,a){const i=new Float32Array(t*e),u=r.length,l=a?0:s,c=a?s:0,p=a?1:t;for(let m=l;m<e-l;m++){const d=m*t;for(let y=c;y<t-c;y++){if(o&&!o[d+y])continue;let x=0;for(let g=0;g<u;g++)x+=n[d+y+(g-s)*p]*r[g];i[d+y]=x}}return i}function hi(n,t,e,s,o,r,a){const i=new Float32Array(t*e),u=Math.floor(s/2),l=Math.floor(o/2);for(let c=u;c<e-u;c++){const p=c*t;for(let m=l;m<t-l;m++){if(r&&!r[p+m])continue;let d=0;for(let y=0;y<s;y++)for(let x=0;x<o;x++)d+=n[p+m+(y-u)*t+x-l]*a[y*o+x];i[p+m]=d}}return i}function mi(n,t,e=!0){const{pixels:s,width:o,height:r,pixelType:a,mask:i}=n,u=s.length,l=[],{kernel:c,rows:p,cols:m}=t;for(let d=0;d<u;d++){const y=hi(s[d],o,r,p,m,i,c);e&&fs(y,o,r,p,m),l.push(y)}return new R({width:o,height:r,pixelType:a,pixels:l,mask:i})}function fi(n,t,e,s=!0){const{pixels:o,width:r,height:a,pixelType:i,mask:u}=n,l=o.length,c=[],p=t.length,m=e.length,d=Math.floor(p/2),y=Math.floor(m/2);for(let x=0;x<l;x++){let g=Vs(o[x],r,a,d,u,t,!0);g=Vs(g,r,a,y,u,e,!1),s&&fs(g,r,a,p,m),c.push(g)}return new R({width:r,height:a,pixelType:i,pixels:c,mask:u})}function di(n,t){const e=pi(t.kernel),s=t.mirrorEdges!==!1,o=e.separable?fi(n,e.row,e.col,s):mi(n,t,s),{outputPixelType:r}=t;return r&&o.clamp(r),o}j.set(C.none,[0,0,0,0,1,0,0,0,0]),j.set(C.lineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),j.set(C.lineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),j.set(C.lineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),j.set(C.lineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),j.set(C.gradientNorth,[-1,-2,-1,0,0,0,1,2,1]),j.set(C.gradientWest,[-1,0,1,-2,0,2,-1,0,1]),j.set(C.gradientEast,[1,0,-1,2,0,-2,1,0,-1]),j.set(C.gradientSouth,[1,2,1,0,0,0,-1,-2,-1]),j.set(C.gradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),j.set(C.gradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),j.set(C.smoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),j.set(C.smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),j.set(C.smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),j.set(C.sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),j.set(C.sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),j.set(C.laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),j.set(C.laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),j.set(C.sobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),j.set(C.sobelVertical,[-1,0,1,-2,0,2,-1,0,1]),j.set(C.sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),j.set(C.sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),j.set(C.pointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);var We;let vt=We=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set convolutionType(n){this._set("convolutionType",n);const t=j.get(n);if(!t||n===C.userDefined||n===C.none)return;const e=Math.sqrt(t.length);this._set("kernel",t),this._set("cols",e),this._set("rows",e)}clone(){return new We({cols:this.cols,rows:this.rows,kernel:[...this.kernel],convolutionType:this.convolutionType,raster:J(this.raster)})}};h([f({json:{type:Number,write:!0}})],vt.prototype,"rows",void 0),h([f({json:{type:Number,write:!0}})],vt.prototype,"cols",void 0),h([f({json:{name:"type",type:Number,write:!0}})],vt.prototype,"convolutionType",null),h([f({json:{type:[Number],write:!0}})],vt.prototype,"kernel",void 0),vt=We=h([N("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],vt);const gi=vt,Us=25;let At=class extends z{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}get _normalizedKernel(){const{kernel:t,convolutionType:e}=this.functionArguments,s=t.reduce(((o,r)=>o+r));return e===-1||s===0||s===1?t:t.map((o=>o/s))}_bindSourceRasters(){const{convolutionType:t,rows:e,cols:s,kernel:o}=this.functionArguments;if(!Object.values(C).includes(t))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==C.none&&e*s!==o.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const r=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(r.pixelType);const a=r.clone();a.pixelType=this.outputPixelType;const i=[C.none,C.sharpen,C.sharpen2,C.sharpening3x3,C.sharpening5x5];return(t===-1||this.outputPixelType!=="u8"&&!i.includes(t))&&(a.statistics=null,a.histograms=null),a.colormap=null,a.attributeTable=null,this.rasterInfo=a,{success:!0,supportsGPU:o.length<=Us}}_processPixels(t){var a;const e=(a=t.pixelBlocks)==null?void 0:a[0];if(e==null||this.functionArguments.convolutionType===C.none)return e;const{rows:s,cols:o}=this.functionArguments,{_normalizedKernel:r}=this;return di(e,{kernel:r,rows:s,cols:o,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=new Float32Array(Us),{rows:e,cols:s}=this.functionArguments,{_normalizedKernel:o}=this;for(let r=0;r<e;r++)for(let a=0;a<s;a++)t[5*r+a]=o[r*s+a];return{kernelRows:e,kernelCols:s,kernel:t,clampRange:ft(this.outputPixelType)}}};h([f({json:{write:!0,name:"rasterFunction"}})],At.prototype,"functionName",void 0),h([f({type:gi,json:{write:!0,name:"rasterFunctionArguments"}})],At.prototype,"functionArguments",void 0),h([f()],At.prototype,"rasterArgumentNames",void 0),h([f()],At.prototype,"_normalizedKernel",null),At=h([N("esri.layers.support.rasterFunctions.ConvolutionFunction")],At);const yi=At;var qe;const dn=new rt({0:"standard",1:"planform",2:"profile"},{useNumericKeys:!0});let Lt=qe=class extends O{constructor(){super(...arguments),this.curvatureType="standard",this.zFactor=1}readCurvatureType(n,t){return dn.fromJSON(t.type??t.curvatureType??0)}clone(){return new qe({curvatureType:this.curvatureType,zFactor:this.zFactor,raster:this.raster})}};h([f({json:{write:{target:"type"}}}),nt(dn)],Lt.prototype,"curvatureType",void 0),h([oe("curvatureType",["type","curvatureType"])],Lt.prototype,"readCurvatureType",null),h([f({type:Number,json:{write:!0}})],Lt.prototype,"zFactor",void 0),Lt=qe=h([N("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")],Lt);const xi=Lt;let Tt=class extends z{constructor(){super(...arguments),this.functionName="Curvature",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var e;this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,t.bandCount=1,this._removeStatsHistColormapVAT(t),this.rasterInfo=t,this.isGCS=((e=t.spatialReference)==null?void 0:e.isGeographic)??!1,{success:!0,supportsGPU:!0}}_processPixels(t){var c;const e=(c=t.pixelBlocks)==null?void 0:c[0];if(e==null)return null;const{zFactor:s,curvatureType:o}=this.functionArguments,{extent:r,primaryPixelSizes:a}=t,i=a==null?void 0:a[0],u=i??(r?{x:r.width/e.width,y:r.height/e.height}:{x:1,y:1}),l=this.isGCS&&s>=1?s*ie:s;return zn(e,{zFactor:l,curvatureType:o,resolution:u})}_getWebGLParameters(){const{zFactor:t,curvatureType:e}=this.functionArguments;return{curvatureType:e,zFactor:this.isGCS&&t>=1?t*ie:t}}};h([f({json:{write:!0,name:"rasterFunction"}})],Tt.prototype,"functionName",void 0),h([f({type:xi,json:{write:!0,name:"rasterFunctionArguments"}})],Tt.prototype,"functionArguments",void 0),h([f()],Tt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],Tt.prototype,"isGCS",void 0),Tt=h([N("esri.layers.support.rasterFunctions.CurvatureFunction")],Tt);const wi=Tt;var He;let it=He=class extends O{constructor(){super(...arguments),this.bandIds=[],this.bandNames=[],this.bandWavelengths=[],this.missingBandAction=sn.bestMatch}clone(){var n,t,e;return new He({bandIds:(n=this.bandIds)==null?void 0:n.slice(),bandNames:(t=this.bandNames)==null?void 0:t.slice(),bandWavelengths:(e=this.bandWavelengths)==null?void 0:e.slice(),missingBandAction:this.missingBandAction,method:this.method,wavelengthMatchTolerance:this.wavelengthMatchTolerance})}};h([f({json:{write:!0}})],it.prototype,"bandIds",void 0),h([f({json:{write:!0}})],it.prototype,"bandNames",void 0),h([f({json:{write:!0}})],it.prototype,"bandWavelengths",void 0),h([nt({0:"name",1:"wavelength",2:"id"})],it.prototype,"method",void 0),h([f({json:{write:!0}})],it.prototype,"missingBandAction",void 0),h([f({json:{write:!0}})],it.prototype,"wavelengthMatchTolerance",void 0),it=He=h([N("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],it);const bi=it;let Wt=class extends z{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){var A;const{functionArguments:t,sourceRasterInfos:e}=this,s=e[0],{method:o,bandNames:r,bandWavelengths:a,bandIds:i,missingBandAction:u}=t,l=(r==null?void 0:r.length)&&(o==="name"||o!=="id"&&!(i!=null&&i.length)),c=(a==null?void 0:a.length)&&(o==="wavelength"||o!=="id"&&!(i!=null&&i.length)),p=u===sn.fail,m=l?Ai(s,r):c?Pi(s,a,this.functionArguments,p):Ti(s,i,p);if(m==null)return{success:!1,supportsGPU:!1,error:`extract-band-function: Invalid ${l?"band names":c?"band wavelengths":"band ids"} for the imagery data source`};this.functionArguments.bandIds=m,this.functionArguments.method="id",this.outputPixelType=this._getOutputPixelType("f32");const d=s.clone();d.pixelType=this.outputPixelType,d.bandCount=m.length;const{statistics:y,histograms:x}=d;y!=null&&y.length&&(d.statistics=m.map((w=>y[w]||y[y.length-1]))),x!=null&&x.length&&(d.histograms=m.map((w=>x[w]||x[x.length-1]))),d.multidimensionalInfo&&d.multidimensionalInfo.variables.forEach((w=>{const{statistics:v,histograms:b}=w;v!=null&&v.length&&(w.statistics=m.map((T=>v[T]||v[v.length-1]))),b!=null&&b.length&&(w.histograms=m.map((T=>b[T]||b[b.length-1])))}));let g=(A=d.keyProperties)==null?void 0:A.BandProperties;return g!=null&&g.length&&(g=m.map((w=>w>=g.length?g[g.length-1]:g[w])),d.keyProperties={...d.keyProperties,BandProperties:g}),this.rasterInfo=d,{success:!0,supportsGPU:d.bandCount<=3}}_processPixels(t){var r;const e=(r=t.pixelBlocks)==null?void 0:r[0];if(e==null)return null;const s=e.pixels.length,o=this.functionArguments.bandIds.map((a=>a>=s?s-1:a));return e.extractBands(o)}_getWebGLParameters(){let t;if(this.isInputBandIdsSwizzled)t=this.swizzledBandSelection.length?this.swizzledBandSelection:[0,1,2];else{t=[...this.functionArguments.bandIds],t.length===0?t=[0,1,2]:t.length<3&&(t[1]=t[1]??t[0],t[2]=t[2]??t[1]);for(let e=0;e<3;e++)t[e]=Math.min(t[e],2)}return{bandIndexMat3:U(t)}}_getInputBandIds(t){const e=t.length;return this.functionArguments.bandIds.map((s=>s>=e?e-1:s)).map((s=>t[s]))}_swizzleBandIds(t){const e=this.functionArguments.bandIds.map((s=>t.indexOf(s)));return this.isInputBandIdsSwizzled=!0,e[1]??(e[1]=e[0]),e[2]??(e[2]=e[1]),this.swizzledBandSelection=e,!1}};h([f({json:{write:!0,name:"rasterFunction"}})],Wt.prototype,"functionName",void 0),h([f({type:bi,json:{write:!0,name:"rasterFunctionArguments"}})],Wt.prototype,"functionArguments",void 0),h([f()],Wt.prototype,"rasterArgumentNames",void 0),Wt=h([N("esri.layers.support.rasterFunctions.ExtractBandFunction")],Wt);const vi=Wt;function Ai(n,t){const e=n.bandInfos.map((({name:o})=>o.toLowerCase())),s=[];for(let o=0;o<t.length;o++){const r=t[o].toLowerCase();let a=e.indexOf(r);if(a===-1&&r==="nearinfrared"&&(a=e.findIndex((i=>i.startsWith("nearinfrared_1"))),a===-1&&(a=e.findIndex((i=>i.startsWith("nearinfrared"))))),a===-1)return null;s.push(a)}return s}function Ti(n,t,e){const{bandCount:s}=n;return!(t!=null&&t.length)||e&&t.some((o=>o<0||o>=s))?null:t}function Pi(n,t,{wavelengthMatchTolerance:e},s){const{bandInfos:o}=n,r=[];for(let i=0;i<o.length;i++){const{minWavelength:u,maxWavelength:l}=o[i];if(!u||!l)return null;r.push({minWavelength:u,maxWavelength:l})}const a=[];for(let i=0;i<t.length;i++){const u=t[i];let l=!1,c=-1,p=Number.MAX_VALUE;for(let m=0;m<r.length;m++){const d=r[m],y=u>=d.minWavelength&&u<=d.maxWavelength,x=Math.abs(u-(d.minWavelength+d.maxWavelength)/2);y?x<p&&(l=!0,c=m,p=x):!l&&x<p&&(c=m,p=x)}if(!l&&e&&p<e&&(l=!0),!l&&s)return null;a.push(c)}return a}function Ri(n,t,e){const{pixels:s,width:o,height:r,mask:a,bandMasks:i}=n,u=o*r,l=i!=null&&i.length?R.combineBandMasks(i):a,c=Math.min(t.length,s.length),p=e.startsWith("f"),m=!p&&e!==n.pixelType,[d,y]=ft(e),x=R.createEmptyBand(e,u);for(let A=0;A<r;A++){let w=A*o;for(let v=0;v<o;v++,w++)if(!l||l[w]){let b=0;for(let T=0;T<c;T++)b+=t[T]*s[T][w];p||(b=Math.round(b),m&&(b=b>y?y:b<d?d:b)),x[w]=b}}const g=new R({width:o,height:r,pixels:[x],pixelType:e,mask:l});return g.updateStatistics(),g}var Je;let me=Je=class extends O{clone(){return new Je({conversionParameters:[...this.conversionParameters],raster:this.raster})}};h([f({type:[Number],json:{write:!0}})],me.prototype,"conversionParameters",void 0),me=Je=h([N("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")],me);const $i=me;let Pt=class extends z{constructor(){super(...arguments),this.functionName="Grayscale",this.functionArguments=null,this.rasterArgumentNames=["raster"]}get _normalizedWeights(){const{conversionParameters:t}=this.functionArguments,e=t.reduce(((s,o)=>s+o));return t.map((s=>s/e))}_bindSourceRasters(){const{conversionParameters:t}=this.functionArguments;if(!(t!=null&&t.length))return{success:!1,supportsGPU:!1,error:"missing valid conversion parameters."};const e=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType;const s=t.length===3||e.bandCount===3&&t.length>3;return e.bandCount=1,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:s}}_processPixels(t){var s;const e=(s=t.pixelBlocks)==null?void 0:s[0];return e==null?null:Ri(e,this._normalizedWeights,this.outputPixelType)}_getWebGLParameters(){return{weights:this._normalizedWeights}}};h([f({json:{write:!0,name:"rasterFunction"}})],Pt.prototype,"functionName",void 0),h([f({type:$i,json:{write:!0,name:"rasterFunctionArguments"}})],Pt.prototype,"functionArguments",void 0),h([f()],Pt.prototype,"rasterArgumentNames",void 0),h([f()],Pt.prototype,"_normalizedWeights",null),Pt=h([N("esri.layers.support.rasterFunctions.GrayscaleFunction")],Pt);const Ni=Pt;var Ke;const Fi=new rt({0:"traditional",1:"multi-directional"},{useNumericKeys:!0}),ki=new rt({1:"degree",2:"percent-rise",3:"scaled"},{useNumericKeys:!0});let Y=Ke=class extends O{constructor(){super(...arguments),this.altitude=45,this.azimuth=315,this.hillshadeType="traditional",this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.slopeType="degree",this.zFactor=1,this.removeEdgeEffect=!1}clone(){return new Ke({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([f({type:Number,json:{write:!0}})],Y.prototype,"altitude",void 0),h([f({type:Number,json:{write:!0}})],Y.prototype,"azimuth",void 0),h([f(),nt(Fi)],Y.prototype,"hillshadeType",void 0),h([f({type:Number,json:{write:!0,name:"psPower"}})],Y.prototype,"pixelSizePower",void 0),h([f({type:Number,json:{write:!0,name:"psZFactor"}})],Y.prototype,"pixelSizeFactor",void 0),h([f(),nt(ki)],Y.prototype,"slopeType",void 0),h([f({type:Number,json:{write:!0}})],Y.prototype,"zFactor",void 0),h([f({type:Boolean,json:{write:!0}})],Y.prototype,"removeEdgeEffect",void 0),Y=Ke=h([N("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")],Y);const gn=Y;let Rt=class extends z{constructor(){super(...arguments),this.functionName="Hillshade",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var s;const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"hillshade-function: source data must be single band"};this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone();return this._removeStatsHistColormapVAT(e),e.pixelType=this.outputPixelType,e.bandCount=1,e.statistics=[{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=e,this.isGCS=((s=e.spatialReference)==null?void 0:s.isGeographic)??!1,{success:!0,supportsGPU:!0}}_processPixels(t){var l;const e=(l=t.pixelBlocks)==null?void 0:l[0];if(!e)return null;const{extent:s,primaryPixelSizes:o}=t,r=o==null?void 0:o[0],a=r??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1}),i=ge(this.functionArguments,a,this.isGCS),u=nn(e,i);return u.pixelType=this.outputPixelType,u}_getWebGLParameters(){const t=ge(this.functionArguments,{x:1,y:1},this.isGCS),e=rn(t),{slopeType:s,zFactor:o,pixelSizeFactor:r,pixelSizePower:a}=this.functionArguments,i=s==="scaled",u=W(this.outputPixelType);return{...e,zFactor:o,gcsFactor:this.isGCS?ie:1,pixelSizeFactor:i?r:0,pixelSizePower:i?a:0,isOutputRounded:u}}};h([f({json:{write:!0,name:"rasterFunction"}})],Rt.prototype,"functionName",void 0),h([f({type:gn,json:{write:!0,name:"rasterFunctionArguments"}})],Rt.prototype,"functionArguments",void 0),h([f()],Rt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],Rt.prototype,"isGCS",void 0),Rt=h([N("esri.layers.support.rasterFunctions.HillshadeFunction")],Rt);const _i=Rt;var Xe;let $t=Xe=class extends O{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!0}writeRasters(n,t){t.rasters=n.map((e=>typeof e=="number"||typeof e=="string"?e:e.toJSON()))}clone(){return new Xe({operation:this.operation,processAsMultiband:this.processAsMultiband,rasters:J(this.rasters)})}};h([f({json:{write:!0}})],$t.prototype,"operation",void 0),h([f({json:{write:!0}})],$t.prototype,"rasters",void 0),h([Ae("rasters")],$t.prototype,"writeRasters",null),h([f({json:{write:!0}})],$t.prototype,"processAsMultiband",void 0),$t=Xe=h([N("esri.layers.support.rasterFunctions.LocalFunctionArguments")],$t);const Ii=$t;let qt=class extends z{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0],{bandCount:s}=e,{processAsMultiband:o}=this.functionArguments;if(t.some((l=>l.bandCount!==s)))return{success:!1,supportsGPU:!1,error:"local-function: input rasters do not have same band count"};const{operation:r,rasters:a}=this.functionArguments,i=bs[r];if(!(i===999||a.length===i||a.length<=1&&i===1))return{success:!1,supportsGPU:!1,error:`local-function: the length of functionArguments.rasters does not match operation's requirement: ${i}`};const u=e.clone();return u.bandCount=i!==999||o?s:1,this._removeStatsHistColormapVAT(u),this._updateStatistics(u),this._updatePixelType(u),this.rasterInfo=u,{success:!0,supportsGPU:u.bandCount===1&&i<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e==null||e.some((s=>s==null))?null:pn(e,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}_getWebGLParameters(){var u;const{operation:t}=this.functionArguments,e=bs[t],s=((u=Object.keys(xs).find((l=>xs[l]===t)))==null?void 0:u.toLowerCase())??"undefined",o=this.outputPixelType??"f32";let[r,a]=ft(o);const i=W(o);return i&&(r-=1e-4,a+=1e-4),{imageCount:e,operationName:s,domainRange:[r,a],isOutputRounded:i}}_updateStatistics(t){var r,a;const e=this.sourceRasterInfos[0],{operation:s}=this.functionArguments,o=(r=ws(s))==null?void 0:r.domain;if(o){t.statistics=[];for(let i=0;i<t.bandCount;i++)t.statistics[i]={min:o[0],max:o[1],avg:(o[0]+o[1])/2,stddev:(o[0]+o[1])/10}}else s===45&&((a=e.statistics)!=null&&a.length)&&(t.statistics=e.statistics.map((i=>({min:-i.max,max:-i.min,avg:i.avg!=null?-i.avg:void 0,stddev:i.stddev!=null?-i.stddev:void 0}))))}_updatePixelType(t){const{statistics:e,pixelType:s}=this.sourceRasterInfos[0],{operation:o}=this.functionArguments,{domain:r,isInteger:a}=ws(o)??{domain:null,isInteger:!1};let i="f32";if(r&&a)i=Re(r[0],r[1]);else if(o===30){const u=e==null?void 0:e[0];i=u?Re(u.min,u.max):W(s)?s:"s32"}else if(o===45&&W(s)){const u=e==null?void 0:e.map((({max:m})=>-m)),l=e==null?void 0:e.map((({min:m})=>-m)),c=u!=null&&u.length?Math.min(...u):null,p=l!=null&&l.length?Math.min(...l):null;i=c!=null&&p!=null?Re(c,p):s.startsWith("s")?s.replace("s","u"):s==="u1"||s==="u2"||s==="u4"?"s8":s==="u8"?"s16":"s32"}t.pixelType=this.outputPixelType=this._getOutputPixelType(i)}};h([f({json:{write:!0,name:"rasterFunction"}})],qt.prototype,"functionName",void 0),h([f({type:Ii,json:{write:!0,name:"rasterFunctionArguments"}})],qt.prototype,"functionArguments",void 0),h([f()],qt.prototype,"rasterArgumentNames",void 0),qt=h([N("esri.layers.support.rasterFunctions.LocalFunction")],qt);const Si=qt;var Ye;let Nt=Ye=class extends O{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=on.matchAny}get normalizedNoDataValues(){const{noDataValues:n}=this;if(!(n!=null&&n.length))return null;let t=!1;const e=n.map((s=>{if(typeof s=="number")return t=!0,[s];if(typeof s=="string"){const o=s.trim().split(" ").filter((r=>r.trim()!=="")).map((r=>Number(r)));return t=t||o.length>0,o.length===0?null:o}return null}));return t?e:null}clone(){var n,t;return new Ye({includedRanges:((n=this.includedRanges)==null?void 0:n.slice())??[],noDataValues:((t=this.noDataValues)==null?void 0:t.slice())??[],noDataInterpretation:this.noDataInterpretation})}};h([f({json:{write:!0}})],Nt.prototype,"includedRanges",void 0),h([f({json:{write:!0}})],Nt.prototype,"noDataValues",void 0),h([f()],Nt.prototype,"normalizedNoDataValues",null),h([f({json:{write:!0}})],Nt.prototype,"noDataInterpretation",void 0),Nt=Ye=h([N("esri.layers.support.rasterFunctions.MaskFunctionArguments")],Nt);const Ci=Nt;let Ft=class extends z{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:s,normalizedNoDataValues:o}=this.functionArguments;if(!(s!=null&&s.length)&&!(o!=null&&o.length))return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let r=[];for(let i=0;i<t.bandCount;i++){const u=En(e,s==null?void 0:s.slice(2*i,2*i+2),o==null?void 0:o[i]);if(u==null){r=null;break}r.push(u)}this.lookups=r;const a=o!=null&&o.every((i=>{var u;return(i==null?void 0:i.length)===((u=o[0])==null?void 0:u.length)}));return{success:!0,supportsGPU:(!s||s.length<=2*Yt)&&(!o||a&&o[0].length<=Yt)}}_processPixels(t){var l;const e=(l=t.pixelBlocks)==null?void 0:l[0];if(e==null)return null;const{outputPixelType:s,lookups:o}=this,{includedRanges:r,noDataInterpretation:a,normalizedNoDataValues:i}=this.functionArguments,u=a===on.matchAll;return On(e,{includedRanges:r,noDataValues:i,outputPixelType:s,matchAll:u,lookups:o})}_getWebGLParameters(){var r;const{includedRanges:t,normalizedNoDataValues:e}=this.functionArguments,s=new Float32Array(Yt);s.fill(pe),(r=e==null?void 0:e[0])!=null&&r.length&&s.set(e[0]);const o=new Float32Array(6);for(let a=0;a<o.length;a+=2)o[a]=(t==null?void 0:t[a])??-pe,o[a+1]=(t==null?void 0:t[a+1])??pe;return t!=null&&t.length&&o.set(t),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:s,includedRanges:o}}};h([f({json:{write:!0,name:"rasterFunction"}})],Ft.prototype,"functionName",void 0),h([f({type:Ci,json:{write:!0,name:"rasterFunctionArguments"}})],Ft.prototype,"functionArguments",void 0),h([f()],Ft.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],Ft.prototype,"lookups",void 0),Ft=h([N("esri.layers.support.rasterFunctions.MaskFunction")],Ft);const Mi=Ft;var Ze;let Ht=Ze=class extends O{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scientificOutput=!1}clone(){const{visibleBandID:n,infraredBandID:t,scientificOutput:e}=this;return new Ze({visibleBandID:n,infraredBandID:t,scientificOutput:e})}};h([f({json:{write:!0}})],Ht.prototype,"visibleBandID",void 0),h([f({json:{write:!0}})],Ht.prototype,"infraredBandID",void 0),h([f({json:{write:!0}})],Ht.prototype,"scientificOutput",void 0),Ht=Ze=h([N("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],Ht);const Bi=Ht;let Jt=class extends z{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scientificOutput:t,visibleBandID:e,infraredBandID:s}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"f32":"u8");const o=this.sourceRasterInfos[0],r=Math.max(e,s);if(o.bandCount<2||r>=o.bandCount)return{success:!1,supportsGPU:!1,error:"ndvi-function: source raster has insufficient amount of raster bands"};if(e<0||s<0)return{success:!1,supportsGPU:!1,error:"ndvi-function: invalid visible or infrared band id"};const a=o.clone();a.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(a),a.bandCount=1,a.keyProperties={...a.keyProperties,BandProperties:void 0};const[i,u,l,c]=t?[-1,1,0,.1]:[0,200,100,10];return a.statistics=[{min:i,max:u,avg:l,stddev:c}],this.rasterInfo=a,{success:!0,supportsGPU:!0}}_processPixels(t){var a;const e=(a=t.pixelBlocks)==null?void 0:a[0];if(e==null)return null;const{visibleBandID:s,infraredBandID:o,scientificOutput:r}=this.functionArguments;return Zr(e,s,o,!r)}_getWebGLParameters(){const{visibleBandID:t,infraredBandID:e,scientificOutput:s}=this.functionArguments,o=this.isInputBandIdsSwizzled?[0,1,2]:[e,t,0];return{bandIndexMat3:U(o),scaled:!s}}_getInputBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments;return[s,e,0].map((o=>t[o]))}_swizzleBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments,o=[e,s].map((r=>t.indexOf(r)));return o[2]=o[1],this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=o,!1}};h([f({json:{write:!0,name:"rasterFunction"}})],Jt.prototype,"functionName",void 0),h([f({type:Bi,json:{write:!0,name:"rasterFunctionArguments"}})],Jt.prototype,"functionArguments",void 0),h([f()],Jt.prototype,"rasterArgumentNames",void 0),Jt=h([N("esri.layers.support.rasterFunctions.NDVIFunction")],Jt);const ji=Jt;var Qe;let at=Qe=class extends O{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1,this.isLastInputRangeInclusive=!1}clone(){return new Qe({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched,isLastInputRangeInclusive:this.isLastInputRangeInclusive})}};h([f({json:{write:!0}})],at.prototype,"inputRanges",void 0),h([f({json:{write:!0}})],at.prototype,"outputValues",void 0),h([f({json:{write:!0}})],at.prototype,"noDataRanges",void 0),h([f({json:{write:!0}})],at.prototype,"allowUnmatched",void 0),h([f({json:{write:!0}})],at.prototype,"replacementValue",void 0),h([f({json:{write:!0}})],at.prototype,"isLastInputRangeInclusive",void 0),at=Qe=h([N("esri.layers.support.rasterFunctions.RemapFunctionArguments")],at);const Gi=at;let kt=class extends z{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const n=this.sourceRasterInfos[0].clone(),{pixelType:t}=n;n.bandCount=1;const{statistics:e}=n;this._removeStatsHistColormapVAT(n);const{allowUnmatched:s,replacementValue:o,outputValues:r,inputRanges:a,noDataRanges:i,isLastInputRangeInclusive:u}=this.functionArguments,l=this.outputPixelType==="unknown"||this.outputPixelType==null;if(this.outputPixelType=this._getOutputPixelType(t),r==null?void 0:r.length){const c=e==null?void 0:e[0];if(s&&o==null){let p=(c==null?void 0:c.min)??r[0],m=(c==null?void 0:c.max)??r[0];p=Math.min.apply(null,[...r,p]),m=Math.max.apply(null,[...r,m]),n.statistics=[{min:p,max:m,avg:(c==null?void 0:c.avg)??0,stddev:(c==null?void 0:c.stddev)??-1}]}else{let p=r[0],m=p;for(let d=0;d<r.length;d++)p=p>r[d]?r[d]:p,m=m>r[d]?m:r[d];s&&o!=null&&(p=Math.min(p,o),m=Math.max(m,o)),n.statistics=[{min:p,max:m,avg:(c==null?void 0:c.avg)??0,stddev:(c==null?void 0:c.stddev)??-1}]}if(l){const{min:p,max:m}=n.statistics[0],d=["u8","s8","u16","s16","u32","s32","f32"],y=d.find((x=>{const[g,A]=ft(x);return p>=g&&m<=A}))??"f64";r.some((x=>Math.floor(x)!==x))?this.outputPixelType=y==="f64"?"f64":"f32":this.outputPixelType=s&&o==null&&d.indexOf(t)>d.indexOf(y)?t:y}}return n.pixelType=this.outputPixelType,this.rasterInfo=n,this.lookup=s?null:Dn({srcPixelType:t,inputRanges:a,outputValues:r,noDataRanges:i,allowUnmatched:s,isLastInputRangeInclusive:u,outputPixelType:this.outputPixelType}),{success:!0,supportsGPU:(!r||r.length<=Yt)&&(!i||i.length<=Yt)}}_processPixels(n){var c;const t=(c=n.pixelBlocks)==null?void 0:c[0];if(t==null)return null;const{lookup:e,outputPixelType:s}=this;if(e){const p=ls(t,{lut:[e.lut],offset:e.offset,outputPixelType:s});return p!=null&&e.mask&&(p.mask=Vn(t.pixels[0],t.mask,e.mask,e.offset,"u8")),p}const{inputRanges:o,outputValues:r,noDataRanges:a,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l}=this.functionArguments;return Un(t,{inputRanges:o,outputValues:r,noDataRanges:a,outputPixelType:s,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l})}_getWebGLParameters(){const{allowUnmatched:n,noDataRanges:t,isLastInputRangeInclusive:e}=this.functionArguments,s=this.functionArguments.inputRanges??[],o=this.functionArguments.outputValues??[],r=Ln(s,o,e),a=new Float32Array(2*Yt);return a.fill(pe),t!=null&&t.length&&a.set(t),{allowUnmatched:n,rangeMaps:r,noDataRanges:a,clampRange:ft(this.outputPixelType),replacementValue:this.functionArguments.replacementValue}}};h([f({json:{write:!0,name:"rasterFunction"}})],kt.prototype,"functionName",void 0),h([f({type:Gi,json:{write:!0,name:"rasterFunctionArguments"}})],kt.prototype,"functionArguments",void 0),h([f()],kt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],kt.prototype,"lookup",void 0),kt=h([N("esri.layers.support.rasterFunctions.RemapFunction")],kt);const zi=kt;var ts;let Kt=ts=class extends gn{readColorRamp(n){if(typeof n=="string"){const t=Mt.jsonValues.find((e=>e.toLowerCase()===n.toLowerCase()));return t?Qs(Mt.fromJSON(t)):null}return"toJSON"in n?n.toJSON():n}clone(){return new ts({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,colorRamp:this.colorRamp,colormap:this.colormap,raster:this.raster})}};h([f({json:{write:!0}})],Kt.prototype,"colorRamp",void 0),h([oe("colorRamp")],Kt.prototype,"readColorRamp",null),h([f({type:[[Number]],json:{write:!0}})],Kt.prototype,"colormap",void 0),Kt=ts=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")],Kt);const Ei=Kt;let ct=class extends z{constructor(){super(...arguments),this.functionName="ShadedRelief",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var i;const n=this.sourceRasterInfos[0];if(n.bandCount>1)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: source data must be single band"};let{colorRamp:t,colormap:e}=this.functionArguments;if(!t&&!(e!=null&&e.length))return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a color ramp argument must be specified"};this.outputPixelType=this._getOutputPixelType("u8");const s=n.clone();this._removeStatsHistColormapVAT(s),s.pixelType=this.outputPixelType,s.bandCount=3,s.statistics=[{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=s,this.isGCS=((i=s.spatialReference)==null?void 0:i.isGeographic)??!1,e!=null&&e.length||(e=Se(t,{interpolateAlpha:!0}));const{indexedColormap:o,offset:r}=tn({colormap:e});if(!(o!=null&&o.length))return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a valid colorramp is required"};const a=Wn(o);return this.lookup={indexedColormap:o,offset:r,hsvMap:a},{success:!0,supportsGPU:en(o)}}_processPixels(n){var a,i,u;const t=(a=n.pixelBlocks)==null?void 0:a[0];if(!t||!this.lookup)return null;let e=(i=n.primaryPixelSizes)==null?void 0:i[0];if(e==null){const{extent:l}=n;e=l?{x:l.width/t.width,y:l.height/t.height}:{x:1,y:1}}const s=ge(this.functionArguments,e,this.isGCS),o=nn(t,s),r=((u=this.sourceRasterInfos[0].statistics)==null?void 0:u[0])??{min:0,max:8e3};return qn(o,t,this.lookup.hsvMap,r),o.pixelType=this.outputPixelType,o}_getWebGLParameters(){var p;const n=ge(this.functionArguments,{x:1,y:1},this.isGCS),t=rn(n),{slopeType:e,zFactor:s,pixelSizeFactor:o,pixelSizePower:r}=this.functionArguments,a=e==="scaled",{indexedColormap:i,offset:u}=this.lookup,l=(p=this.sourceRasterInfos[0].statistics)==null?void 0:p[0],c=W(this.outputPixelType);return{...t,indexedColormap:i,offset:u,zFactor:s,gcsFactor:this.isGCS?ie:1,pixelSizeFactor:a?o:0,pixelSizePower:a?r:0,minValue:(l==null?void 0:l.min)??0,maxValue:(l==null?void 0:l.max)??8e3,isOutputRounded:c}}};h([f({json:{write:!0,name:"rasterFunction"}})],ct.prototype,"functionName",void 0),h([f({type:Ei,json:{write:!0,name:"rasterFunctionArguments"}})],ct.prototype,"functionArguments",void 0),h([f()],ct.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],ct.prototype,"isGCS",void 0),h([f({json:{write:!0}})],ct.prototype,"lookup",void 0),ct=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunction")],ct);const Oi=ct;var es;const Di=new rt({1:"degree",2:"percent-rise",3:"adjusted"},{useNumericKeys:!0});let pt=es=class extends O{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.removeEdgeEffect=!1}clone(){return new es({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([nt(Di)],pt.prototype,"slopeType",void 0),h([f({type:Number,json:{write:!0}})],pt.prototype,"zFactor",void 0),h([f({type:Number,json:{name:"psPower",write:!0}})],pt.prototype,"pixelSizePower",void 0),h([f({type:Number,json:{name:"psZFactor",write:!0}})],pt.prototype,"pixelSizeFactor",void 0),h([f({type:Boolean,json:{write:!0}})],pt.prototype,"removeEdgeEffect",void 0),pt=es=h([N("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],pt);const Vi=pt;let _t=class extends z{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var e;this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),t.statistics=this.functionArguments.slopeType!=="percent-rise"?[{min:0,max:90,avg:1,stddev:1}]:null,t.bandCount=1,this.rasterInfo=t,this.isGCS=((e=t.spatialReference)==null?void 0:e.isGeographic)??!1,{success:!0,supportsGPU:!0}}_processPixels(t){var m;const e=(m=t.pixelBlocks)==null?void 0:m[0];if(e==null)return null;const{zFactor:s,slopeType:o,pixelSizePower:r,pixelSizeFactor:a}=this.functionArguments,{isGCS:i}=this,{extent:u,primaryPixelSizes:l}=t,c=l==null?void 0:l[0],p=c??(u?{x:u.width/e.width,y:u.height/e.height}:{x:1,y:1});return Hn(e,{zFactor:s,slopeType:o,pixelSizePower:r,pixelSizeFactor:a,isGCS:i,resolution:p})}_getWebGLParameters(){const{zFactor:t,slopeType:e,pixelSizeFactor:s,pixelSizePower:o}=this.functionArguments;return{zFactor:this.isGCS&&t>=1?t*ie:t,slopeType:e,pixelSizeFactor:s??0,pixelSizePower:o??0,isOutputRounded:W(this.outputPixelType)}}};h([f({json:{write:!0,name:"rasterFunction"}})],_t.prototype,"functionName",void 0),h([f({type:Vi,json:{write:!0,name:"rasterFunctionArguments"}})],_t.prototype,"functionArguments",void 0),h([f()],_t.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],_t.prototype,"isGCS",void 0),_t=h([N("esri.layers.support.rasterFunctions.SlopeFunction")],_t);const Ui=_t,Ls=new rt({1:"min",2:"max",3:"mean",4:"stddev",5:"median",6:"majority",7:"minority"},{useNumericKeys:!0});function Li(n,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:r,mask:a,outBand:i}=n;if(e&&!a)return void i.set(s);const{statisticsType:u,kernelRows:l,kernelCols:c}=t,p=u==="stddev",m=o*r,d=new Float64Array(m),y=new Float64Array(m),x=new Uint32Array(m);for(let P=0;P<r;P++){const $=P*o;let F=0,k=0,_=0;for(let S=0;S<c;S++)a&&!a[$+S]||(F+=s[$+S],p&&(k+=s[$+S]**2),_++);d[$]=F,y[$]=k,x[$]=_;for(let S=1;S<=o-c;S++){const B=$+S-1,X=B+c;a?(a[B]&&(_--,F-=s[B],p&&(k-=s[B]**2)),a[X]&&(_++,F+=s[X],p&&(k+=s[X]**2))):(F-=s[B],F+=s[X],p&&(k-=s[B]**2,k+=s[X]**2)),d[$+S]=F,x[$+S]=_,p&&(y[$+S]=k)}}const g=new Float64Array(m),A=new Float64Array(m),w=new Uint32Array(m),v=l*o;for(let P=0;P<=o-c;P++){let $=0,F=0,k=0;for(let _=0;_<l;_++){const S=_*o+P;$+=d[S],k+=x[S],p&&(F+=y[S])}g[P]=$,A[P]=F,w[P]=k;for(let _=1;_<=r-l;_++){const S=(_-1)*o+P,B=S+v;$-=d[S],$+=d[B],k-=x[S],k+=x[B],p&&(F-=y[S],F+=y[B]),g[_*o+P]=$,A[_*o+P]=F,w[_*o+P]=k}}const b=Math.floor(l/2),T=Math.floor(c/2);for(let P=b;P<r-b;P++){const $=P*o;for(let F=T;F<o-T;F++){const k=(P-b)*o+F-T,_=w[k];if(_===0||e&&(!a||a[$+F]))continue;const S=g[k]/_,B=p?Math.sqrt((A[k]-g[k]*S)/_):S;i[$+F]=B,a&&(a[$+F]=255)}}}function Wi(n,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:r,mask:a,outBand:i}=n;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l,statisticsType:c}=t,p=Math.floor(u/2),m=Math.floor(l/2),d=c==="min",y=i.slice(),x=new Uint32Array(o*r);for(let g=p;g<r-p;g++){const A=g*o;for(let w=m;w<o-m;w++){let v=d?Number.MAX_VALUE:-Number.MAX_VALUE,b=0;for(let T=0;T<u;T++)for(let P=0;P<l;P++){const $=A+w+(T-p)*o+P-m;a&&!a[$]||(v=d?Math.min(v,s[$]):Math.max(v,s[$]),b++)}a?(y[A+w]=b===0?0:v,x[A+w]=b):i[A+w]=b===0?0:v}}if(a)for(let g=p;g<r-p;g++){const A=g*o;for(let w=m;w<o-m;w++)if(x[A+w]){if(e&&a[A+w])continue;i[A+w]=y[A+w],a[A+w]=255}}}function qi(n,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:r,mask:a,outBand:i}=n;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=i.slice(),d=new Uint32Array(o*r);for(let y=c;y<r-c;y++){const x=y*o;for(let g=p;g<o-p;g++){if(e&&(a!=null&&a[x+g]))continue;const A=[];for(let w=0;w<u;w++)for(let v=0;v<l;v++){const b=x+g+(w-c)*o+v-p;a&&!a[b]||A.push(s[b])}A.length&&(A.sort(((w,v)=>w-v)),a?(m[x+g]=A[Math.floor((A.length-1)/2)],d[x+g]=A.length):i[x+g]=A[Math.floor((A.length-1)/2)])}}if(a)for(let y=c;y<r-c;y++){const x=y*o;for(let g=p;g<o-p;g++)if(d[x+g]){if(e&&a[x+g])continue;i[x+g]=m[x+g],a[x+g]=255}}}function Hi(n,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:r,mask:a,outBand:i}=n;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=t.statisticsType==="majority",d=u*l,y=i.slice(),x=new Uint32Array(o*r);for(let g=c;g<r-c;g++){const A=g*o;for(let w=p;w<o-p;w++){if(e&&(a!=null&&a[A+w]))continue;const v=new Map;for(let $=0;$<u;$++)for(let F=0;F<l;F++){const k=A+w+($-c)*o+F-p;if(a&&!a[k])continue;const _=s[k];v.set(_,v.has(_)?v.get(_)+1:1)}if(v.size===0)continue;let b=0,T=0,P=m?0:d+1;for(const $ of v.keys())T=v.get($),m===T>P&&(P=T,b=$);a?(y[A+w]=b,x[A+w]=v.size):i[A+w]=b}}if(a)for(let g=c;g<r-c;g++){const A=g*o;for(let w=p;w<o-p;w++)if(x[A+w]){if(e&&a[A+w])continue;i[A+w]=y[A+w],a[A+w]=255}}}function Ji(n,t){const{mask:e}=n,{fillNoDataOnly:s}=t;if(s&&!e)return n;const{pixels:o,width:r,height:a,bandMasks:i,pixelType:u}=n,l=o.length,c=r*a,p=[],{kernelRows:m,kernelCols:d,statisticsType:y,mirrorEdges:x}=t;if(s&&!e)return n;const g=t.outputPixelType??u,A=[];for(let b=0;b<l;b++){const T=o[b],P=R.createEmptyBand(g,c);s&&P.set(T);const $=(i==null?void 0:i[b])??e,F=($==null?void 0:$.slice())??null,k={band:T,width:r,height:a,mask:F,outBand:P};switch(y){case"min":case"max":Wi(k,t);break;case"mean":case"stddev":Li(k,t);break;case"median":qi(k,t);break;case"majority":case"minority":Hi(k,t)}x&&!s&&fs(P,r,a,m,d),p.push(P),F&&A.push(F)}let w=A[0]??e;A.length!==l&&(A.length=0),l>1&&(i!=null&&i.length)&&(w=R.combineBandMasks(i));const v=new R({pixelType:g,width:r,height:a,pixels:p,bandMasks:i&&A.length?A:null,mask:w});return v.updateStatistics(),v}var ss;let It=ss=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.fillNoDataOnly=!1,this.statisticsType="min"}clone(){return new ss({rows:this.rows,cols:this.cols,fillNoDataOnly:this.fillNoDataOnly,statisticsType:this.statisticsType,raster:J(this.raster)})}};h([f({json:{write:!0,read:{source:["kernelRows","rows"],reader:(n,t)=>Number(n??(t==null?void 0:t.kernelRows)??3)}}})],It.prototype,"rows",void 0),h([f({json:{write:!0,read:{source:["kernelCols","cols"],reader:(n,t)=>Number(n??(t==null?void 0:t.kernelCols)??3)}}})],It.prototype,"cols",void 0),h([f({json:{write:!0}})],It.prototype,"fillNoDataOnly",void 0),h([f({json:{read:{source:["statisticsType","type"],reader:(n,t)=>Ls.fromJSON((t==null?void 0:t.statisticsType)??(t==null?void 0:t.type))??"min"},write:{target:"type"}}}),nt(Ls)],It.prototype,"statisticsType",void 0),It=ss=h([N("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")],It);const Ki=It;let Xt=class extends z{constructor(){super(...arguments),this.functionName="Statistics",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{type:t}=this.functionArguments.toJSON();if(t<1||t>7)return{success:!1,supportsGPU:!1,error:`statistics-function: the given statistics type is not supported ${t}`};const e=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();s.pixelType=this.outputPixelType;const{statisticsType:o}=this.functionArguments;return o==="stddev"&&this._removeStatsHistColormapVAT(s),this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3&&t<5}}_processPixels(t){var i;const e=(i=t.pixelBlocks)==null?void 0:i[0];if(e==null)return e;const{statisticsType:s,rows:o,cols:r,fillNoDataOnly:a}=this.functionArguments;return Ji(e,{kernelRows:o,kernelCols:r,fillNoDataOnly:a,outputPixelType:this.outputPixelType,statisticsType:s,mirrorEdges:!0})}_getWebGLParameters(){const{rows:t,cols:e,statisticsType:s,fillNoDataOnly:o}=this.functionArguments;return{fillNoDataOnly:o,kernelRows:t,kernelCols:e,statisticsType:s,clampRange:ft(this.outputPixelType)}}};h([f({json:{write:!0,name:"rasterFunction"}})],Xt.prototype,"functionName",void 0),h([f({type:Ki,json:{write:!0,name:"rasterFunctionArguments"}})],Xt.prototype,"functionArguments",void 0),h([f()],Xt.prototype,"rasterArgumentNames",void 0),Xt=h([N("esri.layers.support.rasterFunctions.StatisticsFunction")],Xt);const Xi=Xt;var ns;let St=ns=class extends O{constructor(){super(...arguments),this.statistics=null,this.histograms=null}readStatistics(n,t){if(!(n!=null&&n.length))return null;const e=[];return n.forEach((s=>{const o={min:s.min,max:s.max,avg:s.avg??s.mean,stddev:s.stddev??s.standardDeviation};e.push(o)})),e}writeStatistics(n,t,e){if(!(n!=null&&n.length))return;const s=[];n.forEach((o=>{const r={...o,mean:o.avg,standardDeviation:o.stddev};delete r.avg,delete r.stddev,s.push(r)})),t[e]=s}clone(){return new ns({statistics:J(this.statistics),histograms:J(this.histograms)})}};h([f({json:{write:!0}})],St.prototype,"statistics",void 0),h([oe("statistics")],St.prototype,"readStatistics",null),h([Ae("statistics")],St.prototype,"writeStatistics",null),h([f({json:{write:!0}})],St.prototype,"histograms",void 0),St=ns=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")],St);const Yi=St;let ht=class extends z{constructor(){super(...arguments),this.functionName="StatisticsHistogram",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone(),{statistics:s,histograms:o}=this.functionArguments;return o&&(e.histograms=o),s&&(e.statistics=s),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){var e;return(e=t.pixelBlocks)==null?void 0:e[0]}};h([f({json:{write:!0,name:"rasterFunction"}})],ht.prototype,"functionName",void 0),h([f({type:Yi,json:{write:!0,name:"rasterFunctionArguments"}})],ht.prototype,"functionArguments",void 0),h([f()],ht.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],ht.prototype,"indexedColormap",void 0),h([f()],ht.prototype,"isNoopProcess",void 0),ht=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")],ht);const Zi=ht;var rs;const Qi=new rt({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",9:"sigmoid"},{useNumericKeys:!0});let L=rs=class extends O{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(n,t,e){n!=null&&n.length&&(Array.isArray(n[0])||(n=n.map((s=>[s.min,s.max,s.avg,s.stddev]))),t[e]=n)}clone(){return new rs({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:J(this.statistics),gamma:J(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:J(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};h([f({type:Boolean,json:{write:!0}})],L.prototype,"computeGamma",void 0),h([f({type:Boolean,json:{name:"dra",write:!0}})],L.prototype,"dynamicRangeAdjustment",void 0),h([f({type:[Number],json:{write:!0}})],L.prototype,"gamma",void 0),h([f()],L.prototype,"histograms",void 0),h([f({type:Number,json:{write:!0}})],L.prototype,"maxPercent",void 0),h([f({type:Number,json:{write:!0}})],L.prototype,"minPercent",void 0),h([f({type:Number,json:{write:!0}})],L.prototype,"numberOfStandardDeviations",void 0),h([f({type:Number,json:{name:"max",write:!0}})],L.prototype,"outputMax",void 0),h([f({type:Number,json:{name:"min",write:!0}})],L.prototype,"outputMin",void 0),h([f({type:Number,json:{write:!0}})],L.prototype,"sigmoidStrengthLevel",void 0),h([f({json:{type:[[Number]],write:!0}})],L.prototype,"statistics",void 0),h([Ae("statistics")],L.prototype,"writeStatistics",null),h([nt(Qi)],L.prototype,"stretchType",void 0),h([f({type:Boolean,json:{write:!0}})],L.prototype,"useGamma",void 0),L=rs=h([N("esri.layers.support.rasterFunctions.StretchFunctionArguments")],L);const ta=L;let mt=class extends z{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:e}=t,{functionArguments:s}=this,{dynamicRangeAdjustment:o,gamma:r,useGamma:a}=s;if(!o&&["u8","u16","s8","s16"].includes(e)){const c=$e(s.toJSON(),{rasterInfo:t}),p=W(this.outputPixelType)?"round":"float";this.lookup=Jn({pixelType:e,...c,gamma:a?r:null,rounding:p}),this.cutOffs=c}else o||(this.cutOffs=$e(s.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(e);const i=t.clone();i.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(i),this.outputPixelType==="u8"&&(i.keyProperties.DataType="processed");const{outputMin:u=0,outputMax:l=255}=this.functionArguments;i.statistics=[];for(let c=0;c<i.bandCount;c++)i.statistics[c]={min:u,max:l};return this.rasterInfo=i,{success:!0,supportsGPU:!o}}_processPixels(t){var i;const e=(i=t.pixelBlocks)==null?void 0:i[0];if(e==null)return e;const{lookup:s}=this;if(s)return ls(e,{...s,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:o}=this,r=this.cutOffs||$e(o.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:e}),a=o.useGamma?o.gamma:null;return Kn(e,{...r,gamma:a,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const{outputMin:t=0,outputMax:e=255,gamma:s,useGamma:o}=this.functionArguments,r=this.rasterInfo.bandCount>=2?3:1,a=o&&(s!=null&&s.length)?Xn(r,s):[1,1,1],{minCutOff:i,maxCutOff:u}=this.cutOffs??{minCutOff:[0,0,0],maxCutOff:[255,255,255]};i.length===1&&(i[1]=i[2]=i[0],u[1]=u[2]=u[0]);const l=u.map(((d,y)=>(e-t)/(u[y]-i[y]))),c=W(this.outputPixelType),p=o&&s?[s[0],s[1]??s[0],s[2]??s[0]]:[1,1,1],m=o?[a[0],a[1]??a[0],a[2]??a[0]]:[1,1,1];return{bandCount:r,minOutput:t,maxOutput:e,minCutOff:i,maxCutOff:u,factor:l,useGamma:o,gamma:p,gammaCorrection:m,stretchType:this.functionArguments.stretchType,isOutputRounded:c,type:"stretch"}}};h([f({json:{write:!0,name:"rasterFunction"}})],mt.prototype,"functionName",void 0),h([f({type:ta,json:{write:!0,name:"rasterFunctionArguments"}})],mt.prototype,"functionArguments",void 0),h([f()],mt.prototype,"rasterArgumentNames",void 0),h([f({json:{write:!0}})],mt.prototype,"lookup",void 0),h([f({json:{write:!0}})],mt.prototype,"cutOffs",void 0),mt=h([N("esri.layers.support.rasterFunctions.StretchFunction")],mt);const ea=mt;var os;let fe=os=class extends O{constructor(){super(...arguments),this.attributeTableAsRecordSet=null}clone(){return new os({attributeTableAsRecordSet:J(this.attributeTableAsRecordSet)})}};h([f({json:{write:!0}})],fe.prototype,"attributeTableAsRecordSet",void 0),fe=os=h([N("esri.layers.support.rasterFunctions.TableFunctionArguments")],fe);const sa=fe;let Ct=class extends z{constructor(){super(...arguments),this.functionName="Table",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const n=this.sourceRasterInfos[0];if(n.bandCount>1||n.pixelType.startsWith("f"))return{success:!1,supportsGPU:!1,error:"table-function: Source data must be single band and integer pixel type."};const{attributeTableAsRecordSet:t}=this.functionArguments;if(!t)return{success:!1,supportsGPU:!1,error:"table-function: Missing attributeTableAsRecordSet argument."};this.outputPixelType=this._getOutputPixelType(n.pixelType);const e=n.clone();return e.pixelType=this.outputPixelType,e.bandCount=1,e.dataType!=="thematic"&&(e.keyProperties=e.keyProperties?{...e.keyProperties,DataType:"thematic"}:{DataType:"thematic"}),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(n){var t;return(t=n.pixelBlocks)==null?void 0:t[0]}};h([f({json:{write:!0,name:"rasterFunction"}})],Ct.prototype,"functionName",void 0),h([f({type:sa,json:{write:!0,name:"rasterFunctionArguments"}})],Ct.prototype,"functionArguments",void 0),h([f()],Ct.prototype,"rasterArgumentNames",void 0),h([f()],Ct.prototype,"isNoopProcess",void 0),Ct=h([N("esri.layers.support.rasterFunctions.TableFunction")],Ct);const na=Ct,M=new Map;function ra(n,t){const{rasterFunctionArguments:e}=n;e&&(e.rasters||[e.raster,e.raster2]).forEach((s=>{s&&typeof s!="number"&&(typeof s=="string"?s.startsWith("http")&&(t.includes(s)||t.push(s)):"rasterFunctionArguments"in s&&ra(s,t))}))}function Ua(n,t){t=t??{};try{if("function"in(n=J(n))&&"arguments"in n&&n.arguments){const e=wn(n,new Map,t);if(us(e),!e.renderingRule)throw new Gt("raster-function-helper","Unsupported raster function json.");n=e.renderingRule}if("rasterFunction"in n){const e=yn(n=is(n),t);return e.isRoot=!0,e}}catch{}throw new Gt("raster-function-helper","unsupported raster function json.")}function oa(n,t){return t[0]==="rasters"&&Array.isArray(n.rasters)?n.rasters:t.map((e=>n[e]))}function Ws(n){return!!(n&&typeof n=="object"&&n.rasterFunction&&n.rasterFunctionArguments)}function is(n){var o;const{rasterFunction:t,rasterFunctionArguments:e}=n,s={};for(const r in e){let a=e[r];const i=r.toLowerCase();if(i==="rasters"&&Array.isArray(a))s.rasters=a.map((u=>Ws(u)?is(u):u));else switch(Ws(a)&&(a=is(a)),i){case"dra":s.dra=a;break;case"pspower":s.psPower=a;break;case"pszfactor":s.psZFactor=a;break;case"bandids":s.bandIds=a;break;default:s[r[0].toLowerCase()+r.slice(1)]=a}}return t!=="Local"||(o=s.rasters)!=null&&o.length||(s.rasters=["$$"]),{...n,rasterFunctionArguments:s}}function yn(n,t){var m,d;const{rasterFunction:e,rasterFunctionArguments:s}=n,o=(m=n.outputPixelType)==null?void 0:m.toLowerCase();if(e==null||!M.has(e))throw new Gt("raster-function-helper",`unsupported raster function: ${e}`);const r=M.get(e),a=(typeof r.ctor=="function"?r.ctor:r.ctor.default).fromJSON({...n,outputPixelType:o}),{rasterArgumentNames:i}=a,u=[],l=oa(s,i),c=i[0]==="rasters"||i.length>1,p=[];for(let y=0;y<l.length;y++){const x=l[y];let g;x==null||typeof x=="string"&&x.startsWith("$")?u.push(t==null?void 0:t.raster):typeof x=="string"?t[x]&&u.push(t[x]):typeof x!="number"&&"rasterFunction"in x&&(g=yn(x,t),c||(a.functionArguments[i[y]]=g),u.push(g)),c&&p.push(g??x)}if(c&&(i[0]==="rasters"?a.functionArguments.rasters=p:i.forEach(((y,x)=>{a.functionArguments[y]=p[x]}))),t){a.sourceRasters=u;const y=(d=t.raster)==null?void 0:d.url;y&&(a.mainPrimaryRasterId=y)}return a}function xn(n,t){if(n&&t)for(const e in n){const s=n[e];s&&typeof s=="object"&&"type"in s&&(s.type==="RasterFunctionTemplate"?xn(s.arguments,t):s.type==="RasterFunctionVariable"&&t[s.name]!=null&&(s.value=t[s.name]))}}function as(n,t){var o;if(!n||typeof n!="object")return n;const{value:e}=n;if(!e||typeof e!="object")return n.isDataset?"$$":e;if(Array.isArray(e))return e.length===0?[]:e.map((r=>r&&typeof r=="object"&&r.type==="RasterFunctionVariable"?as(r,t):r));if("value"in e&&["number","string","boolean"].includes(typeof e.value))return e.value;if(n.isDataset&&e.type!=="Scalar")return"$$";if(!("type"in e))return e;let s=e;switch(e.type){case"Scalar":s=e.value;break;case"AlgorithmicColorRamp":s=qs(e);break;case"MultiPartColorRamp":s={type:"multipart",colorRamps:e.ArrayOfColorRamp.map(qs)};break;case"ArgumentArray":if((o=e.elements)!=null&&o.length&&e.elements[0].type!=="RasterStatistics"){const r=[];for(let a=0;a<e.elements.length;a++){const i=e.elements[a],{type:u}=i;if(u)if(u==="RasterFunctionTemplate"){const{renderingRule:l}=wn(i,t);r.push(l),i._object_id!=null&&t.set(i._object_id,l)}else{if(u!=="RasterFunctionVariable")throw new Gt("raster-function-helper","unsupported raster function json.");{const l=as(i,t);r.push(l),i._object_id!=null&&t.set(i._object_id,l)}}else r.push(i)}s=r}else s=e.elements}return e._object_id!=null&&t.set(e._object_id,s),s}function qs(n){const t=n.algorithm??"esriHSVAlgorithm";let{FromColor:e,ToColor:s}=n;if(!Array.isArray(e)){const{r:o,g:r,b:a}=gs({h:e.Hue,s:e.Saturation,v:e.Value});e=[o,r,a,e.AlphaValue]}if(!Array.isArray(s)){const{r:o,g:r,b:a}=gs({h:s.Hue,s:s.Saturation,v:s.Value});s=[o,r,a,s.AlphaValue]}return{type:"algorithmic",algorithm:t,fromColor:e,toColor:s}}function wn(n,t,e){e&&xn(n,e);const s={renderingRule:{},templates:t};return bn(n,s),s}function bn(n,t){if(!n||!t.renderingRule)return;const{renderingRule:e,templates:s}=t,{function:o,arguments:r,_object_id:a}=n;if(!o||!r)return;a!=null&&s.set(a,e),e.rasterFunction=o.type.replace("Function",""),e.outputPixelType=o.pixelType;const i={};e.rasterFunctionArguments=i;for(const u in r){if(u==="type"||u==="object_id"||u==="_object_ref_id")continue;const l=r[u];l&&typeof l=="object"&&"type"in l&&(l.type==="RasterFunctionTemplate"||l.type==="RasterFunctionVariable")?(l.type==="RasterFunctionVariable"?i[u]=as(l,s):(e.rasterFunctionArguments[u]={},bn(l,{renderingRule:e.rasterFunctionArguments[u],templates:s})),l._object_id!=null&&s.set(l._object_id,i[u])):i[u]=l}switch(i.DEM&&!i.Raster&&(i.Raster=i.DEM,delete i.DEM),e.rasterFunction){case"Stretch":ia(i);break;case"Colormap":aa(i);break;case"Convolution":ua(i);break;case"Mask":la(i)}}function us(n){const{renderingRule:t,templates:e}=n;if(typeof t!="object"||!(t!=null&&t.rasterFunctionArguments)||!e.size)return;const{rasterFunctionArguments:s}=t;for(const o in s){const r=s[o],a=o==="_object_ref_id"?r:r&&typeof r=="object"&&"_object_ref_id"in r?r._object_ref_id:null;if(a==null)r&&typeof r=="object"&&(r.rasterFunctionArguments&&us({renderingRule:r,templates:e}),Array.isArray(r)&&r.forEach(((i,u)=>{if(i&&typeof i=="object")if(i._object_ref_id!=null){if(!e.has(i._object_ref_id))throw new Gt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${r} does not exist`);const l=e.get(a);l&&typeof l=="object"?Object.assign(i,l):r[u]=l}else us({renderingRule:i,templates:e})})));else{if(!e.has(a))throw new Gt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${a} does not exist`);const i=e.get(a);o!=="_object_ref_id"?s[o]=i:i&&typeof i=="object"&&Object.assign(s,i)}}}function ia(n){var t;(t=n.Statistics)!=null&&t.length&&typeof n.Statistics=="object"&&(n.Statistics=n.Statistics.map((e=>[e.min,e.max,e.mean,e.standardDeviation]))),n.NumberOfStandardDeviation!=null&&(n.NumberOfStandardDeviations=n.NumberOfStandardDeviation,delete n.NumberOfStandardDeviation)}function aa(n){var t,e;((e=(t=n.ColorRamp)==null?void 0:t.type)==null?void 0:e.toLowerCase())==="randomcolorramp"&&(delete n.ColorRamp,n.ColormapName="Random"),n.ColorSchemeType===0&&delete n.ColorRamp}function ua(n){n.ConvolutionType!=null&&(n.Type=n.ConvolutionType,delete n.ConvolutionType)}function la(n){var t;(t=n.NoDataValues)!=null&&t.length&&typeof n.NoDataValues[0]=="string"&&(n.NoDataValues=n.NoDataValues.filter((e=>e!=="")).map((e=>Number(e))))}M.set("Arithmetic",{desc:"Arithmetic Function",ctor:Dr,rasterArgumentNames:["rasters"]}),M.set("Aspect",{desc:"Aspect Function",ctor:Ur,rasterArgumentNames:["raster"]}),M.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:yo,rasterArgumentNames:["raster"]}),M.set("Colormap",{desc:"Colormap Function",ctor:Jo,rasterArgumentNames:["raster"]}),M.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:Xo,rasterArgumentNames:["raster"]}),M.set("CompositeBand",{desc:"CompositeBand Function",ctor:Zo,rasterArgumentNames:["rasters"]}),M.set("ComputeChange",{desc:"ComputeChange Function",ctor:ui,rasterArgumentNames:["rasters"]}),M.set("Convolution",{desc:"Convolution Function",ctor:yi,rasterArgumentNames:["raster"]}),M.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:ci,rasterArgumentNames:["raster"]}),M.set("ExtractBand",{desc:"ExtractBand Function",ctor:vi,rasterArgumentNames:["raster"]}),M.set("Curvature",{desc:"Curvature Function",ctor:wi,rasterArgumentNames:["raster"]}),M.set("Hillshade",{desc:"Hillshade Function",ctor:_i,rasterArgumentNames:["raster"]}),M.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:Oi,rasterArgumentNames:["raster"]}),M.set("Grayscale",{desc:"Grayscale Function",ctor:Ni,rasterArgumentNames:["raster"]}),M.set("Clip",{desc:"Clip Function",ctor:zo,rasterArgumentNames:["raster"]}),M.set("Local",{desc:"Local Function",ctor:Si,rasterArgumentNames:["rasters"]}),M.set("Mask",{desc:"Mask Function",ctor:Mi,rasterArgumentNames:["raster"]}),M.set("NDVI",{desc:"NDVI Function",ctor:ji,rasterArgumentNames:["raster"]}),M.set("Remap",{desc:"Remap Function",ctor:zi,rasterArgumentNames:["raster"]}),M.set("Slope",{desc:"Slope Function",ctor:Ui,rasterArgumentNames:["raster"]}),M.set("Statistics",{desc:"Focal Statistics Function",ctor:Xi,rasterArgumentNames:["raster"]}),M.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:Zi,rasterArgumentNames:["raster"]}),M.set("Stretch",{desc:"Stretch Function",ctor:ea,rasterArgumentNames:["raster"]}),M.set("Table",{desc:"Attribute Table Function",ctor:na,rasterArgumentNames:["raster"]});export{js as A,fn as Q,Ua as T,Mo as V,ba as _,ut as e,Ta as f,va as i,jo as o,$o as p,xa as r,Aa as s,Pa as u,wa as v,ra as w};
