const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./libtess-asm-CfQP31-y.js","./index-BAMY2Nnw.js","./_commonjsHelpers-BcY2WciP.js","./index-BbP3371Q.js","./libtess-Bioqp9UR.js"])))=>i.map(i=>d[i]);
import{g1 as I,g2 as D,n as bt,_ as vt,fK as pt}from"./index-DzoQLc5A.js";import{R as Mt}from"./GeometryUtils-DF5xixq3.js";class At{constructor(e=0,r=0,_=0,m=0){this.x=e,this.y=r,this.width=_,this.height=m}get isEmpty(){return this.width<=0||this.height<=0}union(e){this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.width=Math.max(this.width,e.width),this.height=Math.max(this.height,e.height)}}function mt(s,e){return s.x===e.x&&s.y===e.y}function Rt(s){if(!s)return;const e=s.length;if(e<=1)return;let r=0;for(let _=1;_<e;_++)mt(s[_],s[r])||++r===_||(s[r]=s[_]);s.length=r+1}function k(s,e){return s.x=e.y,s.y=-e.x,s}function p(s,e){return s.x=-e.y,s.y=e.x,s}function Tt(s,e){return s.x=e.x,s.y=e.y,s}function dt(s,e){return s.x=-e.x,s.y=-e.y,s}function ft(s){return Math.sqrt(s.x*s.x+s.y*s.y)}function Ut(s,e){return s.x*e.y-s.y*e.x}function gt(s,e){return s.x*e.x+s.y*e.y}function it(s,e,r,_){return s.x=e.x*r+e.y*_,s.y=e.x*_-e.y*r,s}class Ot{constructor(e,r,_){this._writeVertex=e,this._writeTriangle=r,this._canUseThinTessellation=_,this._prevNormal={x:void 0,y:void 0},this._nextNormal={x:void 0,y:void 0},this._textureNormalLeft={x:0,y:1},this._textureNormalRight={x:0,y:-1},this._textureNormal={x:void 0,y:void 0},this._joinNormal={x:void 0,y:void 0},this._inner={x:void 0,y:void 0},this._outer={x:void 0,y:void 0},this._roundStart={x:void 0,y:void 0},this._roundEnd={x:void 0,y:void 0},this._startBreak={x:void 0,y:void 0},this._endBreak={x:void 0,y:void 0},this._innerPrev={x:void 0,y:void 0},this._innerNext={x:void 0,y:void 0},this._bevelStart={x:void 0,y:void 0},this._bevelEnd={x:void 0,y:void 0},this._bevelMiddle={x:void 0,y:void 0}}tessellate(e,r,_=this._canUseThinTessellation){Rt(e),_&&r.halfWidth<Mt&&!r.offset?this._tessellateThin(e,r):this._tessellate(e,r)}_tessellateThin(e,r){if(e.length<2)return;const _=r.wrapDistance||65535;let m=r.initialDistance||0,$=!1,C=e[0].x,F=e[0].y;const B=e.length;for(let j=1;j<B;++j){$&&($=!1,m=0);let W=e[j].x,X=e[j].y,b=W-C,w=X-F,T=Math.sqrt(b*b+w*w);if(b/=T,w/=T,m+T>_){$=!0;const t=(_-m)/T;T=_-m,W=(1-t)*C+t*W,X=(1-t)*F+t*X,--j}const h=this._writeVertex(C,F,0,0,b,w,w,-b,0,-1,m),y=this._writeVertex(C,F,0,0,b,w,-w,b,0,1,m);m+=T;const K=this._writeVertex(W,X,0,0,b,w,w,-b,0,-1,m),i=this._writeVertex(W,X,0,0,b,w,-w,b,0,1,m);this._writeTriangle(h,y,K),this._writeTriangle(y,K,i),C=W,F=X}}_tessellate(e,r){const _=e[0],m=e[e.length-1],$=mt(_,m),C=$?3:2;if(e.length<C)return;const F=r.pixelCoordRatio,B=r.capType!=null?r.capType:I.BUTT,j=r.joinType!=null?r.joinType:D.MITER,W=r.miterLimit!=null?Math.min(r.miterLimit,4):2,X=r.roundLimit!=null?Math.min(r.roundLimit,1.05):1.05,b=r.halfWidth!=null?r.halfWidth:2,w=!!r.textured;let T,h,y,K=null;const i=this._prevNormal,t=this._nextNormal;let J=-1,Q=-1;const n=this._joinNormal;let c,u;const rt=this._textureNormalLeft,xt=this._textureNormalRight,v=this._textureNormal;let d=-1,o=-1;const _t=r.wrapDistance||65535;let l=r.initialDistance||0;const Et=this._writeVertex,Nt=this._writeTriangle,f=(M,nt,G,V,L,A)=>{const O=Et(h,y,c,u,G,V,M,nt,L,A,l);return d>=0&&o>=0&&O>=0&&Nt(d,o,O),d=o,o=O,O};$&&(T=e[e.length-2],t.x=m.x-T.x,t.y=m.y-T.y,Q=ft(t),t.x/=Q,t.y/=Q);let Y=!1;for(let M=0;M<e.length;++M){if(Y&&(Y=!1,l=0),T&&(i.x=-t.x,i.y=-t.y,J=Q,l+J>_t&&(Y=!0)),Y){const x=(_t-l)/J;J=_t-l,T={x:(1-x)*T.x+x*e[M].x,y:(1-x)*T.y+x*e[M].y},--M}else T=e[M];h=T.x,y=T.y;const nt=M<=0&&!Y,G=M===e.length-1;if(nt||(l+=J),K=G?$?e[1]:null:e[M+1],K?(t.x=K.x-h,t.y=K.y-y,Q=ft(t),t.x/=Q,t.y/=Q):(t.x=void 0,t.y=void 0),!$){if(nt){p(n,t),c=n.x,u=n.y,B===I.SQUARE&&(f(-t.y-t.x,t.x-t.y,t.x,t.y,0,-1),f(t.y-t.x,-t.x-t.y,t.x,t.y,0,1)),B===I.ROUND&&(f(-t.y-t.x,t.x-t.y,t.x,t.y,-1,-1),f(t.y-t.x,-t.x-t.y,t.x,t.y,-1,1)),B!==I.ROUND&&B!==I.BUTT||(f(-t.y,t.x,t.x,t.y,0,-1),f(t.y,-t.x,t.x,t.y,0,1));continue}if(G){k(n,i),c=n.x,u=n.y,B!==I.ROUND&&B!==I.BUTT||(f(i.y,-i.x,-i.x,-i.y,0,-1),f(-i.y,i.x,-i.x,-i.y,0,1)),B===I.SQUARE&&(f(i.y-i.x,-i.x-i.y,-i.x,-i.y,0,-1),f(-i.y-i.x,i.x-i.y,-i.x,-i.y,0,1)),B===I.ROUND&&(f(i.y-i.x,-i.x-i.y,-i.x,-i.y,1,-1),f(-i.y-i.x,i.x-i.y,-i.x,-i.y,1,1));continue}}let V,L,A=-Ut(i,t);if(Math.abs(A)<.01)gt(i,t)>0?(n.x=i.x,n.y=i.y,A=1,V=Number.MAX_VALUE,L=!0):(p(n,t),A=1,V=1,L=!1);else{n.x=(i.x+t.x)/A,n.y=(i.y+t.y)/A,V=ft(n);const x=(V-1)*b*F;L=V>4||x>J&&x>Q}c=n.x,u=n.y;let O=j;switch(j){case D.BEVEL:V<1.05&&(O=D.MITER);break;case D.ROUND:V<X&&(O=D.MITER);break;case D.MITER:V>W&&(O=D.BEVEL)}switch(O){case D.MITER:if(f(n.x,n.y,-i.x,-i.y,0,-1),f(-n.x,-n.y,-i.x,-i.y,0,1),G)break;if(w){const x=Y?0:l;d=this._writeVertex(h,y,c,u,t.x,t.y,n.x,n.y,0,-1,x),o=this._writeVertex(h,y,c,u,t.x,t.y,-n.x,-n.y,0,1,x)}break;case D.BEVEL:{const x=A<0;let g,E,q,R;if(x){const a=d;d=o,o=a,g=rt,E=xt}else g=xt,E=rt;if(L)q=x?p(this._innerPrev,i):k(this._innerPrev,i),R=x?k(this._innerNext,t):p(this._innerNext,t);else{const a=x?dt(this._inner,n):Tt(this._inner,n);q=a,R=a}const U=x?k(this._bevelStart,i):p(this._bevelStart,i);f(q.x,q.y,-i.x,-i.y,g.x,g.y);const yt=f(U.x,U.y,-i.x,-i.y,E.x,E.y);if(G)break;const P=x?p(this._bevelEnd,t):k(this._bevelEnd,t);if(L){const a=this._writeVertex(h,y,c,u,-i.x,-i.y,0,0,0,0,l);d=this._writeVertex(h,y,c,u,t.x,t.y,R.x,R.y,g.x,g.y,l),o=this._writeVertex(h,y,c,u,t.x,t.y,P.x,P.y,E.x,E.y,l),this._writeTriangle(yt,a,o)}else{if(w){const a=this._bevelMiddle;a.x=(U.x+P.x)/2,a.y=(U.y+P.y)/2,it(v,a,-i.x,-i.y),f(a.x,a.y,-i.x,-i.y,v.x,v.y),it(v,a,t.x,t.y),d=this._writeVertex(h,y,c,u,t.x,t.y,a.x,a.y,v.x,v.y,l),o=this._writeVertex(h,y,c,u,t.x,t.y,R.x,R.y,g.x,g.y,l)}else{const a=d;d=o,o=a}f(P.x,P.y,t.x,t.y,E.x,E.y)}if(x){const a=d;d=o,o=a}break}case D.ROUND:{const x=A<0;let g,E;if(x){const N=d;d=o,o=N,g=rt,E=xt}else g=xt,E=rt;const q=x?dt(this._inner,n):Tt(this._inner,n);let R,U;L?(R=x?p(this._innerPrev,i):k(this._innerPrev,i),U=x?k(this._innerNext,t):p(this._innerNext,t)):(R=q,U=q);const yt=x?k(this._roundStart,i):p(this._roundStart,i),P=x?p(this._roundEnd,t):k(this._roundEnd,t),a=f(R.x,R.y,-i.x,-i.y,g.x,g.y),ht=f(yt.x,yt.y,-i.x,-i.y,E.x,E.y);if(G)break;const z=this._writeVertex(h,y,c,u,-i.x,-i.y,0,0,0,0,l);L||this._writeTriangle(d,o,z);const S=dt(this._outer,q),H=this._writeVertex(h,y,c,u,t.x,t.y,P.x,P.y,E.x,E.y,l);let Z,tt;const ot=V>2;if(ot){let N;V!==Number.MAX_VALUE?(S.x/=V,S.y/=V,N=gt(i,S),N=(V*(N*N-1)+1)/N):N=-1,Z=x?k(this._startBreak,i):p(this._startBreak,i),Z.x+=i.x*N,Z.y+=i.y*N,tt=x?p(this._endBreak,t):k(this._endBreak,t),tt.x+=t.x*N,tt.y+=t.y*N}it(v,S,-i.x,-i.y);const lt=this._writeVertex(h,y,c,u,-i.x,-i.y,S.x,S.y,v.x,v.y,l);it(v,S,t.x,t.y);const ct=w?this._writeVertex(h,y,c,u,t.x,t.y,S.x,S.y,v.x,v.y,l):lt,ut=z,at=w?this._writeVertex(h,y,c,u,t.x,t.y,0,0,0,0,l):z;let et=-1,st=-1;if(ot&&(it(v,Z,-i.x,-i.y),et=this._writeVertex(h,y,c,u,-i.x,-i.y,Z.x,Z.y,v.x,v.y,l),it(v,tt,t.x,t.y),st=this._writeVertex(h,y,c,u,t.x,t.y,tt.x,tt.y,v.x,v.y,l)),w?ot?(this._writeTriangle(ut,ht,et),this._writeTriangle(ut,et,lt),this._writeTriangle(at,ct,st),this._writeTriangle(at,st,H)):(this._writeTriangle(ut,ht,lt),this._writeTriangle(at,ct,H)):ot?(this._writeTriangle(z,ht,et),this._writeTriangle(z,et,st),this._writeTriangle(z,st,H)):(this._writeTriangle(z,ht,lt),this._writeTriangle(z,ct,H)),L?(d=this._writeVertex(h,y,c,u,t.x,t.y,U.x,U.y,g.x,g.y,l),o=H):(d=w?this._writeVertex(h,y,c,u,t.x,t.y,U.x,U.y,g.x,g.y,l):a,this._writeTriangle(d,at,H),o=H),x){const N=d;d=o,o=N}break}}}}}const kt=128e3;let wt=null,Vt=null;async function Pt(){return wt||(wt=Bt()),wt}async function Bt(){Vt=await(bt("esri-csp-restrictions")?await vt(()=>import("./libtess-asm-CfQP31-y.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then((e=>e.l)):await vt(()=>import("./libtess-Bioqp9UR.js"),__vite__mapDeps([4,1,2,3]),import.meta.url).then((e=>e.l))).default({locateFile:e=>pt(`esri/core/libs/libtess/${e}`)})}function St(s,e){const r=Math.max(s.length,kt);return Vt.triangulate(s,e,r)}export{St as a,Ot as c,Pt as i,At as t};
