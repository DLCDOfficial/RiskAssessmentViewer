import{bH as $,aB as p,aO as At,a6 as N,$ as Et,cq as C,B as St,J as Ft}from"./index-DzoQLc5A.js";import{s as et,I as Nt,v as nt,g as y,u as P,q as ot,p as Z}from"./vec32-LyzMesOw.js";import{v as xt,h as Mt,j as jt}from"./lineSegment-BnQxKnu0.js";import{s as _t,b as it,w as W,k as st,N as q,H as rt,E as B,U as l,i as ft}from"./sphere-DVa6yVTZ.js";import"./plane-BM5dy-fQ.js";import"./vectorStacks-BcGsIGGR.js";import{i as mt}from"./BufferView-6Wo0HYee.js";import{g as Bt}from"./edgeProcessing-Dw3MNk6H.js";import"https://js.arcgis.com/map-components/4.33/arcgis-map-components.esm.js";import"./mat3-D2DxLcs1.js";import"./mat3f64-B5o_lm6j.js";import"./mat4f64-Busq8X2U.js";import"./quatf64-aQ5IuZRd.js";import"./vec2f64-B08OqgY-.js";import"./vec2-D0N3Bz89.js";import"./deduplicate-D67lYUNS.js";import"./Indices-Die4BdlF.js";import"./InterleavedLayout-DWIRiq9i.js";import"./types-BKo2foNY.js";import"./VertexAttribute-C1eU-FcF.js";import"./enums-CIq3dAOf.js";import"./VertexElementDescriptor-BLyltQyJ.js";function pt(o){return o?{ray:it(o.ray),c0:o.c0,c1:o.c1}:{ray:it(),c0:0,c1:Number.MAX_VALUE}}new _t((()=>pt()));function w(o,t){for(let e=0;e<Pt;e++){const n=o[e];if(n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]>=t[3])return!1}return!0}var at,u;(function(o){o[o.LEFT=0]="LEFT",o[o.RIGHT=1]="RIGHT",o[o.BOTTOM=2]="BOTTOM",o[o.TOP=3]="TOP",o[o.NEAR=4]="NEAR",o[o.FAR=5]="FAR"})(at||(at={})),(function(o){o[o.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",o[o.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",o[o.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",o[o.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",o[o.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",o[o.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",o[o.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",o[o.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"})(u||(u={}));u.FAR_BOTTOM_RIGHT,u.NEAR_BOTTOM_RIGHT,u.NEAR_BOTTOM_LEFT,u.FAR_BOTTOM_LEFT,u.NEAR_BOTTOM_LEFT,u.NEAR_BOTTOM_RIGHT,u.NEAR_TOP_RIGHT,u.NEAR_TOP_LEFT,u.FAR_BOTTOM_RIGHT,u.FAR_BOTTOM_LEFT,u.FAR_TOP_LEFT,u.FAR_TOP_RIGHT,u.NEAR_BOTTOM_RIGHT,u.FAR_BOTTOM_RIGHT,u.FAR_TOP_RIGHT,u.NEAR_TOP_RIGHT,u.FAR_BOTTOM_LEFT,u.NEAR_BOTTOM_LEFT,u.NEAR_TOP_LEFT,u.FAR_TOP_LEFT,u.FAR_TOP_LEFT,u.NEAR_TOP_LEFT,u.NEAR_TOP_RIGHT,u.FAR_TOP_RIGHT;const Pt=6;new _t(pt);let H=class U{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new _,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),_.clearPool(),X[0]=null,M.prune(),j.prune()}add(t){const e=Array.from(t);this._grow(e);const n=_.acquire();for(const i of e)++this._objectCount,this._isDegenerate(i)?this._degenerateObjects.add(i):(n.init(this._root),this._add(i,n));_.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=_.acquire();for(const i of t){const r=e??W(this.objectToBoundingSphere(i),Dt);z(r[3])?(n.init(this._root),Lt(i,r,n)):this._degenerateObjects.delete(i)}_.release(n),this._shrink()}update(t,e){if(!z(e[3])&&this._isDegenerate(t))return;const n=Ct(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const i=st(t,e);x(this._root,(r=>{if(!zt(i,r))return!1;const a=r.node;return a.terminals.forAll((h=>{this._intersectsObject(i,h)&&n(h)})),a.residents!==null&&a.residents.forAll((h=>{this._intersectsObject(i,h)&&n(h)})),!0}))}forEachAlongRayWithVerticalOffset(t,e,n,i){const r=st(t,e);x(this._root,(a=>{if(!$t(r,a,i))return!1;const h=a.node;return h.terminals.forAll((s=>{this._intersectsObjectWithOffset(r,s,i)&&n(s)})),h.residents!==null&&h.residents.forAll((s=>{this._intersectsObjectWithOffset(r,s,i)&&n(s)})),!0}))}forEach(t){x(this._root,(e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0})),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,i=()=>!0,r=1/0){let a=1/0,h=1/0,s=null;const d=k(t,e),f=c=>{if(--r,!i(c))return;const T=this.objectToBoundingSphere(c);if(!w(n,T))return;const R=F(t,e,l(T)),L=R-T[3],m=R+T[3];L<a&&(a=L,h=m,s=c)};return ht(this._root,(c=>{if(r<=0||!w(n,c.bounds)||(y(g,d,c.halfSize),P(g,g,l(c.bounds)),F(t,e,g)>h))return!1;const T=c.node;return T.terminals.forAll((R=>f(R))),T.residents!==null&&T.residents.forAll((R=>f(R))),!0}),t,e),s}forEachInDepthRange(t,e,n,i,r,a,h){let s=-1/0,d=1/0;const f={setRange:m=>{n===U.DepthOrder.FRONT_TO_BACK?(s=Math.max(s,m.near),d=Math.min(d,m.far)):(s=Math.max(s,-m.far),d=Math.min(d,-m.near))}};f.setRange(i);const c=F(e,n,t),T=k(e,n),R=k(e,-n),L=m=>{if(!h(m))return;const S=this.objectToBoundingSphere(m),I=l(S),tt=F(e,n,I)-c,gt=tt-S[3],Rt=tt+S[3];gt>d||Rt<s||!w(a,S)||r(m,f)};ht(this._root,(m=>{if(!w(a,m.bounds)||(y(g,T,m.halfSize),P(g,g,l(m.bounds)),F(e,n,g)-c>d)||(y(g,R,m.halfSize),P(g,g,l(m.bounds)),F(e,n,g)-c<s))return!1;const S=m.node;return S.terminals.forAll((I=>L(I))),S.residents!==null&&S.residents.forAll((I=>L(I))),!0}),e,n)}forEachNode(t){x(this._root,(e=>t(e.node,e.bounds,e.halfSize,e.depth)))}forEachNeighbor(t,e){const n=q(e),i=l(e),r=s=>{const d=this.objectToBoundingSphere(s),f=q(d),c=n+f;return!(nt(l(d),i)-c*c<=0)||t(s)};let a=!0;const h=s=>{a&&(a=r(s))};x(this._root,(s=>{const d=q(s.bounds),f=n+d;if(nt(l(s.bounds),i)-f*f>0)return!1;const c=s.node;return c.terminals.forAll(h),a&&c.residents!==null&&c.residents.forAll(h),a})),a&&this.forEachDegenerateObject(h)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n[3]>0)||rt(n,t)}_intersectsObjectWithOffset(t,e,n){const i=this.objectToBoundingSphere(e);return!(i[3]>0)||rt(n.applyToBoundingSphere(i),t)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const i=_.acquire().init(t);this._add(e.at(n),i),_.release(i)}}_grow(t){if(dt(t,(e=>this.objectToBoundingSphere(e)),A),z(A[3])&&!this._fitsInsideTree(A))if(Tt(this._root.node))W(A,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(A);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(A,e):this._growRootAsSubNode(e),_.release(e)}}_rebuildTree(t,e){et(l(J),l(e.bounds)),J[3]=e.halfSize,dt([t,J],(i=>i),K);const n=_.acquire().init(this._root);this._root.initFrom(null,K,K[3]),this._root.increaseHalfSize(1.25),x(n,(i=>(this.add(i.node.terminals.data),i.node.residents!==null&&this.add(i.node.residents.data),!0))),_.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return x(this._root,(i=>(n=Math.max(n,i.depth),n+e<=this._maximumDepth))),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let i=-1/0;const r=this._root.bounds,a=this._root.halfSize;for(let s=0;s<3;s++){const d=r[s]-a-(n[s]-e),f=n[s]+e-(r[s]+a),c=Math.max(0,Math.ceil(d/(2*a))),T=Math.max(0,Math.ceil(f/(2*a)))+1,R=2**Math.ceil(Math.log(c+T)*Math.LOG2E);i=Math.max(i,R),v[s].min=c,v[s].max=T}for(let s=0;s<3;s++){let d=v[s].min,f=v[s].max;const c=(i-(d+f))/2;d+=Math.ceil(c),f+=Math.floor(c);const T=r[s]-a-d*a*2;V[s]=T+(f+d)*a}const h=i*a;return V[3]=h*bt,_.acquire().initFrom(null,V,h,0)}_growRootAsSubNode(t){const e=this._root.node;et(l(A),l(this._root.bounds)),A[3]=this._root.halfSize,this._root.init(t),t.advanceTo(A,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,i=0;for(;i<e.length&&t==null;)n=i++,t=e[n];for(;i<e.length;)if(e[i++])return-1;return n}_isDegenerate(t){return!z(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,i=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:i}}}_nodeToJSON(t){var r,a;const e=t.children.map((h=>h?this._nodeToJSON(h):null)),n=(r=t.residents)==null?void 0:r.map((h=>this.objectToBoundingSphere(h))),i=(a=t.terminals)==null?void 0:a.map((h=>this.objectToBoundingSphere(h)));return{children:e,residents:n,terminals:i}}static fromJSON(t){const e=new U((n=>n),{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}};const E=class E{constructor(){this.bounds=B(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,i=this.depth){return this.node=t??E.createEmptyNode(),e&&W(e,this.bounds),this.halfSize=n,this.depth=i,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*bt}advance(t){let e=this.node.children[t];e||(e=E.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=Ot[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const i=this._childIndex(t);e&&e(this,i),this.advance(i)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new $({shrink:!0}),residents:new $({shrink:!0})}}static acquire(){return E._pool.acquire()}static release(t){E._pool.release(t)}static clearPool(){E._pool.prune()}};E._pool=new At(E);let _=E;function x(o,t){let e=_.acquire().init(o);const n=[e];for(;n.length!==0;){if(e=n.pop(),t(e)&&!e.isLeaf())for(let i=0;i<e.node.children.length;i++)e.node.children[i]&&n.push(_.acquire().init(e).advance(i));_.release(e)}}function ht(o,t,e,n=H.DepthOrder.FRONT_TO_BACK){let i=_.acquire().init(o);const r=[i];for(vt(e,n,ct);r.length!==0;){if(i=r.pop(),t(i)&&!i.isLeaf())for(let a=7;a>=0;--a){const h=ct[a];i.node.children[h]&&r.push(_.acquire().init(i).advance(h))}_.release(i)}}function Lt(o,t,e){M.clear();const n=e.advanceTo(t,((i,r)=>{M.push(i.node),M.push(r)}))?e.node.terminals:e.node.residents;if(n.removeUnordered(o),n.length===0)for(let i=M.length-2;i>=0&&It(M.data[i],M.data[i+1]);i-=2);}function It(o,t){return t>=0&&(o.children[t]=null),!!Tt(o)&&(o.residents===null&&(o.residents=new $({shrink:!0})),!0)}function zt(o,t){return D(l(t.bounds),2*-t.halfSize,O),D(l(t.bounds),2*t.halfSize,b),mt(o.origin,o.direction,O,b)}function $t(o,t,e){return D(l(t.bounds),2*-t.halfSize,O),D(l(t.bounds),2*t.halfSize,b),e.applyToMinMax(O,b),mt(o.origin,o.direction,O,b)}function Tt(o){if(o.terminals.length!==0)return!1;if(o.residents!==null)return o.residents.length===0;for(let t=0;t<o.children.length;t++)if(o.children[t])return!1;return!0}function Ht(o,t){o[0]=Math.min(o[0],t[0]-t[3]),o[1]=Math.min(o[1],t[1]-t[3]),o[2]=Math.min(o[2],t[2]-t[3])}function wt(o,t){o[0]=Math.max(o[0],t[0]+t[3]),o[1]=Math.max(o[1],t[1]+t[3]),o[2]=Math.max(o[2],t[2]+t[3])}function D(o,t,e){e[0]=o[0]+t,e[1]=o[1]+t,e[2]=o[2]+t}function dt(o,t,e){O[0]=1/0,O[1]=1/0,O[2]=1/0,b[0]=-1/0,b[1]=-1/0,b[2]=-1/0;for(const n of o){const i=t(n);z(i[3])&&(Ht(O,i),wt(b,i))}Nt(l(e),O,b,.5),e[3]=Math.max(b[0]-O[0],b[1]-O[1],b[2]-O[2])/2}function vt(o,t,e){if(!j.length)for(let n=0;n<8;++n)j.push({index:0,distance:0});for(let n=0;n<8;++n){const i=Ot[n];j.data[n].index=n,j.data[n].distance=F(o,t,i)}j.sort(((n,i)=>n.distance-i.distance));for(let n=0;n<8;++n)e[n]=j.data[n].index}function k(o,t){let e,n=1/0;for(let i=0;i<8;++i){const r=F(o,t,ut[i]);r<n&&(n=r,e=ut[i])}return e}function F(o,t,e){return t*(o[0]*e[0]+o[1]*e[1]+o[2]*e[2])}function z(o){return!isNaN(o)&&o!==-1/0&&o!==1/0&&o>0}(function(o){var t;(t=o.DepthOrder||(o.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(H||(H={}));const Ot=[p(-1,-1,-1),p(1,-1,-1),p(-1,1,-1),p(1,1,-1),p(-1,-1,1),p(1,-1,1),p(-1,1,1),p(1,1,1)],ut=[p(-1,-1,-1),p(-1,-1,1),p(-1,1,-1),p(-1,1,1),p(1,-1,-1),p(1,-1,1),p(1,1,-1),p(1,1,1)],bt=Math.sqrt(3),X=[null];function Ct(o){return X[0]=o,X}const V=B(),g=N(),O=N(),b=N(),M=new $,Dt=B(),A=B(),J=B(),K=B(),v=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],j=new $,ct=[0,0,0,0,0,0,0,0],Gt=1e3;function yt(o,t,e){const n=B(),i=l(n);return ot(i,i,o,.5),ot(i,i,t,.5),n[3]=Z(i,o),P(i,i,e),n}let Q=class{constructor(){this._idToComponent=new Map,this._components=new H((o=>o.bounds)),this._edges=new H((o=>o.bounds)),this._tmpLineSegment=xt(),this._tmpP1=N(),this._tmpP2=N(),this._tmpP3=N(),this.remoteClient=null}async fetchCandidates(o,t){await Promise.resolve(),Et(t),await this._ensureEdgeLocations(o,t);const e=[];return this._edges.forEachNeighbor((n=>(this._addCandidates(o,n,e),e.length<Gt)),o.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(o,t){const e=[];if(this._components.forEachNeighbor((r=>{if(r.info==null){const{id:a,uid:h}=r;e.push({id:a,uid:h})}return!0}),o.bounds),!e.length)return;const n={components:e},i=await this.remoteClient.invoke("fetchAllEdgeLocations",n,t??{});for(const r of i.components)this._setFetchEdgeLocations(r)}async add(o){const t=new Y(o.id,o.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(o){const t=this._idToComponent.get(o.id);if(t){const e=[];this._edges.forEachNeighbor((n=>(n.component===t&&e.push(n),!0)),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(o){const t=this._idToComponent.get(o.id);if(t==null||o.uid!==t.uid)return;const e=Bt.createView(o.locations),n=new Array(e.count),i=N(),r=N();for(let s=0;s<e.count;s++){e.position0.getVec(s,i),e.position1.getVec(s,r);const d=yt(i,r,o.origin),f=new qt(t,s,d);n[s]=f}this._edges.add(n);const{objectIds:a,origin:h}=o;t.info={locations:e,objectIds:a,origin:h}}_addCandidates(o,t,e){const{info:n}=t.component,{origin:i,objectIds:r}=n,a=n.locations,h=a.position0.getVec(t.index,this._tmpP1),s=a.position1.getVec(t.index,this._tmpP2);P(h,h,i),P(s,s,i);const d=r[a.componentIndex.get(t.index)];this._addEdgeCandidate(o,d,h,s,e),lt(o,d,h,e),lt(o,d,s,e)}_addEdgeCandidate(o,t,e,n,i){if(!o.returnEdge)return;const r=l(o.bounds),a=Mt(e,n,this._tmpLineSegment),h=jt(a,r,this._tmpP3);ft(o.bounds,h)&&i.push({type:"edge",objectId:t,target:C(h),distance:Z(r,h),start:C(e),end:C(n)})}};Q=St([Ft("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],Q);const le=Q;function lt(o,t,e,n){if(!o.returnVertex||!ft(o.bounds,e))return;const i=l(o.bounds);n.push({type:"vertex",objectId:t,target:C(e),distance:Z(i,e)})}const G=class G{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++G.uid}};G.uid=0;let Y=G;class qt{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}export{le as default};
