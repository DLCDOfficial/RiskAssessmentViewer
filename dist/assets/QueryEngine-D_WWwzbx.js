const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-DGETChXf.js","./geometryEngineBase-BV9OKxkg.js","./_commonjsHelpers-BcY2WciP.js","./index-BbP3371Q.js","./json-Wa8cmqdu.js","./intersectsOperator-BabvpyGm.js","./OperatorIntersects-DExe29Qj.js","./ProjectionTransformation-CSOGIsAN.js","./Envelope2D-Da8Eb6by.js","./Point2D-C8Vjr_uf.js","./Transformation2D-a6U1dcm_.js","./SimpleGeometryCursor-B92kdZ15.js","./index-DzoQLc5A.js","./index-FMl8DCyv.css","./OperatorDefinitions-DP7_WWTp.js","./jsonConverter-6QX7GqU9.js","./containsOperator-GnkxENvA.js","./crossesOperator-CfnLjjrK.js","./OperatorCrosses-BQEH2NuI.js","./disjointOperator-gw19WMTJ.js","./overlapsOperator-UpXXdD7X.js","./OperatorOverlaps-D-NWulJ6.js","./touchesOperator-yqpWpb2O.js","./OperatorTouches-BS6uq_xM.js","./withinOperator-BLzZu6IJ.js","./OperatorWithin-BDe2SSpu.js"])))=>i.map(i=>d[i]);
import{s as v,c3 as ke,bc as Se,bd as we,T as te,m as ut,cb as X,aj as Q,bb as Ue,cd as _e,_ as U,ji as bt,iw as Qe,jj as At,jk as vt,a5 as fe,be as Nt,hF as he,jl as Pt,jm as Ot,aD as Oe,cj as Ce,jn as Ct,jo as $t,aN as Dt,bJ as ie,fU as ct,O as me,b2 as Vt,B as ye,F as Be,J as Lt,bX as Mt,jp as Te,bH as Ie,bY as Gt,fS as kt,a_ as be,j as Ut,jq as Qt,bZ as Bt,jr as zt,c2 as qt,ci as jt,fM as Zt,bB as V,$ as Ht,js as Yt,bF as Wt,gs as Jt,dS as Ee,bI as Xt,bK as Kt,jt as es,gq as ts,aL as ze,ck as ss,bE as is}from"./index-DzoQLc5A.js";import{d as rs,$ as as,Q as ns,D as ls,E as Ae,g as ve,G as os,X as qe,u as us}from"./featureConversionUtils-4vS7e9DV.js";import{WhereClauseCache as cs}from"./WhereClauseCache-DaRLeTPC.js";import{e as le}from"./OptimizedFeature-DdLiUxBt.js";import{j as re,m as hs,n as ds,a as fs,b as ms,h as z,s as ps,x as $e,S as q,w as gs,c as je,d as _s}from"./FixedIntervalBinParameters-DX-Dxyp5.js";import{t as ys}from"./QueryEngineCapabilities-CsRUnGk7.js";import{s as Ze}from"./quantizationUtils-DJOt4u77.js";import{I as Ts}from"./utils-Cr3t4q4M.js";import{m as Re,B as Is,d as Es,f as He,p as Ye,C as Rs,k as xs,$ as Fs,E as Ss,P as ws,U as bs,g as As,v as vs,L as Ns,G as We}from"./utils-CeM4xVkE.js";import{r as pe}from"./signal-CCMhCnaC.js";import{n as L}from"./time-ClENgjgA.js";const ht=new cs(50,500),ae="unsupported-query",dt=" as ",ft=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),mt=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Ps=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...ft,...mt]);function De(n,e,t={}){const i=Z(e,n);if(!i){const s=ht.getError(e,n);throw new v(ae,"invalid SQL expression",{expression:e,error:s})}const r=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new v(ae,`${r} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new v(ae,`${r} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function Os(n,e,t,i){if(!t)return!0;const r="where clause";return B(n,e,De(n,t,{validateStandardized:!0,expressionName:r}),{expressionName:r,query:i}),!0}function Cs(n,e,t,i,r){if(!t)return!0;const s="having clause",a=De(n,t,{validateAggregate:!0,expressionName:s});B(n,e,a,{expressionName:s,query:r});const l=Z(t,n);if(!(l==null?void 0:l.getExpressions().every((u=>{var m;const{aggregateType:c,field:h}=u,d=(m=n.get(h))==null?void 0:m.name;return i.some((f=>{var w;const{onStatisticField:p,statisticType:T}=f;return((w=n.get(p))==null?void 0:w.name)===d&&T.toLowerCase().trim()===c}))}))))throw new v(ae,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function Z(n,e){return n?ht.get(n,e):null}function pt(n){return/\((.*?)\)/.test(n)?n:n.split(dt)[0]}function $s(n){return n.split(dt)[1]}function B(n,e,t,i={}){const r=new Map;if(Ds(r,n,e,i.allowedFieldTypes??Ps,t),r.size){const s=i.expressionName??"expression";throw new v(ae,`${s} contains invalid or missing fields`,{errors:Array.from(r.values()),query:i.query})}}function Ds(n,e,t,i,r){const s=r.includes("*")?[...t,...r.filter((a=>a!=="*"))]:r;for(const a of s)if(e.get(a))Je(n,e,t,i,a);else try{const l=De(e,pt(a),{validateStandardized:!0});for(const o of l)Je(n,e,t,i,o)}catch(l){n.set(a,{type:"expression-error",expression:a,error:l})}}function Je(n,e,t,i,r){const s=e.get(r);s?t.has(s.name)?i!=="all"&&(i==null?void 0:i.has(s.type))===!1&&n.set(r,{type:"invalid-type",fieldName:s.name,fieldType:ke.fromJSON(s.type),allowedFieldTypes:Array.from(i,(a=>ke.fromJSON(a)))}):n.set(r,{type:"missing-field",fieldName:s.name}):n.set(r,{type:"invalid-field",fieldName:r})}const Xe=new le,Vs=new le,Ne=new le,M={esriGeometryPoint:Ae,esriGeometryPolyline:ls,esriGeometryPolygon:ns,esriGeometryMultipoint:as};function xe(n,e,t,i=n.hasZ,r=n.hasM){if(e==null)return null;const s=n.hasZ&&i,a=n.hasM&&r;if(t){const l=ve(Ne,e,n.hasZ,n.hasM,"esriGeometryPoint",t,i,r);return Ae(l,s,a)}return Ae(e,s,a)}function G(n,e,t,i,r,s,a=e,l=t){var h,d,m;const o=e&&a,u=t&&l,c=i!=null?"coords"in i?i:i.geometry:null;if(c==null)return null;if(r){let f=rs(Vs,c,e,t,n,r,a,l);return s&&(f=ve(Ne,f,o,u,n,s)),((h=M[n])==null?void 0:h.call(M,f,o,u))??null}if(s){const f=ve(Ne,c,e,t,n,s,a,l);return((d=M[n])==null?void 0:d.call(M,f,o,u))??null}return os(Xe,c,e,t,a,l),((m=M[n])==null?void 0:m.call(M,Xe,o,u))??null}function ne(n){return n&&gt in n?JSON.parse(JSON.stringify(n,Ls)):n}const gt="_geVersion",Ls=(n,e)=>n===gt?void 0:e,Ms=5;let Gs=class{constructor(){this._storage=new Map,this._purgeInterval=Ms,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,r]of this._storage){if(!(r.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){var e;(e=this._storage)==null||e.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){var i;(i=this._storage)==null||i.set(e,new Us(t)),this._scheduleSweep()}get(e){var i,r,s;const t=(i=this._storage)==null?void 0:i.get(e);if(t)return(r=this._storage)==null||r.delete(e),t.time=performance.now(),(s=this._storage)==null||s.set(e,t),t.items}clear(){var e;(e=this._storage)==null||e.clear()}_scheduleSweep(){this._storage&&(this._timer??(this._timer=setTimeout(this._sweep,1e3*this._purgeInterval)))}get test(){}},ks=0,Us=class{constructor(e){this.items=e,this.time=performance.now(),this.id=ks++}},ee=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const r=e.outFields;if(r&&!r.includes("*")){this.outFields=r;let s=0;for(const a of r){const l=pt(a),o=this.fieldsIndex.get(l),u=o?null:Z(l,i),c=o?o.name:$s(a)||"FIELD_EXP_"+s++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){var a;const r=i?i.name:t;let s=null;return this._fieldDataCache.has(r)?s=(a=this._fieldDataCache.get(r))==null?void 0:a.clause:i||(s=Z(t,this.fieldsIndex),this._fieldDataCache.set(r,{alias:r,clause:s})),i?this.featureAdapter.getAttribute(e,r):s==null?void 0:s.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const r=t.normalizationType,s=t.normalizationTotal,a=this.fieldsIndex.get(t.field),l=Se(a)||we(a),o=te(a);return e.map((u=>{let c=t.field&&this.getFieldValue(u,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${Re(c)}${t.fieldDelimiter}${Re(this.getFieldValue(u,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${Re(this.getFieldValue(u,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&i&&(l?c=c?new Date(c).getTime():null:o&&(c=c?Ts(c):null)),r&&Number.isFinite(c)){const h=r==="field"&&t.normalizationField?this.getFieldValue(u,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=Is(c,r,h,s)}return c}))}async getExpressionValues(e,t,i,r,s){const{arcadeUtils:a}=await ut(),l=a.hasGeometryOperations(t);l&&await a.enableGeometryOperations();const o=a.createFunction(t),u=a.getViewInfo(i),c={fields:this.fieldsIndex.fields};return e.map((h=>{const d={attributes:this.featureAdapter.getAttributes(h),layer:c,geometry:l?{...G(r.geometryType,r.hasZ,r.hasM,this.featureAdapter.getGeometry(h)),spatialReference:i==null?void 0:i.spatialReference}:null},m=a.createExecContext(d,u,s);return a.executeFunction(o,m)}))}validateItem(e,t){var i,r;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),((r=(i=this._fieldDataCache.get(t))==null?void 0:i.clause)==null?void 0:r.testFeature(e,this.featureAdapter))??!1}validateItems(e,t){var i,r;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),((r=(i=this._fieldDataCache.get(t))==null?void 0:i.clause)==null?void 0:r.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!(t!=null&&t.length))return this.featureAdapter.getAttributes(e);const i={};for(const r of t){const{alias:s,clause:a}=this._fieldDataCache.get(r);i[s]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,s)}return i}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:l}=this._fieldDataCache.get(a);i.push(e[l])}else for(const a in e)i.push(e[a]);const r=`${(t||["*"]).join(",")}=${i.join(",")}`;let s=this._returnDistinctMap.get(r)||0;return this._returnDistinctMap.set(r,++s),s>1?null:e}};function Ke(n,e,t){return{objectId:n,target:e,distance:t,type:"vertex"}}function Qs(n,e,t,i,r,s=!1){return{objectId:n,target:e,distance:t,type:"edge",start:i,end:r,draped:s}}const J="bin";let P=class{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new ee(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:r}=this.query;if(!(t==null?void 0:t.length))return 1;const a=new Map,l=new Map,o=new Set;for(const u of r){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!l.has(h)){const m=[];for(const f of t){const p=this._getAttributeValues(e,f,this.items,a);m.push(p)}l.set(h,this._calculateUniqueValues(m,this.items,e.returnDistinctValues))}const d=l.get(h);for(const m in d){const{data:f,items:p}=d[m],T=f.join(",");i&&!e.validateItems(p,i)||o.add(T)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some((t=>t.statisticType==="exceedslimit"))?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;X(this.query.outSR)&&!Q(t.spatialReference,this.query.outSR)?e.queryGeometry=ne({spatialReference:this.query.outSR,...re(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=ne({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const r=this.featureAdapter,s=et(this.hasZ,this.hasM),{point:a,mode:l}=e,o=typeof e.distance=="number"?e.distance:e.distance.x,u=typeof e.distance=="number"?e.distance:e.distance.y,c={candidates:[]},h=this.geometryType==="esriGeometryPolygon",d=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",m=this._getPointCreator(l,t,this.spatialReference,i),f=new tt(null,0),p=new tt(null,0),T={x:0,y:0,z:0};for(const I of this.items){const w=r.getGeometry(I);if(w==null)continue;const{coords:A}=w,R=w.isPoint?zs:w.lengths;if(f.coords=A,p.coords=A,e.returnEdge){let F=0;for(let b=0;b<R.length;b++){const x=R[b],_=F;for(let g=0;g<x;g++,F+=s){if(!h&&g===x-1)continue;const S=f;S.coordsIndex=F;const E=p;E.coordsIndex=g===x-1?_:F+s;const O=T;if(!Bs(T,a,S,E))continue;const D=(a.x-O.x)/o,N=(a.y-O.y)/u,Y=D*D+N*N;Y<=1&&c.candidates.push(Qs(r.getObjectId(I),m(O),Math.sqrt(Y),m(S),m(E)))}}}if(e.vertexMode==="all"){let F=0;for(let b=0;b<R.length;b++){const x=R[b],_=F,g=p;g.coordsIndex=_;for(let S=0;S<x;S++,F+=s){const E=f;if(E.coordsIndex=F,h&&S===x-1&&E.x===g.x&&E.y===g.y)continue;const O=(a.x-E.x)/o,D=(a.y-E.y)/u,N=O*O+D*D;N<=1&&c.candidates.push(Ke(r.getObjectId(I),m(E),Math.sqrt(N)))}}}else if(d&&e.vertexMode==="ends"){let F=0;const b=[];for(let x=0;x<R.length;x++){b.push(F);const _=R[x];F+=_*s,!h&&_>1&&b.push(F-s)}for(const x of b){const _=f;_.coordsIndex=x;const g=(a.x-_.x)/o,S=(a.y-_.y)/u,E=g*g+S*S;E<=1&&c.candidates.push(Ke(r.getObjectId(I),m(_),Math.sqrt(E)))}}}return c.candidates.sort(((I,w)=>I.distance-w.distance)),c}_getPointCreator(e,t,i,r){const s=r==null||Q(i,r)?o=>o:o=>re(o,i,r),{hasZ:a}=this,l=0;return e==="3d"?a&&t?({x:o,y:u,z:c})=>s({x:o,y:u,z:c}):({x:o,y:u})=>s({x:o,y:u,z:l}):({x:o,y:u})=>s({x:o,y:u})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,minValue:l,maxValue:o,scale:u,timeZone:c,outStatisticTypes:h}=e,d=this.fieldsIndex.get(t),m=Ue(d)||Se(d)||we(d),f=await this._getDataValues({field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,scale:u,timeZone:c},this.items),p=Es({normalizationType:s,normalizationField:r,minValue:l,maxValue:o}),T={value:.5,fieldType:d==null?void 0:d.type},I=_e(d)?He({values:f,supportsNullCount:p,percentileParams:T,outStatisticTypes:h}):Ye({values:f,minValue:l,maxValue:o,useSampleStdDev:!s,supportsNullCount:p,percentileParams:T,outStatisticTypes:h});return Rs(I,h,m)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:r,returnAllCodedValues:s,scale:a,timeZone:l}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:a,timeZone:l},this.items,!1),u=xs(o);return Fs(u,r,s,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:h,scale:d,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,scale:d,timeZone:m},this.items),p=Ss(f,{field:t,normalizationField:r,normalizationType:s,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:h});return ws(p,l)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:h,scale:d,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:r,normalizationType:s,normalizationTotal:a,scale:d,timeZone:m},this.items);return bs(f,{field:t,normalizationField:r,normalizationType:s,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:h})}_sortFeatures(e,t,i){if(e.length>1&&(t!=null&&t.length))for(const r of t.slice().reverse()){const s=r.split(" "),a=s[0],l=this.fieldsIndex.get(a),o=!!s[1]&&s[1].toLowerCase()==="desc",u=As(l==null?void 0:l.type,o);e.sort(((c,h)=>{const d=i(c,a,l),m=i(h,a,l);return u(d,m)}))}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:r,hasZ:s,objectIdField:a,spatialReference:l}=this,{outFields:o,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:d,returnZ:m,returnM:f}=e,p=h!=null&&t.length>(d||0)+h,T=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map((I=>this.fieldsIndex.get(I))));return{exceededTransferLimit:p,features:this._createFeatures(e,t),fields:T,geometryType:i,hasM:r&&f,hasZ:s&&m,objectIdFieldName:a,spatialReference:ne(u||l),transform:c&&Ze(c)||null}}_createFeatures(e,t){var F,b,x,_;const i=new ee(e,this.featureAdapter,this.fieldsIndex),{hasM:r,hasZ:s}=this,{orderByFields:a,quantizationParameters:l,returnGeometry:o,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:d,returnZ:m=!1,returnM:f=!1}=e,p=s&&m,T=r&&f;let I=[],w=0;const A=[...t];if(this._sortFeatures(A,a,((g,S,E)=>i.getFieldValue(g,S,E))),this.geometryType&&(o||u)){const g=Ze(l)??void 0,S=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(o&&!u)for(const E of A){const O=this.featureAdapter.getGeometry(E),D={attributes:i.getAttributes(E),geometry:G(this.geometryType,this.hasZ,this.hasM,O,c,g,p,T),metadata:(b=(F=this.featureAdapter).getMetadata)==null?void 0:b.call(F,E)};S&&O&&!D.geometry&&(D.centroid=xe(this,this.featureAdapter.getCentroid(E,this),g)),I[w++]=D}else if(!o&&u)for(const E of A)I[w++]={attributes:i.getAttributes(E),centroid:xe(this,this.featureAdapter.getCentroid(E,this),g)};else for(const E of A)I[w++]={attributes:i.getAttributes(E),centroid:xe(this,this.featureAdapter.getCentroid(E,this),g),geometry:G(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(E),c,g,p,T),metadata:(_=(x=this.featureAdapter).getMetadata)==null?void 0:_.call(x,E)}}else for(const g of A){const S=i.getAttributes(g);S&&(I[w++]={attributes:S})}const R=h||0;if(d!=null){const g=R+d;I=I.slice(R,Math.min(I.length,g))}return I}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const s of this.query.outStatistics??[])if(s.statisticType==="exceedslimit"){t=s.maxPointCount!=null?s.maxPointCount:Number.POSITIVE_INFINITY,i=s.maxRecordCount!=null?s.maxRecordCount:Number.POSITIVE_INFINITY,r=s.maxVertexCount!=null?s.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{const s=et(this.hasZ,this.hasM),a=this.featureAdapter;e=this.items.reduce(((l,o)=>{const u=a.getGeometry(o);return l+(u!=null&&u.coords.length||0)}),0)/s>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){var R;const r=[],s=new Map,a=new Map,l=new Map,o=new Map,u=new ee(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:h,having:d,orderByFields:m,resultRecordCount:f}=e,p=h==null?void 0:h.length,T=!!p,I=T?h[0]:null,w=T&&!this.fieldsIndex.get(I);for(const F of c??[]){const{outStatisticFieldName:b,statisticType:x}=F,_=F,g=x!=="exceedslimit"?F.onStatisticField:void 0,S=x==="percentile_disc"||x==="percentile_cont",E=x==="EnvelopeAggregate"||x==="CentroidAggregate"||x==="ConvexHullAggregate",O=T&&p===1&&(g===I||w)&&x==="count";if(T){if(!l.has(g)){const ue=[];for(const ge of h){const ce=this._getAttributeValues(u,ge,t,s);ue.push(ce)}l.set(g,this._calculateUniqueValues(ue,t,!E&&u.returnDistinctValues))}const N=l.get(g);if(!N)continue;const Y=Object.keys(N);for(const ue of Y){const{count:ge,data:ce,items:Le,itemPositions:Ft}=N[ue],Me=ce.join(",");if(!d||u.validateItems(Le,d)){const W=o.get(Me)||{attributes:{}};if(E){W.aggregateGeometries||(W.aggregateGeometries={});const{aggregateGeometries:k,outStatisticFieldName:K}=await this._getAggregateGeometry(_,Le);W.aggregateGeometries[K]=k}else{let k=null;if(O)k=ge;else{const K=this._getAttributeValues(u,g,t,s),Ge=Ft.map((wt=>K[wt]));k=S&&"statisticParameters"in _?this._getPercentileValue(_,Ge):this._getStatisticValue(_,Ge,null,u.returnDistinctValues)}W.attributes[b]=k}let St=0;h.forEach(((k,K)=>W.attributes[this.fieldsIndex.get(k)?k:"EXPR_"+ ++St]=ce[K])),o.set(Me,W)}}}else if(E){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:N,outStatisticFieldName:Y}=await this._getAggregateGeometry(_,t);i.aggregateGeometries[Y]=N}else{const N=this._getAttributeValues(u,g,t,s);i.attributes[b]=S&&"statisticParameters"in _?this._getPercentileValue(_,N):this._getStatisticValue(_,N,a,u.returnDistinctValues)}const D=x!=="min"&&x!=="max"||!_e(this.fieldsIndex.get(g))&&!this._isAnyDateField(g)?null:(R=this.fieldsIndex.get(g))==null?void 0:R.type;r.push({name:b,alias:b,type:D||"esriFieldTypeDouble"})}const A=T?Array.from(o.values()):[i];return this._sortFeatures(A,m,((F,b)=>F.attributes[b])),f&&(A.length=Math.min(f,A.length)),{fields:r,features:A}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return Ue(t)||Se(t)||we(t)||te(t)}async _getAggregateGeometry(e,t){const{convexHull:i,union:r}=await U(()=>import("./geometryEngineJSON-DGETChXf.js").then(p=>p.g),__vite__mapDeps([0,1,2,3,4]),import.meta.url),{statisticType:s,outStatisticFieldName:a}=e,{featureAdapter:l,spatialReference:o,geometryType:u,hasZ:c,hasM:h}=this,d=t.map((p=>G(u,c,h,l.getGeometry(p)))),m=i(o,d,!0)[0],f={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const p=m?bt(m):Qe(r(o,d));f.aggregateGeometries={...p,spatialReference:o},f.outStatisticFieldName=a||"extent"}else if(s==="CentroidAggregate"){const p=m?At(m):vt(Qe(r(o,d)));f.aggregateGeometries={x:p[0],y:p[1],spatialReference:o},f.outStatisticFieldName=a||"centroid"}else s==="ConvexHullAggregate"&&(f.aggregateGeometries=m,f.outStatisticFieldName=a||"convexHull");return f}_getStatisticValue(e,t,i,r){const{onStatisticField:s,statisticType:a}=e;let l=null;return l=i!=null&&i.has(s)?i.get(s):_e(this.fieldsIndex.get(s))||this._isAnyDateField(s)?He({values:t,returnDistinct:r}):Ye({values:r?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(s,l),l[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:r,statisticType:s}=e,{value:a,orderBy:l}=r,o=this.fieldsIndex.get(i);return vs(t,{value:a,orderBy:l,fieldType:o==null?void 0:o.type,isDiscrete:s==="percentile_disc"})}_getAttributeValues(e,t,i,r){if(r.has(t))return r.get(t);const s=this.fieldsIndex.get(t),a=i.map((l=>e.getFieldValue(l,t,s)));return r.set(t,a),a}_calculateUniqueValues(e,t,i){const r={},s=t.length;for(let a=0;a<s;a++){const l=t[a],o=[];for(const c of e)o.push(c[a]);const u=o.join(",");r[u]==null?r[u]={count:1,data:o,items:[l],itemPositions:[a]}:(i||r[u].count++,r[u].items.push(l),r[u].itemPositions.push(a))}return r}async _getDataValues(e,t,i=!0){const r=new ee(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,scale:a,timeZone:l}=e;return s?r.getExpressionValues(t,s,{viewingMode:"map",scale:a,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},l):r.getDataValues(t,fe(e),i)}async _calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];const r=t.intervals,s=t.min??0,a=t.max??0,l=r.map((([o,u])=>({minValue:o,maxValue:u,count:0,items:[]})));for(let o=0;o<e.length;o++){const u=e[o],c=i[o];if(u!=null&&u>=s&&u<=a){const h=Ns(r,u);h>-1&&(l[h].count++,l[h].items.push(c))}}return l}async createQueryBinsResponse(e){var m;const t=(m=e.bin)==null?void 0:m.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:r,valueType:s}=t,a=[],l=[{name:r??i,alias:r??i,type:s??"esriFieldTypeString"},{name:J,alias:J,type:"esriFieldTypeInteger"}],o=new ee(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],((f,p,T)=>o.getFieldValue(f,p,T)));const h=this._getAttributeValues(o,i,c,u),d=this._calculateUniqueValues([h],c,o.returnDistinctValues);for(const f in d){const{items:p}=d[f],T=await this._createBinsResponse(e,p);if(a.push(...T.features.map((I=>({...I,attributes:{...I.attributes,[r??i]:f}})))),T.fields)for(const I of T.fields)l.some((w=>w.name===I.name))||l.push(I)}return{fields:l,features:a}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(ms.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(fs.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(ds.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(hs.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){var f;const{field:r,normalizationField:s,numBins:a,normalizationType:l,normalizationTotal:o,start:u,end:c}=e,h=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:(f=t.outTimeReference)==null?void 0:f.ianaTimeZone},i),d=We(h,{field:r,normalizationField:s,normalizationType:l,normalizationTotal:o,numBins:a,minValue:z(u,!1),maxValue:z(c,!1)}),m=await this._calculateHistogramBins(h,d,i);return this._createFeaturesFromHistogramBins(m,t)}async _createDateBinsResponse(e,t,i){var b,x;const{field:r,interval:s,start:a,end:l,snapToData:o,returnFullIntervalBin:u}=e,c=s.unit,h=await this._getDataValues({field:e.field,timeZone:(b=t.outTimeReference)==null?void 0:b.ianaTimeZone},i),d=te(this.fieldsIndex.get(r)),m=ps.toJSON(c),f=h.filter(Boolean).sort(((_,g)=>_-g)),p=a!=null?z(a,d):f[0],T=l!=null?z(l,d):f[f.length-1],I={zone:((x=t.outTimeReference)==null?void 0:x.ianaTimeZone)??Nt},w=he.fromMillis(p,I),A=he.fromMillis(T,I),R=[];if(o==="last"){let _=A;for(;_>w;){const g=_.minus({[m]:s.value});if(g<w){R.unshift([u?g.toMillis():w.toMillis(),_.toMillis()]);break}R.unshift([g.toMillis(),_.toMillis()]),_=g}}else{let _=o==="first"?w:w.startOf(m);for(;_<=A;){const g=_.plus({[m]:s.value});if(g>A){R.push([_.toMillis(),u?g.toMillis():A.toMillis()]);break}R.push([_.toMillis(),g.toMillis()]),_=g}}const F=await this._calculateHistogramBins(h,{intervals:R,min:p,max:T},i);return this._createFeaturesFromHistogramBins(F,t)}async _createFixedBoundariesBinsResponse(e,t,i){var h;const{field:r}=e,s=await this._getDataValues({field:r,timeZone:(h=t.outTimeReference)==null?void 0:h.ianaTimeZone},i),a=te(this.fieldsIndex.get(r)),l=e.boundaries.map((d=>z(d,a))).sort(((d,m)=>d-m)),o=[];for(let d=0;d<l.length-1;d++)o.push([l[d],l[d+1]]);const u={intervals:o,min:l.at(0),max:l.at(-1)},c=await this._calculateHistogramBins(s,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,i){var d;const{field:r,interval:s,start:a,end:l}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:(d=t.outTimeReference)==null?void 0:d.ianaTimeZone},i),u=te(this.fieldsIndex.get(r)),c=We(o,{field:r,classificationMethod:"defined-interval",definedInterval:s,minValue:z(a,u),maxValue:z(l,u)},!0),h=await this._calculateHistogramBins(o,c,i);return this._createFeaturesFromHistogramBins(h,t)}async _createFeaturesFromHistogramBins(e,t){var f,p,T,I,w,A;const{upperBoundaryAlias:i,lowerBoundaryAlias:r}=t,s=r||"lowerBoundary",a=i||"upperBoundary",l=[],o=[{name:s,alias:s,type:"esriFieldTypeDouble"},{name:a,alias:a,type:"esriFieldTypeDouble"}],u=(p=(f=t.bin)==null?void 0:f.stackBy)==null?void 0:p.value,c=(I=(T=t.bin)==null?void 0:T.stackBy)==null?void 0:I.outAlias;u&&o.push({name:J,alias:J,type:"esriFieldTypeInteger"},{name:c??u,alias:c??u,type:"esriFieldTypeString"});let h=0;const d=t.bin.type==="dateBin",m=(w=t.outTimeReference)==null?void 0:w.ianaTimeZone;for(const R of e){const{minValue:F,maxValue:b,items:x}=R,_={attributes:{}};let g;if(_.attributes[s]=d&&m&&F!=null?he.fromMillis(F,{zone:m}).toISO():F,_.attributes[a]=d&&m&&b!=null?he.fromMillis(b,{zone:m}).toISO():b,u?(g=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[u],orderByFields:[u]},x),_.attributes[J]=++h,t.bin.jsonStyle==="flat"?l.push(...g.features.map((({attributes:{EXPR_1:S,...E},...O})=>({...O,attributes:c??S?{...E,[c??S]:S,..._.attributes}:{...E,..._.attributes}})))):(_.stackedAttributes=g.features.map((({attributes:{EXPR_1:S,...E}})=>c??S?{...E,[c??S]:S}:E)),l.push(_))):((A=t.bin)!=null&&A.splitBy&&(_.attributes[J]=++h),g=await this._createStatisticsQueryResponse(t,x,_),l.push(_)),g.fields)for(const S of g.fields)o.some((E=>E.name===S.name))||o.push(S)}return t.binOrder==="desc"&&l.reverse(),{fields:o,features:l}}};function Bs(n,e,t,i){const r=i.x-t.x,s=i.y-t.y,a=e.x-t.x,l=e.y-t.y,o=r*r+s*s;if(o===0)return!1;const u=a*r+l*s,c=Math.min(1,Math.max(0,u/o));return n.x=t.x+r*c,n.y=t.y+s*c,!0}function et(n,e){return n?e?4:3:e?3:2}let tt=class{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}};const zs=[1];function qs(n){return n==="mesh"?Pt:Ot(n)}function _t(n,e){return n?e?4:3:e?3:2}function js(n,e,t,i){return yt(n,e,t,i.coords[0],i.coords[1])}function Zs(n,e,t,i,r,s){const a=_t(r,s),{coords:l,lengths:o}=i;if(!o)return!1;for(let u=0,c=0;u<o.length;u++,c+=a)if(!yt(n,e,t,l[c],l[c+1]))return!1;return!0}function yt(n,e,t,i,r){if(!n)return!1;const s=_t(e,t),{coords:a,lengths:l}=n;let o=!1,u=0;for(const c of l)o=Hs(o,a,s,u,c,i,r),u+=c*s;return o}function Hs(n,e,t,i,r,s,a){let l=n,o=i;for(let u=i,c=i+r*t;u<c;u+=t){o=u+t,o===c&&(o=i);const h=e[u],d=e[u+1],m=e[o],f=e[o+1];(d<a&&f>=a||f<a&&d>=a)&&h+(a-d)/(f-d)*(m-h)<s&&(l=!l)}return l}const Fe="unsupported-query",Ve={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!1,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Ys(n){return n!=null&&Ve.spatialRelationship[n]===!0}function Ws(n){return n!=null&&Ve.queryGeometry[Dt(n)]===!0}function Js(n){return n!=null&&Ve.layerGeometry[n]===!0}const Xs={esriSpatialRelIntersects:()=>U(()=>import("./intersectsOperator-BabvpyGm.js"),__vite__mapDeps([5,6,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelContains:()=>U(()=>import("./containsOperator-GnkxENvA.js"),__vite__mapDeps([16,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelCrosses:()=>U(()=>import("./crossesOperator-CfnLjjrK.js"),__vite__mapDeps([17,18,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelDisjoint:()=>U(()=>import("./disjointOperator-gw19WMTJ.js"),__vite__mapDeps([19,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelEnvelopeIntersects:null,esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:()=>U(()=>import("./overlapsOperator-UpXXdD7X.js"),__vite__mapDeps([20,21,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelTouches:()=>U(()=>import("./touchesOperator-yqpWpb2O.js"),__vite__mapDeps([22,23,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelWithin:()=>U(()=>import("./withinOperator-BLzZu6IJ.js"),__vite__mapDeps([24,25,7,8,9,10,11,12,13,14,15]),import.meta.url),esriSpatialRelRelation:null};function Ks(n){const e=Xs[n];if(e==null)throw new Error(`Cannot load unsupported spatial operator: ${n}`);return e()}async function de(n,e,t,i,r){if(Oe(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const a=qe(new le,e,!1,!1);return l=>js(a,!1,!1,l)}if(t==="esriGeometryMultipoint"){const a=qe(new le,e,!1,!1);if(n==="esriSpatialRelContains")return l=>Zs(a,!1,!1,l,i,r)}}if(Ce(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return a=>Ct(e,G(t,i,r,a));if(t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return a=>$t(e,G(t,i,r,a));if(n==="esriSpatialRelIntersects"){const a=qs(t);return l=>a(e,G(t,i,r,l))}}n==="esriSpatialRelEnvelopeIntersects"&&(n="esriSpatialRelIntersects");const s=await Ks(n);return a=>s.execute(e,G(t,i,r,a))}async function Tt(n,e,t){var s;const{spatialRel:i,geometry:r}=n;if(r){if(!Ys(i))throw new v(Fe,"Unsupported query spatial relationship",{query:n});if(X(r.spatialReference)&&X(t)){if(!Ws(r))throw new v(Fe,"Unsupported query geometry type",{query:n});if(!Js(e))throw new v(Fe,"Unsupported layer geometry type",{query:n});if(n.outSR)return $e((s=n.geometry)==null?void 0:s.spatialReference,n.outSR)}}}function It(n){if(Ce(n))return!0;if(Oe(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}const H="unsupported-query";async function ei(n,e){var i;const t=n.bin;if(!t.onField&&!((i=t.onExpression)!=null&&i.value)||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new v(H,"Unsupported query options",{query:n});return Et(n,e)}async function Et(n,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:r}){if(n.geometryPrecision!=null||n.multipatchOption&&n.multipatchOption!=="xyFootprint"||n.pixelSize||n.relationParam||n.text)throw new v(H,"Unsupported query options",{query:n});return Rt(e,r,n),si(e,r,n),Promise.all([Tt(n,t,i),$e(i,n.outSR)]).then((()=>n))}function Rt(n,e,t){var a;const{returnDistinctValues:i,outStatistics:r}=t,s=r?r.map((l=>l.outStatisticFieldName&&l.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const l=" asc",o=" desc",u=t.orderByFields.map((c=>{const h=c.toLowerCase();return h.includes(l)?h.split(l)[0]:h.includes(o)?h.split(o)[0]:c})).filter((c=>!s.includes(c)));B(n,e,u,{expressionName:"orderByFields",query:t})}if("outFields"in t){if((a=t.outFields)!=null&&a.length)B(n,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new v(H,"outFields should be specified for returnDistinctValues",{query:t})}Os(n,e,t.where,t)}const ti=new Set([...ft,...mt]);function si(n,e,t){const{outStatistics:i,groupByFieldsForStatistics:r,having:s}=t,a=r==null?void 0:r.length,l=i==null?void 0:i.length;if(s){if(!a||!l)throw new v(H,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});Cs(n,e,s,i,t)}if(l){if(!ai(i))return;const o=i.map((u=>u.onStatisticField)).filter(Boolean);B(n,e,o,{expressionName:"onStatisticFields",query:t}),a&&B(n,e,r,{expressionName:"groupByFieldsForStatistics",query:t});for(const u of i){const{onStatisticField:c,statisticType:h}=u;if((h==="percentile_disc"||h==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:d}=u;if(!d)throw new v(H,"statisticParameters should be set for percentile type",{definition:u,query:t})}else n.get(c)&&h!=="count"&&h!=="min"&&h!=="max"&&B(n,e,[c],{expressionName:`outStatistics with '${h}' statistic type`,allowedFieldTypes:ti,query:t})}}}async function ii(n,e,{fieldsIndex:t,geometryType:i,spatialReference:r,availableFields:s}){if(n.geometryPrecision!=null||n.multipatchOption||n.pixelSize||n.relationParam||n.text||n.outStatistics||n.groupByFieldsForStatistics||n.having||n.orderByFields)throw new v(H,"Unsupported query options",{query:n});return Rt(t,s,n),Promise.all([ri(t,s,e,n),Tt(n,i,r),$e(r,n.outSR)]).then((()=>n))}async function ri(n,e,t,i){let r=[];if(t.valueExpression){const{arcadeUtils:s}=await ut();r=s.extractFieldNames(t.valueExpression)}if(t.field&&r.push(t.field),t.field2&&r.push(t.field2),t.field3&&r.push(t.field3),t.normalizationField&&r.push(t.normalizationField),!r.length&&!t.valueExpression)throw new v(H,"field or valueExpression is required",{params:t});B(n,e,r,{expressionName:"statistics",query:i})}function ai(n){return n!=null&&n.every((e=>e.statisticType!=="exceedslimit"))}async function ni(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:r}=n;let s=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(i&&r)await e.forEach((l=>{const o=t.getAttribute(ie(l),i),u=t.getAttribute(ie(l),r);o==null||isNaN(o)||(s=Math.min(s,o)),u==null||isNaN(u)||(a=Math.max(a,u))}));else{const l=i||r;await e.forEach((o=>{const u=t.getAttribute(ie(o),l);u==null||isNaN(u)||(s=Math.min(s,u),a=Math.max(a,u))}))}return{start:s,end:a}}function li(n,e,t){var o;if(!e||!n)return null;const{startTimeField:i,endTimeField:r}=n;if(!i&&!r)return null;const{start:s,end:a}=e;if(s===null&&a===null)return null;if(s===void 0&&a===void 0)return ci();const l=((o=t.getAttributeAsTimestamp)==null?void 0:o.bind(t))??t.getAttribute.bind(t);return i&&r?oi(l,i,r,s,a):ui(l,i||r,s,a)}function oi(n,e,t,i,r){return i!=null&&r!=null?s=>{const a=n(s,e),l=n(s,t);return(a==null||a<=r)&&(l==null||l>=i)}:i!=null?s=>{const a=n(s,t);return a==null||a>=i}:r!=null?s=>{const a=n(s,e);return a==null||a<=r}:void 0}function ui(n,e,t,i){return t!=null&&i!=null&&t===i?r=>n(r,e)===t:t!=null&&i!=null?r=>{const s=n(r,e);return s!=null&&s>=t&&s<=i}:t!=null?r=>{const s=n(r,e);return s!=null&&s>=t}:i!=null?r=>{const s=n(r,e);return s!=null&&s<=i}:void 0}function ci(){return()=>!1}const xt=Symbol("Yield");class hi{constructor(){this._tasks=new Array,this._numPendingTasks=pe(0),this._running=pe(!1)}get length(){return this._tasks.length}get updating(){return this._numPendingTasks.value>0}get running(){return this._running.value}_updateRunning(){this._running.value=this._tasks.length>0}destroy(){this.cancelAll()}runTask(e){if(this.length===0)return xt;for(;!e.done&&this._process(e);)e.madeProgress()}push(e,t,i){return new Promise(((r,s)=>{this._tasks.push(new st(r,s,e,t,i)),++this._numPendingTasks.value,this._updateRunning()})).finally((()=>--this._numPendingTasks.value))}unshift(e,t,i){return new Promise(((r,s)=>{this._tasks.unshift(new st(r,s,e,t,i)),++this._numPendingTasks.value,this._updateRunning()})).finally((()=>--this._numPendingTasks.value))}_process(e){var i;if(this._tasks.length===0)return!1;const t=this._tasks.shift();this._updateRunning();try{const r=ct(t.signal);if(r&&!t.abortCallback)t.reject(me());else{const s=r?(i=t.abortCallback)==null?void 0:i.call(t,me()):t.callback(e);Vt(s)?s.then(t.resolve,t.reject):t.resolve(s)}}catch(r){t.reject(r)}return!0}cancelAll(){const e=me();for(const t of this._tasks)if(t.abortCallback){const i=t.abortCallback(e);t.resolve(i)}else t.reject(e);this._tasks.length=0,this._updateRunning()}}class st{constructor(e,t,i,r=void 0,s=void 0){this.resolve=e,this.reject=t,this.callback=i,this.signal=r,this.abortCallback=s}}let se=class extends Mt{constructor(){super(...arguments),this.SCHEDULER_LOG_SLOW_TASKS=!1,this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES=!1}};ye([Be()],se.prototype,"SCHEDULER_LOG_SLOW_TASKS",void 0),ye([Be()],se.prototype,"FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES",void 0),se=ye([Lt("esri.views.support.debugFlags")],se);const di=new se;var C;(function(n){n[n.ANIMATING=0]="ANIMATING",n[n.INTERACTING=1]="INTERACTING",n[n.IDLE=2]="IDLE"})(C||(C={}));var y;(function(n){n.RESOURCE_CONTROLLER_IMMEDIATE="immediate",n.RESOURCE_CONTROLLER="schedule",n.SLIDE="slide",n.STREAM_DATA_LOADER="stream loader",n.ELEVATION_QUERY="elevation query",n.TERRAIN_SURFACE="terrain",n.SURFACE_GEOMETRY_UPDATES="surface geometry updates",n.LOD_RENDERER="LoD renderer",n.GRAPHICS_CORE="Graphics3D",n.I3S_CONTROLLER="I3S",n.POINT_CLOUD_LAYER="point cloud",n.FEATURE_TILE_FETCHER="feature fetcher",n.OVERLAY="overlay",n.OVERLAY_RENDERER="overlay renderer",n.STAGE="stage",n.GRAPHICS_DECONFLICTOR="graphics deconflictor",n.FILTER_VISIBILITY="Graphics3D filter visibility",n.SCALE_VISIBILITY="Graphics3D scale visibility",n.FRUSTUM_VISIBILITY="Graphics3D frustum visibility",n.POINT_OF_INTEREST_FREQUENT="POI frequent",n.POINT_OF_INTEREST_INFREQUENT="POI infrequent",n.LABELER="labeler",n.FEATURE_QUERY_ENGINE="feature query",n.FEATURE_TILE_TREE="feature tile tree",n.FEATURE_TILE_TREE_ACTIVE="fast feature tile tree",n.ELEVATION_ALIGNMENT="elevation alignment",n.ELEVATION_ALIGNMENT_SCENE="elevation alignment scene",n.TEXT_TEXTURE_ATLAS="text texture atlas",n.TEXTURE_UNLOAD="texture unload",n.LINE_OF_SIGHT_TOOL="line of sight tool",n.LINE_OF_SIGHT_TOOL_INTERACTIVE="interactive line of sight tool",n.ELEVATION_PROFILE="elevation profile",n.SNAPPING="snapping",n.SHADOW_ACCUMULATOR="shadow accumulator",n.CLOUDS_GENERATOR="clouds generator",n.MAPVIEW_FETCH_QUEUE="mapview fetch queue",n.MAPVIEW_LAYERVIEW_UPDATE="mapview layerview update",n.MAPVIEW_VECTOR_TILE_PARSING_QUEUE="mapview vector tile parsing queue",n[n.NONE=0]="NONE",n[n.TEST_PRIO=1]="TEST_PRIO"})(y||(y={}));const $=0,it=new Map([[y.RESOURCE_CONTROLLER_IMMEDIATE,$],[y.RESOURCE_CONTROLLER,4],[y.SLIDE,$],[y.STREAM_DATA_LOADER,$],[y.ELEVATION_QUERY,$],[y.TERRAIN_SURFACE,1],[y.SURFACE_GEOMETRY_UPDATES,1],[y.LOD_RENDERER,2],[y.GRAPHICS_CORE,2],[y.I3S_CONTROLLER,2],[y.POINT_CLOUD_LAYER,2],[y.FEATURE_TILE_FETCHER,2],[y.CLOUDS_GENERATOR,2],[y.OVERLAY,4],[y.OVERLAY_RENDERER,4],[y.STAGE,4],[y.GRAPHICS_DECONFLICTOR,4],[y.FILTER_VISIBILITY,4],[y.SCALE_VISIBILITY,4],[y.FRUSTUM_VISIBILITY,4],[y.POINT_OF_INTEREST_FREQUENT,6],[y.POINT_OF_INTEREST_INFREQUENT,30],[y.LABELER,8],[y.FEATURE_QUERY_ENGINE,8],[y.FEATURE_TILE_TREE,16],[y.FEATURE_TILE_TREE_ACTIVE,$],[y.ELEVATION_ALIGNMENT,12],[y.ELEVATION_ALIGNMENT_SCENE,14],[y.TEXT_TEXTURE_ATLAS,12],[y.TEXTURE_UNLOAD,12],[y.LINE_OF_SIGHT_TOOL,16],[y.LINE_OF_SIGHT_TOOL_INTERACTIVE,$],[y.SNAPPING,$],[y.SHADOW_ACCUMULATOR,30],[y.MAPVIEW_FETCH_QUEUE,$],[y.MAPVIEW_LAYERVIEW_UPDATE,2],[y.MAPVIEW_VECTOR_TILE_PARSING_QUEUE,$]]);function rt(n){return it.has(n)?it.get(n):typeof n=="number"?n:1}const fi=L(6.5),at=L(1),mi=L(30),pi=L(1e3/30),gi=L(100),nt=.9;var Pe,j;(function(n){class e{get updating(){return this._updating.value}_updatingChanged(){this._updating.value=this._tasks.some((s=>s.needsUpdate))}constructor(){this._updating=pe(!0),this._microTaskQueued=!1,this._frameNumber=0,this.performanceInfo={total:new Te("total"),tasks:new Map},this._frameTaskTimes=new Map,this._budget=new i,this._state=C.INTERACTING,this._tasks=new Ie,this._runQueue=new Ie,this._load=0,this._idleStateCallbacks=new Ie,this._idleUpdatesStartFired=!1,this._forceTask=!1,this._debug=!1,this._debugHandle=Gt((()=>di.SCHEDULER_LOG_SLOW_TASKS),(s=>this._debug=s),kt);for(const s of Object.keys(y))this.performanceInfo.tasks.set(y[s],new Te(y[s]))}destroy(){this._tasks.toArray().forEach((s=>s.remove())),this._tasks.clear(),be(this._debugHandle),this._microTaskQueued=!1,this._updatingChanged()}taskRunningChanged(s){this._updatingChanged(),s&&this._budget.remaining>0&&!this._microTaskQueued&&(this._microTaskQueued=!0,queueMicrotask((()=>{this._microTaskQueued&&(this._microTaskQueued=!1,this._budget.remaining>0&&this._schedule()&&this._runFrame())})))}registerTask(s,a){const l=new t(this,s,a);return this._tasks.push(l),this._updatingChanged(),this.performanceInfo.tasks.has(s)||this.performanceInfo.tasks.set(s,new Te(s)),l}registerIdleStateCallbacks(s,a){const l={idleBegin:s,idleEnd:a};this._idleStateCallbacks.push(l),this.state===C.IDLE&&this._idleUpdatesStartFired&&l.idleBegin();const o=this;return{remove:()=>this._removeIdleStateCallbacks(l),set idleBegin(u){o._idleUpdatesStartFired&&(l.idleEnd(),o._state===C.IDLE&&u()),l.idleBegin=u},set idleEnd(u){l.idleEnd=u}}}get load(){return this._load}set state(s){this._state!==s&&(this._state=s,this.state!==C.IDLE&&this._idleUpdatesStartFired&&(this._idleUpdatesStartFired=!1,this._idleStateCallbacks.forAll((a=>a.idleEnd()))))}get state(){return this._state}frame(s){this._startFrameTaskTimes();const a=this._updateBudget(s);if(a){const l=this._budget.now();this._runFrame(),this._recordFrameTaskTimes(this._budget.now()-l)}else this._recordFrameTaskTimes(0);return a}_updateBudget(s){this._test&&(this._test.usedBudget=0),++this._frameNumber;let a=fi,l=s.frameDuration,o=at;switch(this.state){case C.IDLE:a=L(0),l=L(Math.max(gi,s.frameDuration)),o=mi;break;case C.INTERACTING:l=L(Math.max(pi,s.frameDuration));case C.ANIMATING:}return l=L(l-s.elapsedFrameTime-a),this.state!==C.IDLE&&l<at&&!this._forceTask?(this._forceTask=!0,!1):(l=L(Math.max(l,o)),this._budget.reset(l),this._updateLoad(),this._schedule())}_runFrame(){switch(this._forceTask=!1,this._microTaskQueued=!1,this.state){case C.IDLE:this._idleUpdatesStartFired||(this._idleUpdatesStartFired=!0,this._idleStateCallbacks.forAll((s=>s.idleBegin()))),this._runIdle();break;case C.INTERACTING:this._runInteracting();break;default:this._runAnimating()}this._test&&(this._test.usedBudget=this._budget.elapsed)}stopFrame(){this._budget.reset(L(0)),this._budget.madeProgress()}_removeIdleStateCallbacks(s){this._idleUpdatesStartFired&&s.idleEnd(),this._idleStateCallbacks.removeUnordered(s)}removeTask(s){this._tasks.removeUnordered(s),this._runQueue.removeUnordered(s),this._updatingChanged()}_updateTask(s){this._tasks.forAll((a=>{a.name===s&&a.setPriority(s)}))}_getState(s){if(this._runQueue.some((l=>l.name===s)))return j.SCHEDULED;let a=j.IDLE;return this._tasks.forAll((l=>{l.name===s&&l.needsUpdate&&(l.schedulePriority<=1?a=j.READY:a!==j.READY&&(a=j.WAITING))})),a}_getRuntime(s){let a=0;return this._tasks.forAll((l=>{l.name===s&&(a+=l.runtime)})),a}_resetRuntimes(){this._tasks.forAll((s=>s.runtime=0))}_getRunning(){const s=new Map;if(this._tasks.forAll((l=>{l.needsUpdate&&s.set(l.name,(s.get(l.name)||0)+1)})),s.size===0)return null;let a="";return s.forEach(((l,o)=>{a+=l>1?` ${l}x ${o}`:` ${o}`})),a}_runIdle(){this._run()}_runInteracting(){this._run()}_runAnimating(){this._run()}_updateLoad(){const s=this._tasks.reduce(((a,l)=>l.needsUpdate?++a:a),0);this._load=this._load*nt+s*(1-nt)}_schedule(){for(this._runQueue.filterInPlace((s=>!!s.needsUpdate||(s.schedulePriority=s.basePriority,!1))),this._tasks.forAll((s=>{s.basePriority===$&&s.needsUpdate&&!this._runQueue.includes(s)&&s.blockFrame!==this._frameNumber&&this._runQueue.unshift(s)}));this._runQueue.length===0;){let s=!1,a=0;if(this._tasks.forAll((l=>{l.needsUpdate&&l.schedulePriority!==0&&l.basePriority!==$&&l.blockFrame!==this._frameNumber&&(s=!0,a=Math.max(a,l.basePriority),l.schedulePriority===1?(l.schedulePriority=0,this._runQueue.push(l)):--l.schedulePriority)})),!s)return this._updatingChanged(),!1}return this._updatingChanged(),!0}_run(){do for(;this._runQueue.length>0;){const s=this._budget.now(),a=this._runQueue.pop();this._budget.resetProgress();try{a.task.runTask(this._budget)===xt&&(a.blockFrame=this._frameNumber)}catch(o){Ut.getLogger("esri.views.support.Scheduler").error(`Exception in task "${a.name}"`,o),a.blockFrame=this._frameNumber}!this._budget.hasProgressed&&a.blockFrame!==this._frameNumber&&a.needsUpdate&&(a.name,y.I3S_CONTROLLER,a.blockFrame=this._frameNumber),a.schedulePriority=a.basePriority;const l=this._budget.now()-s;if(a.runtime+=l,this._frameTaskTimes.set(a.priority,this._frameTaskTimes.get(a.priority)+l),this._budget.remaining<=0)return void this._updatingChanged()}while(this._schedule());this._updatingChanged()}_startFrameTaskTimes(){for(const s of Object.keys(y))this._frameTaskTimes.set(y[s],0)}_recordFrameTaskTimes(s){this._frameTaskTimes.forEach(((a,l)=>this.performanceInfo.tasks.get(l).push(a))),this.performanceInfo.total.push(s)}get test(){return this._test}}n.Scheduler=e;class t{get task(){return this._task.value}get updating(){return this._queue.running}constructor(s,a,l){this._scheduler=s,this.name=a,this.blockFrame=0,this.runtime=0,this._queue=new hi,this._handles=new Qt,this._basePriority=rt(a),this.schedulePriority=this._basePriority,this._task=pe(l??this._queue),this._handles.add(Bt((()=>this.task.running),(o=>s.taskRunningChanged(o))))}remove(){this.processQueue(oe),this._scheduler.removeTask(this),this.schedule=lt.schedule,this.reschedule=lt.reschedule,this._handles.destroy()}get basePriority(){return this._basePriority}setPriority(s){if(this.name===s)return;this.name=s;const a=rt(s);this._basePriority!==$&&this.schedulePriority===0||(this.schedulePriority=a),this._basePriority=a}get priority(){return this.name}set priority(s){this.setPriority(s)}get needsUpdate(){return this.updating||this.task.running}schedule(s,a,l){return this._queue.push(s,a,l)}reschedule(s,a,l){return this._queue.unshift(s,a,l)}processQueue(s){return this._queue.runTask(s)}}let i=class{constructor(){this._begin=(performance==null?void 0:performance.now())??0,this._budget=0,this._done=!1,this._progressed=!1,this._enabled=!0}run(s){return!this.done&&(s()===!0&&this.madeProgress(),!0)}get done(){return this._done}get budget(){return this._budget}madeProgress(){return this._progressed=!0,this._done=this.elapsed>=this._budget&&this._enabled,this._done}get enabled(){return this._enabled}set enabled(s){this._enabled=s}reset(s){this._begin=this.now(),this._budget=s,this.resetProgress()}get remaining(){return Math.max(this._budget-this.elapsed,0)}now(){return performance.now()}get elapsed(){return this.now()-this._begin}resetProgress(){this._progressed=!1,this._done=!1}get hasProgressed(){return this._progressed}};n.Budget=i})(Pe||(Pe={})),(function(n){n.SCHEDULED="s",n.READY="r",n.WAITING="w",n.IDLE="i"})(j||(j={}));const oe=new Pe.Budget;oe.enabled=!1;class _i{remove(){}processQueue(){}schedule(e,t,i){try{if(ct(t)){const r=me();return i?Promise.resolve(i(r)):Promise.reject(r)}return zt(e(oe))}catch(r){return Promise.reject(r)}}reschedule(e,t,i){return this.schedule(e,t,i)}}const lt=new _i,yi="unsupported-query";class Vi{constructor(e){this._changeHandle=null,this.capabilities={query:ys},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new Gs,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",(()=>this._clearCache())),this.fieldsIndex=jt(e.fieldsIndex)?e.fieldsIndex:qt.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map((t=>t.name))):this.availableFields=new Set(e.availableFields.map((t=>{var i;return(i=this.fieldsIndex.get(t))==null?void 0:i.name})).filter((t=>t!=null))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._changeHandle=be(this._changeHandle),this._frameTask=be(this._frameTask),this._clearCache(),Zt(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const i=V(t);try{return await(await this._executeQuery(e,{},i)).createQueryResponse()}catch(r){if(r!==q)throw r;return new P([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const i=V(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(r){if(r!==q)throw r;return 0}}async executeQueryForExtent(e,t){const i=V(t),r=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),a=s.size;return a?{count:a,extent:await this._getBounds(s.items,s.spatialReference,r||this.spatialReference)}:{count:0,extent:null}}catch(s){if(s===q)return{count:0,extent:null};throw s}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((i=>Array.from(i)))}async executeQueryForIdSet(e,t){const i=V(t);try{const r=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=r.items,a=new Set;return await this.reschedule((()=>{for(const l of s)a.add(r.featureAdapter.getObjectId(l))}),i),a}catch(r){if(r===q)return new Set;throw r}}async executeQueryForLatestObservations(e,t){var r;const i=V(t);if(!((r=this.timeInfo)!=null&&r.trackIdField))throw new v(yi,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const s=await this._executeQuery(e,{},i);return await this.reschedule((()=>this._filterLatest(s)),i),await s.createQueryResponse()}catch(s){if(s!==q)throw s;return new P([],e,this).createQueryResponse()}}async executeAttributeBinsQuery(e,t){const i=V(t);let r;e=fe(e);try{e=await this.schedule((()=>gs(e,this.definitionExpression,this.spatialReference)),i),e=await this.reschedule((()=>ei(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const s=await this.reschedule((()=>this._executeSceneFilterQuery(e,i)),i);r=await this.reschedule((()=>this._executeGeometryQuery(e,s,i)),i),await this.reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this.reschedule((()=>this.executeObjectIdsQuery(r)),i),await this.reschedule((()=>this.executeTimeQuery(r)),i),await this.reschedule((()=>this.executeAttributesQuery(r)),i)}catch(s){if(s!==q)throw s;r=new P([],e,this)}return r.createQueryBinsResponse(e)}async executeQueryForSummaryStatistics(e={},t,i){const r=V(i),{field:s,normalizationField:a,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:s,normalizationField:a,valueExpression:l},r)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const r=V(i),{field:s,field2:a,field3:l,valueExpression:o}=t;return(await this._executeQueryForStatistics(e,{field:s,field2:a,field3:l,valueExpression:o},r)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const r=V(i),{field:s,normalizationField:a,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:s,normalizationField:a,valueExpression:l},r)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const r=V(i),{field:s,normalizationField:a,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:s,normalizationField:a,valueExpression:l},r)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=V(e);this._timeExtentPromise||(this._timeExtentPromise=ni(this.timeInfo,this.featureStore));const[i,r]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return Ht(t),{fullExtent:i,timeExtent:r}}async _getBounds(e,t,i){const r=Yt(Wt(),ts);await this.featureStore.forEachBounds(e,(l=>Jt(r,l)));const s={xmin:r[0],ymin:r[1],xmax:r[3],ymax:r[4],spatialReference:ne(this.spatialReference)};this.hasZ&&isFinite(r[2])&&isFinite(r[5])&&(s.zmin=r[2],s.zmax=r[5],s.hasZ=!0);const a=re(s,t,i);if(a.spatialReference=ne(i),a.xmax-a.xmin===0){const l=Ee(a.spatialReference);a.xmin-=l,a.xmax+=l}if(a.ymax-a.ymin===0){const l=Ee(a.spatialReference);a.ymin-=l,a.ymax+=l}if(this.hasZ&&a.zmin!=null&&a.zmax!=null&&a.zmax-a.zmin===0){const l=Ee(a.spatialReference);a.zmin-=l,a.zmax+=l}return a}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference)))),this._fullExtentPromise}async schedule(e,t){var i;return((i=this._frameTask)==null?void 0:i.schedule(e,t))??e(oe)}async reschedule(e,t){var i;return((i=this._frameTask)==null?void 0:i.reschedule(e,t))??e(oe)}async _getAllFeaturesQueryEngineResult(e){return new P(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach((r=>i.push(r))))().then((()=>ie(i)))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=fe(e),e=await this.schedule((()=>je(e,this.definitionExpression,this.spatialReference)),i),e=await this.reschedule((()=>Et(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),e={...e,...t};const r=await this.reschedule((()=>this._executeSceneFilterQuery(e,i)),i),s=await this.reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this.reschedule((()=>this._executeAggregateIdsQuery(s)),i),await this.reschedule((()=>this.executeObjectIdsQuery(s)),i),await this.reschedule((()=>this.executeTimeQuery(s)),i),await this.reschedule((()=>this.executeAttributesQuery(s)),i),s}async _executeSceneFilterQuery(e,t){if(e.sceneFilter==null)return null;const{outSR:i,returnGeometry:r,returnCentroid:s}=e,a=this.featureStore.featureSpatialReference,l=e.sceneFilter.geometry,o=a==null||Q(a,l.spatialReference)?l:re(l,a);if(!o)return null;const u=r||s,c=X(i)&&!Q(this.spatialReference,i)&&u?async p=>this._project(p,i):p=>p,h=this.featureAdapter,d=await this.reschedule((()=>this.searchFeatures(ot(o))),t);if(e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const p=new Set;for(const w of d)p.add(h.getObjectId(w));const T=await this.reschedule((()=>this._getAllFeatures()),t),I=await this.reschedule((async()=>{const w=await de("esriSpatialRelDisjoint",o,this.geometryType,this.hasZ,this.hasM),A=F=>!p.has(h.getObjectId(F))||w(h.getGeometry(F)),R=await this.runSpatialFilter(T,A,t);return new P(R,e,this)}),t);return c(I)}if(!d.length)return new P([],e,this);if(this._canExecuteSinglePass(o,e))return c(new P(d,e,this));const m=await de("esriSpatialRelContains",o,this.geometryType,this.hasZ,this.hasM),f=await this.runSpatialFilter(d,(p=>m(h.getGeometry(p))),t);return c(new P(f,e,this))}async _executeGeometryQuery(e,t,i){if(t!=null&&t.items.length===0)return t;const{geometry:r,outSR:s,returnGeometry:a,returnCentroid:l}=e,o=t?null:this._getCacheKey(e),u=o?this._cache.get(o):null;if(u)return new P(u,e,this);const c=X(s)&&!Q(this.spatialReference,s),h=a||l,d=async R=>(c&&h&&await this._project(R,s),o&&this._cache.put(o,R.items),R),m=this.featureStore.featureSpatialReference,f=!r||m==null||Q(m,r.spatialReference)?r:re(r,m);if(!f)return d(t??await this._getAllFeaturesQueryEngineResult(e));const p=this.featureAdapter;let T=await this.reschedule((()=>this.searchFeatures(ot(r))),i);const I=e.spatialRel??"esriSpatialRelIntersects";if(I==="esriSpatialRelDisjoint"){if(!T.length)return d(t??await this._getAllFeaturesQueryEngineResult(e));const R=new Set;for(const x of T)R.add(p.getObjectId(x));const F=t!=null?t.items:await this.reschedule((()=>this._getAllFeatures()),i),b=await this.reschedule((async()=>{const x=await de(I,f,this.geometryType,this.hasZ,this.hasM),_=S=>!R.has(p.getObjectId(S))||x(p.getGeometry(S)),g=await this.runSpatialFilter(F,_,i);return new P(g,e,this)}),i);return d(b)}if(t!=null){const R=new Kt;T=T.filter((F=>Xt(t.items,F,t.items.length,R)>=0))}if(!T.length){const R=new P([],e,this);return o&&this._cache.put(o,R.items),R}if(this._canExecuteSinglePass(f,e))return d(new P(T,e,this));const w=await de(I,f,this.geometryType,this.hasZ,this.hasM),A=await this.runSpatialFilter(T,(R=>w(p.getGeometry(R))),i);return d(new P(A,e,this))}_executeAggregateIdsQuery(e){var r;if(e.items.length===0||!((r=e.query.aggregateIds)!=null&&r.length)||this.aggregateAdapter==null)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach((a=>t.add(a)));const i=this.featureAdapter.getObjectId;e.items=e.items.filter((s=>t.has(i(s))))}executeObjectIdsQuery(e){var r;if(e.items.length===0||!((r=e.query.objectIds)!=null&&r.length))return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((s=>t.has(i(s))))}executeTimeQuery(e){if(e.items.length===0)return;const t=li(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}executeAttributesQuery(e){if(e.items.length===0)return;const t=Z(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((i=>t.testFeature(i,this.featureAdapter)))}}async runSpatialFilter(e,t,i){if(!t)return e;if(this._frameTask==null)return e.filter((l=>t(l)));let r=0;const s=new Array,a=async l=>{for(;r<e.length;){const o=e[r++];t(o)&&(s.push(o),l.madeProgress()),l.done&&await this.reschedule((u=>a(u)),i)}};return this.reschedule((l=>a(l)),i).then((()=>s))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:r}=this.timeInfo,s=r||i,a=new Map,l=this.featureAdapter.getAttribute;for(const o of e.items){const u=l(o,t),c=l(o,s),h=a.get(u);(!h||c>l(h,s))&&a.set(u,o)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:r,returnCentroid:s,outSR:a,resultType:l,cacheHint:o}=e;if(l!=="tile"&&!o)return null;const u=r||s;return X(a)&&!Q(this.spatialReference,a)&&u?JSON.stringify([t,i,a]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return It(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||Q(this.spatialReference,t))return e;const i=this.featureAdapter;let r;try{const a=await this._getFullExtent();r=es(this.spatialReference,t,a)}catch{}const s=await _s(e.items.map((a=>G(this.geometryType,this.hasZ,this.hasM,i.getGeometry(a)))),this.spatialReference,t,r);return e.items=ie(s.map(((a,l)=>i.cloneWithGeometry(e.items[l],us(a,this.hasZ,this.hasM))))),e}async searchFeatures(e){const t=new Set;await Promise.all(e.map((r=>this.featureStore.forEachInBounds(r,(s=>t.add(s))))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=fe(e);try{e=await this.schedule((()=>je(e,this.definitionExpression,this.spatialReference)),i),e=await this.reschedule((()=>ii(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const r=await this.reschedule((()=>this._executeSceneFilterQuery(e,i)),i),s=await this.reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this.reschedule((()=>this._executeAggregateIdsQuery(s)),i),await this.reschedule((()=>this.executeObjectIdsQuery(s)),i),await this.reschedule((()=>this.executeTimeQuery(s)),i),await this.reschedule((()=>this.executeAttributesQuery(s)),i),s}catch(r){if(r!==q)throw r;return new P([],e,this)}}get test(){}}function ot(n){if(It(n)){if(Ce(n))return[ze(Math.min(n.xmin,n.xmax),Math.min(n.ymin,n.ymax),Math.max(n.xmin,n.xmax),Math.max(n.ymin,n.ymax))];if(Oe(n))return n.rings.map((e=>ze(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[ss(is(),n)]}export{de as I,Vi as L,P as O,ot as V,Et as d,ne as h,li as l};
