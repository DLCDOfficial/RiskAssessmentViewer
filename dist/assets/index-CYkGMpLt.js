const le=["BOOLEAN","INT32","INT64","INT96","FLOAT","DOUBLE","BYTE_ARRAY","FIXED_LEN_BYTE_ARRAY"],S=["PLAIN","GROUP_VAR_INT","PLAIN_DICTIONARY","RLE","BIT_PACKED","DELTA_BINARY_PACKED","DELTA_LENGTH_BYTE_ARRAY","DELTA_BYTE_ARRAY","RLE_DICTIONARY","BYTE_STREAM_SPLIT"],Ve=["REQUIRED","OPTIONAL","REPEATED"],Ge=["UTF8","MAP","MAP_KEY_VALUE","LIST","ENUM","DECIMAL","DATE","TIME_MILLIS","TIME_MICROS","TIMESTAMP_MILLIS","TIMESTAMP_MICROS","UINT_8","UINT_16","UINT_32","UINT_64","INT_8","INT_16","INT_32","INT_64","JSON","BSON","INTERVAL"],ze=["UNCOMPRESSED","SNAPPY","GZIP","LZO","BROTLI","LZ4","ZSTD","LZ4_RAW"],ve=["DATA_PAGE","INDEX_PAGE","DICTIONARY_PAGE","DATA_PAGE_V2"],We=["SPHERICAL","VINCENTY","THOMAS","ANDOYER","KARNEY"];function J(e){const t=Y(e);if(t.type===1)return{type:"Point",coordinates:ee(e,t)};if(t.type===2)return{type:"LineString",coordinates:te(e,t)};if(t.type===3)return{type:"Polygon",coordinates:ae(e,t)};if(t.type===4){const n=[];for(let f=0;f<t.count;f++)n.push(ee(e,Y(e)));return{type:"MultiPoint",coordinates:n}}else if(t.type===5){const n=[];for(let f=0;f<t.count;f++)n.push(te(e,Y(e)));return{type:"MultiLineString",coordinates:n}}else if(t.type===6){const n=[];for(let f=0;f<t.count;f++)n.push(ae(e,Y(e)));return{type:"MultiPolygon",coordinates:n}}else if(t.type===7){const n=[];for(let f=0;f<t.count;f++)n.push(J(e));return{type:"GeometryCollection",geometries:n}}else throw new Error(`Unsupported geometry type: ${t.type}`)}function Y(e){const{view:t}=e,n=t.getUint8(e.offset++)===1,f=t.getUint32(e.offset,n);e.offset+=4;const i=f%1e3,r=Math.floor(f/1e3);let o=0;i>1&&i<=7&&(o=t.getUint32(e.offset,n),e.offset+=4);let s=2;return r&&s++,r===3&&s++,{littleEndian:n,type:i,dim:s,count:o}}function ee(e,t){const n=[];for(let f=0;f<t.dim;f++){const i=e.view.getFloat64(e.offset,t.littleEndian);e.offset+=8,n.push(i)}return n}function te(e,t){const n=[];for(let f=0;f<t.count;f++)n.push(ee(e,t));return n}function ae(e,t){const{view:n}=e,f=[];for(let i=0;i<t.count;i++){const r=n.getUint32(e.offset,t.littleEndian);e.offset+=4,f.push(te(e,{...t,count:r}))}return f}const Re=new TextDecoder,H={timestampFromMilliseconds(e){return new Date(Number(e))},timestampFromMicroseconds(e){return new Date(Number(e/1000n))},timestampFromNanoseconds(e){return new Date(Number(e/1000000n))},dateFromDays(e){return new Date(e*864e5)},stringFromBytes(e){return e&&Re.decode(e)},geometryFromBytes(e){return e&&J({view:new DataView(e.buffer,e.byteOffset,e.byteLength),offset:0})},geographyFromBytes(e){return e&&J({view:new DataView(e.buffer,e.byteOffset,e.byteLength),offset:0})}};function de(e,t,n,f){if(t&&n.endsWith("_DICTIONARY")){let i=e;e instanceof Uint8Array&&!(t instanceof Uint8Array)&&(i=new t.constructor(e.length));for(let r=0;r<e.length;r++)i[r]=t[e[r]];return i}else return Ne(e,f)}function Ne(e,t){const{element:n,parsers:f,utf8:i=!0,schemaPath:r}=t,{type:o,converted_type:s,logical_type:c}=n;if((r==null?void 0:r.some(l=>{var u;return((u=l.element.logical_type)==null?void 0:u.type)==="VARIANT"}))&&o==="BYTE_ARRAY"&&s!=="UTF8"&&(c==null?void 0:c.type)!=="STRING")return e;if(s==="DECIMAL"){const u=10**-(n.scale||0),d=new Array(e.length);for(let w=0;w<d.length;w++)e[w]instanceof Uint8Array?d[w]=Le(e[w])*u:d[w]=Number(e[w])*u;return d}if(!s&&o==="INT96")return Array.from(e).map(l=>f.timestampFromNanoseconds(He(l)));if(s==="DATE")return Array.from(e).map(l=>f.dateFromDays(l));if(s==="TIMESTAMP_MILLIS")return Array.from(e).map(l=>f.timestampFromMilliseconds(l));if(s==="TIMESTAMP_MICROS")return Array.from(e).map(l=>f.timestampFromMicroseconds(l));if(s==="JSON")return e.map(l=>JSON.parse(Re.decode(l)));if(s==="BSON")throw new Error("parquet bson not supported");if(s==="INTERVAL")throw new Error("parquet interval not supported");if((c==null?void 0:c.type)==="GEOMETRY")return e.map(l=>f.geometryFromBytes(l));if((c==null?void 0:c.type)==="GEOGRAPHY")return e.map(l=>f.geographyFromBytes(l));if(s==="UTF8"||(c==null?void 0:c.type)==="STRING"||i&&o==="BYTE_ARRAY")return e.map(l=>f.stringFromBytes(l));if(s==="UINT_64"||(c==null?void 0:c.type)==="INTEGER"&&c.bitWidth===64&&!c.isSigned){if(e instanceof BigInt64Array)return new BigUint64Array(e.buffer,e.byteOffset,e.length);const l=new BigUint64Array(e.length);for(let u=0;u<l.length;u++)l[u]=BigInt(e[u]);return l}if(s==="UINT_32"||(c==null?void 0:c.type)==="INTEGER"&&c.bitWidth===32&&!c.isSigned){if(e instanceof Int32Array)return new Uint32Array(e.buffer,e.byteOffset,e.length);const l=new Uint32Array(e.length);for(let u=0;u<l.length;u++)l[u]=e[u];return l}if((c==null?void 0:c.type)==="FLOAT16")return Array.from(e).map(Oe);if((c==null?void 0:c.type)==="TIMESTAMP"){const{unit:l}=c;let u=f.timestampFromMilliseconds;l==="MICROS"&&(u=f.timestampFromMicroseconds),l==="NANOS"&&(u=f.timestampFromNanoseconds);const d=new Array(e.length);for(let w=0;w<d.length;w++)d[w]=u(e[w]);return d}return e}function Le(e){if(!e.length)return 0;let t=0n;for(const f of e)t=t*256n+BigInt(f);const n=e.length*8;return t>=2n**BigInt(n-1)&&(t-=2n**BigInt(n)),Number(t)}function He(e){const t=(e>>64n)-2440588n,n=e&0xffffffffffffffffn;return t*86400000000000n+n}function Oe(e){if(!e)return;const t=e[1]<<8|e[0],n=t>>15?-1:1,f=t>>10&31,i=t&1023;return f===0?n*2**-14*(i/1024):f===31?i?NaN:n*(1/0):n*2**(f-15)*(1+i/1024)}function Se(e,t,n){const f=e[t],i=[];let r=1;if(f.num_children)for(;i.length<f.num_children;){const o=e[t+r],s=Se(e,t+r,[...n,o.name]);r+=s.count,i.push(s)}return{count:r,element:f,children:i,path:n}}function Be(e,t){let n=Se(e,0,[]);const f=[n];for(const i of t){const r=n.children.find(o=>o.element.name===i);if(!r)throw new Error(`parquet schema element not found: ${t}`);f.push(r),n=r}return f}function Ke(e){const t=[];function n(f){if(f.children.length)for(const i of f.children)n(i);else t.push(f.path.join("."))}return n(e),t}function De(e){let t=0;for(const{element:n}of e)n.repetition_type==="REPEATED"&&t++;return t}function re(e){let t=0;for(const{element:n}of e.slice(1))n.repetition_type!=="REQUIRED"&&t++;return t}function Ze(e){if(!e||e.element.converted_type!=="LIST"||e.children.length>1)return!1;const t=e.children[0];return!(t.children.length>1||t.element.repetition_type!=="REPEATED")}function Qe(e){if(!e||e.element.converted_type!=="MAP"||e.children.length>1)return!1;const t=e.children[0];if(t.children.length!==2||t.element.repetition_type!=="REPEATED")return!1;const n=t.children.find(i=>i.element.name==="key");if((n==null?void 0:n.element.repetition_type)==="REPEATED")return!1;const f=t.children.find(i=>i.element.name==="value");return(f==null?void 0:f.element.repetition_type)!=="REPEATED"}function Ue(e){if(e.length!==2)return!1;const[,t]=e;return!(t.element.repetition_type==="REPEATED"||t.children.length)}const E={STOP:0,TRUE:1,FALSE:2,BYTE:3,I16:4,I32:5,I64:6,DOUBLE:7,BINARY:8,LIST:9,STRUCT:12};function se(e){let t=0;const n={};for(;e.offset<e.view.byteLength;){const[f,i,r]=Pe(e,t);if(t=r,f===E.STOP)break;n[`field_${i}`]=k(e,f)}return n}function k(e,t){switch(t){case E.TRUE:return!0;case E.FALSE:return!1;case E.BYTE:return e.view.getInt8(e.offset++);case E.I16:case E.I32:return xe(e);case E.I64:return ne(e);case E.DOUBLE:{const n=e.view.getFloat64(e.offset,!0);return e.offset+=8,n}case E.BINARY:{const n=B(e),f=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,n);return e.offset+=n,f}case E.LIST:{const n=e.view.getUint8(e.offset++),f=n&15;let i=n>>4;i===15&&(i=B(e));const r=f===E.TRUE||f===E.FALSE,o=new Array(i);for(let s=0;s<i;s++)o[s]=r?k(e,E.BYTE)===1:k(e,f);return o}case E.STRUCT:{const n={};let f=0;for(;;){const[i,r,o]=Pe(e,f);if(f=o,i===E.STOP)break;n[`field_${r}`]=k(e,i)}return n}default:throw new Error(`thrift unhandled type: ${t}`)}}function B(e){let t=0,n=0;for(;;){const f=e.view.getUint8(e.offset++);if(t|=(f&127)<<n,!(f&128))return t;n+=7}}function Xe(e){let t=0n,n=0n;for(;;){const f=e.view.getUint8(e.offset++);if(t|=BigInt(f&127)<<n,!(f&128))return t;n+=7n}}function xe(e){const t=B(e);return t>>>1^-(t&1)}function ne(e){const t=Xe(e);return t>>1n^-(t&1n)}function Pe(e,t){const n=e.view.getUint8(e.offset++),f=n&15;if(f===E.STOP)return[0,0,t];const i=n>>4,r=i?t+i:xe(e);return[f,r,r]}function Je(e,t){var r,o,s,c,a;const n=new Map,f=(r=t==null?void 0:t.find(({key:l})=>l==="geo"))==null?void 0:r.value,i=(f&&((o=JSON.parse(f))==null?void 0:o.columns))??{};for(const[l,u]of Object.entries(i)){if(u.encoding!=="WKB")continue;const d=u.edges==="spherical"?"GEOGRAPHY":"GEOMETRY",w=((s=u.crs)==null?void 0:s.id)??((a=(c=u.crs)==null?void 0:c.ids)==null?void 0:a[0]),h=w?`${w.authority}:${w.code.toString()}`:void 0;n.set(l,{type:d,crs:h})}for(let l=1;l<e.length;l++){const u=e[l],{logical_type:d,name:w,num_children:h,repetition_type:A,type:g}=u;if(h){l+=h;continue}g==="BYTE_ARRAY"&&d===void 0&&A!=="REPEATED"&&(u.logical_type=n.get(w))}}const et=1<<19,tt=new TextDecoder;function R(e){return e&&tt.decode(e)}async function K(e,{parsers:t,initialFetchSize:n=et,geoparquet:f=!0}={}){if(!e||!(e.byteLength>=0))throw new Error("parquet expected AsyncBuffer");const i=Math.max(0,e.byteLength-n),r=await e.slice(i,e.byteLength),o=new DataView(r);if(o.getUint32(r.byteLength-4,!0)!==827474256)throw new Error("parquet file invalid (footer != PAR1)");const s=o.getUint32(r.byteLength-8,!0);if(s>e.byteLength-8)throw new Error(`parquet metadata length ${s} exceeds available buffer ${e.byteLength-8}`);if(s+8>n){const c=e.byteLength-s-8,a=await e.slice(c,i),l=new ArrayBuffer(s+8),u=new Uint8Array(l);return u.set(new Uint8Array(a)),u.set(new Uint8Array(r),i-c),_e(l,{parsers:t,geoparquet:f})}else return _e(r,{parsers:t,geoparquet:f})}function _e(e,{parsers:t,geoparquet:n=!0}={}){var g;if(!(e instanceof ArrayBuffer))throw new Error("parquet expected ArrayBuffer");const f=new DataView(e);if(t={...H,...t},f.byteLength<8)throw new Error("parquet file is too short");if(f.getUint32(f.byteLength-4,!0)!==827474256)throw new Error("parquet file invalid (footer != PAR1)");const i=f.byteLength-8,r=f.getUint32(i,!0);if(r>f.byteLength-8)throw new Error(`parquet metadata length ${r} exceeds available buffer ${f.byteLength-8}`);const o=i-r,c=se({view:f,offset:o}),a=c.field_1,l=c.field_2.map(_=>({type:le[_.field_1],type_length:_.field_2,repetition_type:Ve[_.field_3],name:R(_.field_4),num_children:_.field_5,converted_type:Ge[_.field_6],scale:_.field_7,precision:_.field_8,field_id:_.field_9,logical_type:nt(_.field_10)})),u=l.filter(_=>_.type),d=c.field_3,w=c.field_4.map(_=>{var y;return{columns:_.field_1.map((m,p)=>{var I,v,O;return{file_path:R(m.field_1),file_offset:m.field_2,meta_data:m.field_3&&{type:le[m.field_3.field_1],encodings:(I=m.field_3.field_2)==null?void 0:I.map(b=>S[b]),path_in_schema:m.field_3.field_3.map(R),codec:ze[m.field_3.field_4],num_values:m.field_3.field_5,total_uncompressed_size:m.field_3.field_6,total_compressed_size:m.field_3.field_7,key_value_metadata:(v=m.field_3.field_8)==null?void 0:v.map(b=>({key:R(b.field_1),value:R(b.field_2)})),data_page_offset:m.field_3.field_9,index_page_offset:m.field_3.field_10,dictionary_page_offset:m.field_3.field_11,statistics:ft(m.field_3.field_12,u[p],t),encoding_stats:(O=m.field_3.field_13)==null?void 0:O.map(b=>({page_type:ve[b.field_1],encoding:S[b.field_2],count:b.field_3})),bloom_filter_offset:m.field_3.field_14,bloom_filter_length:m.field_3.field_15,size_statistics:m.field_3.field_16&&{unencoded_byte_array_data_bytes:m.field_3.field_16.field_1,repetition_level_histogram:m.field_3.field_16.field_2,definition_level_histogram:m.field_3.field_16.field_3},geospatial_statistics:m.field_3.field_17&&{bbox:m.field_3.field_17.field_1&&{xmin:m.field_3.field_17.field_1.field_1,xmax:m.field_3.field_17.field_1.field_2,ymin:m.field_3.field_17.field_1.field_3,ymax:m.field_3.field_17.field_1.field_4,zmin:m.field_3.field_17.field_1.field_5,zmax:m.field_3.field_17.field_1.field_6,mmin:m.field_3.field_17.field_1.field_7,mmax:m.field_3.field_17.field_1.field_8},geospatial_types:m.field_3.field_17.field_2}},offset_index_offset:m.field_4,offset_index_length:m.field_5,column_index_offset:m.field_6,column_index_length:m.field_7,crypto_metadata:m.field_8,encrypted_column_metadata:m.field_9}}),total_byte_size:_.field_2,num_rows:_.field_3,sorting_columns:(y=_.field_4)==null?void 0:y.map(m=>({column_idx:m.field_1,descending:m.field_2,nulls_first:m.field_3})),file_offset:_.field_5,total_compressed_size:_.field_6,ordinal:_.field_7}}),h=(g=c.field_5)==null?void 0:g.map(_=>({key:R(_.field_1),value:R(_.field_2)})),A=R(c.field_6);return n&&Je(l,h),{version:a,schema:l,num_rows:d,row_groups:w,key_value_metadata:h,created_by:A,metadata_length:r}}function M({schema:e}){return Be(e,[])[0]}function nt(e){return e!=null&&e.field_1?{type:"STRING"}:e!=null&&e.field_2?{type:"MAP"}:e!=null&&e.field_3?{type:"LIST"}:e!=null&&e.field_4?{type:"ENUM"}:e!=null&&e.field_5?{type:"DECIMAL",scale:e.field_5.field_1,precision:e.field_5.field_2}:e!=null&&e.field_6?{type:"DATE"}:e!=null&&e.field_7?{type:"TIME",isAdjustedToUTC:e.field_7.field_1,unit:we(e.field_7.field_2)}:e!=null&&e.field_8?{type:"TIMESTAMP",isAdjustedToUTC:e.field_8.field_1,unit:we(e.field_8.field_2)}:e!=null&&e.field_10?{type:"INTEGER",bitWidth:e.field_10.field_1,isSigned:e.field_10.field_2}:e!=null&&e.field_11?{type:"NULL"}:e!=null&&e.field_12?{type:"JSON"}:e!=null&&e.field_13?{type:"BSON"}:e!=null&&e.field_14?{type:"UUID"}:e!=null&&e.field_15?{type:"FLOAT16"}:e!=null&&e.field_16?{type:"VARIANT",specification_version:e.field_16.field_1}:e!=null&&e.field_17?{type:"GEOMETRY",crs:R(e.field_17.field_1)}:e!=null&&e.field_18?{type:"GEOGRAPHY",crs:R(e.field_18.field_1),algorithm:We[e.field_18.field_2]}:e}function we(e){if(e.field_1)return"MILLIS";if(e.field_2)return"MICROS";if(e.field_3)return"NANOS";throw new Error("parquet time unit required")}function ft(e,t,n){return e&&{max:q(e.field_1,t,n),min:q(e.field_2,t,n),null_count:e.field_3,distinct_count:e.field_4,max_value:q(e.field_5,t,n),min_value:q(e.field_6,t,n),is_max_value_exact:e.field_7,is_min_value_exact:e.field_8}}function q(e,t,n){const{type:f,converted_type:i,logical_type:r}=t;if(e===void 0)return e;if(f==="BOOLEAN")return e[0]===1;if(f==="BYTE_ARRAY")return n.stringFromBytes(e);const o=new DataView(e.buffer,e.byteOffset,e.byteLength);return f==="FLOAT"&&o.byteLength===4?o.getFloat32(0,!0):f==="DOUBLE"&&o.byteLength===8?o.getFloat64(0,!0):f==="INT32"&&i==="DATE"?n.dateFromDays(o.getInt32(0,!0)):f==="INT64"&&i==="TIMESTAMP_MILLIS"?n.timestampFromMilliseconds(o.getBigInt64(0,!0)):f==="INT64"&&i==="TIMESTAMP_MICROS"?n.timestampFromMicroseconds(o.getBigInt64(0,!0)):f==="INT64"&&(r==null?void 0:r.type)==="TIMESTAMP"&&(r==null?void 0:r.unit)==="NANOS"?n.timestampFromNanoseconds(o.getBigInt64(0,!0)):f==="INT64"&&(r==null?void 0:r.type)==="TIMESTAMP"&&(r==null?void 0:r.unit)==="MICROS"?n.timestampFromMicroseconds(o.getBigInt64(0,!0)):f==="INT64"&&(r==null?void 0:r.type)==="TIMESTAMP"?n.timestampFromMilliseconds(o.getBigInt64(0,!0)):f==="INT32"&&o.byteLength===4?o.getInt32(0,!0):f==="INT64"&&o.byteLength===8?o.getBigInt64(0,!0):i==="DECIMAL"?Le(e)*10**-(t.scale||0):(r==null?void 0:r.type)==="FLOAT16"?Oe(e):e}function it(e){const t=se(e);return{page_locations:t.field_1.map(rt),unencoded_byte_array_data_bytes:t.field_2}}function rt(e){return{offset:e.field_1,compressed_page_size:e.field_2,first_row_index:e.field_3}}function Te(e,t){for(let f=0;f<t.length;f+=1e4)e.push(...t.slice(f,f+1e4))}function N(e,t,n=!0){if(n?e===t:e==t)return!0;if(e instanceof Uint8Array&&t instanceof Uint8Array)return N(Array.from(e),Array.from(t),n);if(!e||!t||typeof e!=typeof t)return!1;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!N(e[i],t[i],n))return!1;return!0}if(typeof e!="object")return!1;const f=Object.keys(e);if(f.length!==Object.keys(t).length)return!1;for(const i of f)if(!N(e[i],t[i],n))return!1;return!0}async function he(e,t={},n=globalThis.fetch){const f=new AbortController,i=new Headers(t.headers);i.set("Range","bytes=0-0");const r=await n(e,{...t,headers:i,signal:f.signal});if(!r.ok)throw new Error(`fetch with range failed ${r.status}`);if(r.status===206){const o=r.headers.get("Content-Range");if(!o)throw new Error("missing content-range header");const s=o.match(/bytes \d+-\d+\/(\d+)/);if(!s)throw new Error(`invalid content-range header: ${o}`);return parseInt(s[1])}if(r.status===200){const o=r.headers.get("Content-Length");if(f.abort(),o)return parseInt(o)}throw new Error("server does not support range requests and missing content-length")}async function st(e,t,n){const f=n??globalThis.fetch,i=await f(e,{...t,method:"HEAD"});if(i.status===403)return he(e,t,f);if(!i.ok)throw new Error(`fetch head failed ${i.status}`);const r=i.headers.get("Content-Length");return r?parseInt(r):he(e,t,f)}async function Yt({url:e,byteLength:t,requestInit:n,fetch:f}){if(!e)throw new Error("missing url");const i=f??globalThis.fetch;t??(t=await st(e,n,i));let r;const o=n||{};return{byteLength:t,async slice(s,c){if(r)return r.then(d=>d.slice(s,c));const a=new Headers(o.headers),l=c===void 0?"":c-1;a.set("Range",`bytes=${s}-${l}`);const u=await i(e,{...o,headers:a});if(!u.ok||!u.body)throw new Error(`fetch failed ${u.status}`);if(u.status===200)return r=u.arrayBuffer(),r.then(d=>d.slice(s,c));if(u.status===206)return u.arrayBuffer();throw new Error(`fetch received unexpected status code ${u.status}`)}}}function z(e){if(!e)return[];if(e.length===1)return e[0];const t=[];for(const n of e)Te(t,n);return t}function j(e){if(!e)return[];const t=[];return"$and"in e&&Array.isArray(e.$and)?t.push(...e.$and.flatMap(j)):"$or"in e&&Array.isArray(e.$or)?t.push(...e.$or.flatMap(j)):"$nor"in e&&Array.isArray(e.$nor)?t.push(...e.$nor.flatMap(j)):t.push(...Object.keys(e).map(n=>n.split(".")[0])),[...new Set(t)]}function x(e,t,n=!0){return"$and"in t&&Array.isArray(t.$and)?t.$and.every(f=>x(e,f,n)):"$or"in t&&Array.isArray(t.$or)?t.$or.some(f=>x(e,f,n)):"$nor"in t&&Array.isArray(t.$nor)?!t.$nor.some(f=>x(e,f,n)):Object.entries(t).every(([f,i])=>{const r=ot(e,f);return typeof i!="object"||i===null||Array.isArray(i)?N(r,i,n):Object.entries(i||{}).every(([o,s])=>o==="$gt"?r>s:o==="$gte"?r>=s:o==="$lt"?r<s:o==="$lte"?r<=s:o==="$eq"?N(r,s,n):o==="$ne"?!N(r,s,n):o==="$in"?Array.isArray(s)&&s.includes(r):o==="$nin"?Array.isArray(s)&&!s.includes(r):o==="$not"?!x({[f]:r},{[f]:s},n):!0)})}function fe({rowGroup:e,physicalColumns:t,filter:n,strict:f=!0}){var i;if(!n)return!1;if("$and"in n&&Array.isArray(n.$and))return n.$and.some(r=>fe({rowGroup:e,physicalColumns:t,filter:r,strict:f}));if("$or"in n&&Array.isArray(n.$or))return n.$or.every(r=>fe({rowGroup:e,physicalColumns:t,filter:r,strict:f}));if("$nor"in n&&Array.isArray(n.$nor))return!1;for(const[r,o]of Object.entries(n)){const s=t.indexOf(r);if(s===-1)continue;const c=(i=e.columns[s].meta_data)==null?void 0:i.statistics;if(!c)continue;const{min:a,max:l,min_value:u,max_value:d}=c,w=u!==void 0?u:a,h=d!==void 0?d:l;if(!(w===void 0||h===void 0)){for(const[A,g]of Object.entries(o||{}))if(A==="$gt"&&h<=g||A==="$gte"&&h<g||A==="$lt"&&w>=g||A==="$lte"&&w>g||A==="$eq"&&(g<w||g>h)||A==="$ne"&&N(w,h,f)&&N(w,g,f)||A==="$in"&&Array.isArray(g)&&g.every(_=>_<w||_>h)||A==="$nin"&&Array.isArray(g)&&N(w,h,f)&&g.includes(w))return!0}}return!1}function ot(e,t){let n=e;for(const f of t.split("."))n=n==null?void 0:n[f];return n}const ut=1<<21;function ct({metadata:e,rowStart:t=0,rowEnd:n=1/0,columns:f,filter:i,filterStrict:r=!0,useOffsetIndex:o=!1}){if(!e)throw new Error("parquetPlan requires metadata");const s=[],c=[],a=[],l=Ke(M(e));let u=0;for(const d of e.row_groups){const w=Number(d.num_rows),h=u+w;if(w>0&&h>t&&u<n&&!fe({rowGroup:d,physicalColumns:l,filter:i,strict:r})){const A=[];for(const m of d.columns){const p=m.meta_data;if(m.file_path)throw new Error("parquet file_path not supported");if(!p)throw new Error("parquet column metadata is undefined");if(!f||f.includes(p.path_in_schema[0])){const I=p.dictionary_page_offset||p.data_page_offset,v=Number(I),O=Number(I+p.total_compressed_size);if(o&&m.offset_index_offset&&m.offset_index_length){const b=Number(m.offset_index_offset);A.push({columnMetadata:p,offsetIndex:{startByte:b,endByte:b+m.offset_index_length},bounds:{startByte:v,endByte:O}})}else A.push({columnMetadata:p,range:{startByte:v,endByte:O}})}}const g=Math.max(t-u,0),_=Math.min(n-u,w);s.push({chunks:A,rowGroup:d,groupStart:u,groupRows:w,selectStart:g,selectEnd:_});let y;for(const m of A)if("offsetIndex"in m)a.push(m.offsetIndex);else{const{range:p}=m;f?c.push(p):y&&p.endByte-y.startByte<=ut?y.endByte=p.endByte:(y&&c.push(y),y={...p})}y&&c.push(y)}u=h}return isFinite(n)||(n=u),c.push(...a),{metadata:e,rowStart:t,rowEnd:n,columns:f,fetches:c,groups:s}}function lt(e,{fetches:t}){const n=t.map(({startByte:f,endByte:i})=>e.slice(f,i));return{byteLength:e.byteLength,slice(f,i=e.byteLength){const r=t.findIndex(({startByte:o,endByte:s})=>o<=f&&i<=s);if(r<0)return e.slice(f,i);if(t[r].startByte!==f||t[r].endByte!==i){const o=f-t[r].startByte,s=i-t[r].startByte;return n[r]instanceof Promise?n[r].then(c=>c.slice(o,s)):n[r].slice(o,s)}else return n[r]}}}const oe=new TextDecoder,me=new WeakMap;function Me(e,t=H){if(Array.isArray(e))return e.map(n=>Me(n,t));if(typeof e!="object")return e;if("metadata"in e){const n=at(e.metadata),f=e.typed_value&&V(e.typed_value,n,t),i=e.value&&$(W(e.value),n,t);return f&&i?{...i,...f}:f??i}return e}function V(e,t,n){if(e&&typeof e=="object"&&!Array.isArray(e)&&!(e instanceof Uint8Array)){if("typed_value"in e)return V(e.typed_value,t,n);if("value"in e&&e.value instanceof Uint8Array)return $(W(e.value),t,n);const f={};for(const[i,r]of Object.entries(e))f[i]=V(r,t,n);return f}return e instanceof Uint8Array?$(W(e),t,n):Array.isArray(e)?e.map(f=>V(f,t,n)):e}function W(e){return{view:new DataView(e.buffer,e.byteOffset,e.byteLength),offset:0}}function at(e){let t=me.get(e.buffer);t||(t=new Map,me.set(e.buffer,t));const n=`${e.byteOffset}:${e.byteLength}`,f=t.get(n);if(f)return f;const i=W(e),r=i.view.getUint8(i.offset++),o=r&15;if(o!==1)throw new Error(`parquet unsupported variant metadata version: ${o}`);const s=(r>>4&1)===1,c=(r>>6&3)+1,a=D(i,c),l=new Array(a+1);for(let h=0;h<l.length;h++)l[h]=D(i,c);const u=i.offset,d=new Array(a);for(let h=0;h<a;h++){const A=l[h],g=l[h+1],_=new Uint8Array(e.buffer,e.byteOffset+u+A,g-A);d[h]=oe.decode(_)}const w={dictionary:d,sorted:s};return t.set(n,w),w}function D(e,t){let n=0;for(let f=0;f<t;f++)n|=e.view.getUint8(e.offset+f)<<f*8;return e.offset+=t,n}function $(e,t,n){const f=e.view.getUint8(e.offset++),i=f&3,r=f>>2;if(i===0)return dt(e,r,n);if(i===2)return _t(e,r,t,n);if(i===3)return wt(e,r,t,n);const o=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,r);return e.offset+=r,oe.decode(o)}function dt(e,t,n){switch(t){case 0:return null;case 1:return!0;case 2:return!1;case 3:{const f=e.view.getInt8(e.offset);return e.offset+=1,f}case 4:{const f=e.view.getInt16(e.offset,!0);return e.offset+=2,f}case 5:{const f=e.view.getInt32(e.offset,!0);return e.offset+=4,f}case 6:{const f=e.view.getBigInt64(e.offset,!0);return e.offset+=8,f}case 7:{const f=e.view.getFloat64(e.offset,!0);return e.offset+=8,f}case 8:return X(e,4);case 9:return X(e,8);case 10:return X(e,16);case 11:{const f=e.view.getInt32(e.offset,!0);return e.offset+=4,n.dateFromDays(f)}case 12:case 13:{const f=e.view.getBigInt64(e.offset,!0);return e.offset+=8,n.timestampFromMicroseconds(f)}case 14:{const f=e.view.getFloat32(e.offset,!0);return e.offset+=4,f}case 15:return ge(e);case 16:{const f=ge(e);return oe.decode(f)}case 17:{const f=e.view.getBigInt64(e.offset,!0);return e.offset+=8,f}case 18:case 19:{const f=e.view.getBigInt64(e.offset,!0);return e.offset+=8,n.timestampFromNanoseconds(f)}case 20:{const f=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,16);e.offset+=16;const i=Array.from(f,r=>r.toString(16).padStart(2,"0")).join("");return`${i.slice(0,8)}-${i.slice(8,12)}-${i.slice(12,16)}-${i.slice(16,20)}-${i.slice(20)}`}default:throw new Error(`parquet unsupported variant primitive type: ${t}`)}}function _t(e,t,n,f){const i=(t&3)+1,r=(t>>2&3)+1,s=t>>4&1?D(e,4):e.view.getUint8(e.offset++),c=new Array(s);for(let u=0;u<s;u++)c[u]=D(e,r);const a=new Array(s+1);for(let u=0;u<a.length;u++)a[u]=D(e,i);const l={};for(let u=0;u<s;u++){const d=n.dictionary[c[u]],w={view:e.view,offset:e.offset+a[u]};l[d]=$(w,n,f)}return e.offset+=a[a.length-1],l}function wt(e,t,n,f){const i=t&3,r=t>>2&1,o=i+1,s=D(e,r?4:1),c=new Array(s+1);for(let u=0;u<c.length;u++)c[u]=D(e,o);const a=e.offset,l=new Array(s);for(let u=0;u<s;u++){const d={view:e.view,offset:a+c[u]};l[u]=$(d,n,f)}return e.offset=a+c[c.length-1],l}function X(e,t){const n=e.view.getUint8(e.offset);e.offset+=1;let f;if(t===4)f=BigInt(e.view.getInt32(e.offset,!0)),e.offset+=4;else if(t===8)f=e.view.getBigInt64(e.offset,!0),e.offset+=8;else{const i=e.view.getBigUint64(e.offset,!0);f=e.view.getBigInt64(e.offset+8,!0)<<64n|i,e.offset+=16}return Number(f)*10**-n}function ge(e){const t=e.view.getUint32(e.offset,!0);e.offset+=4;const n=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,t);return e.offset+=t,n}function Ae(e,t,n,f,i){const r=re(i);if(!(t!=null&&t.length)&&!n.length){if(!r||!f.length)return f;t=new Array(f.length).fill(r)}const o=(t==null?void 0:t.length)||n.length,s=i.map(({element:h})=>h.repetition_type);let c=0;const a=[e];let l=e,u=0,d=0,w=0;if(n[0])for(;u<s.length-2&&w<n[0];)u++,s[u]!=="REQUIRED"&&(l=l.at(-1),a.push(l),d++),s[u]==="REPEATED"&&w++;for(let h=0;h<o;h++){const A=t!=null&&t.length?t[h]:r,g=n[h];for(;u&&(g<w||s[u]!=="REPEATED");)s[u]!=="REQUIRED"&&(a.pop(),d--),s[u]==="REPEATED"&&w--,u--;for(l=a.at(-1);(u<s.length-2||s[u+1]==="REPEATED")&&(d<A||s[u+1]==="REQUIRED");){if(u++,s[u]!=="REQUIRED"){const _=[];l.push(_),l=_,a.push(_),d++}s[u]==="REPEATED"&&w++}A===r?l.push(f[c++]):u===s.length-2?l.push(null):l.push([])}if(!e.length)for(let h=0;h<r;h++){const A=[];l.push(A),l=A}return e}function P(e,t,n,f=0){var s;const i=t.path.join("."),r=t.element.repetition_type==="OPTIONAL",o=r?f+1:f;if(Ze(t)){let c=t.children[0],a=o;c.children.length===1&&(c=c.children[0],a++),P(e,c,n,a);const l=c.path.join("."),u=e.get(l);if(!u)throw new Error("parquet list column missing values");r&&G(u,f),e.set(i,u),e.delete(l);return}if(Qe(t)){const c=t.children[0].element.name;P(e,t.children[0].children[0],n,o+1),P(e,t.children[0].children[1],n,o+1);const a=e.get(`${i}.${c}.key`),l=e.get(`${i}.${c}.value`);if(!a)throw new Error("parquet map column missing keys");if(!l)throw new Error("parquet map column missing values");if(a.length!==l.length)throw new Error("parquet map column key/value length mismatch");const u=$e(a,l,o);r&&G(u,f),e.delete(`${i}.${c}.key`),e.delete(`${i}.${c}.value`),e.set(i,u);return}if(t.children.length){const c=t.element.repetition_type==="REQUIRED"?f:f+1,a={};for(const u of t.children){P(e,u,n,c);const d=e.get(u.path.join("."));if(!d)throw new Error("parquet struct missing child data");a[u.element.name]=d}for(const u of t.children)e.delete(u.path.join("."));let l=Fe(a,c);((s=t.element.logical_type)==null?void 0:s.type)==="VARIANT"&&(l=Me(l,n)),r&&G(l,f),e.set(i,l)}}function G(e,t){for(let n=0;n<e.length;n++)t?G(e[n],t-1):e[n]=e[n][0]}function $e(e,t,n){const f=[];for(let i=0;i<e.length;i++)if(n)f.push($e(e[i],t[i],n-1));else if(e[i]){const r={};for(let o=0;o<e[i].length;o++){const s=t[i][o];r[e[i][o]]=s===void 0?null:s}f.push(r)}else f.push(void 0);return f}function Fe(e,t){var r;const n=Object.keys(e),f=(r=e[n[0]])==null?void 0:r.length,i=[];for(let o=0;o<f;o++){const s={};for(const c of n){if(e[c].length!==f)throw new Error("parquet struct parsing error");s[c]=e[c][o]}t?i.push(Fe(s,t-1)):i.push(s)}return i}function F(e,t,n){const f=n instanceof Int32Array,i=B(e),r=B(e);B(e);let o=ne(e),s=0;n[s++]=f?Number(o):o;const c=i/r;for(;s<t;){const a=ne(e),l=new Uint8Array(r);for(let u=0;u<r;u++)l[u]=e.view.getUint8(e.offset++);for(let u=0;u<r&&s<t;u++){const d=BigInt(l[u]);if(d){let w=0n,h=c;const A=(1n<<d)-1n;for(;h&&s<t;){let g=BigInt(e.view.getUint8(e.offset))>>w&A;for(w+=d;w>=8;)w-=8n,e.offset++,w&&(g|=BigInt(e.view.getUint8(e.offset))<<d-w&A);const _=a+g;o+=_,n[s++]=f?Number(o):o,h--}h&&(e.offset+=Math.ceil((h*Number(d)+Number(w))/8))}else for(let w=0;w<c&&s<t;w++)o+=a,n[s++]=f?Number(o):o}}}function Ce(e,t,n){const f=new Int32Array(t);F(e,t,f);for(let i=0;i<t;i++)n[i]=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,f[i]),e.offset+=f[i]}function ht(e,t,n){const f=new Int32Array(t);F(e,t,f);const i=new Int32Array(t);F(e,t,i);for(let r=0;r<t;r++){const o=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,i[r]);f[r]?(n[r]=new Uint8Array(f[r]+i[r]),n[r].set(n[r-1].subarray(0,f[r])),n[r].set(o,f[r])):n[r]=o,e.offset+=i[r]}}function Z(e){return 32-Math.clz32(e)}function L(e,t,n,f){f===void 0&&(f=e.view.getUint32(e.offset,!0),e.offset+=4);const i=e.offset;let r=0;for(;r<n.length;){const o=B(e);if(o&1)r=gt(e,o,t,n,r);else{const s=o>>>1;mt(e,s,t,n,r),r+=s}}e.offset=i+f}function mt(e,t,n,f,i){const r=n+7>>3;let o=0;for(let s=0;s<r;s++)o|=e.view.getUint8(e.offset++)<<(s<<3);for(let s=0;s<t;s++)f[i+s]=o}function gt(e,t,n,f,i){let r=t>>1<<3;const o=(1<<n)-1;let s=0;if(e.offset<e.view.byteLength)s=e.view.getUint8(e.offset++);else if(o)throw new Error(`parquet bitpack offset ${e.offset} out of range`);let c=8,a=0;for(;r;)a>8?(a-=8,c-=8,s>>>=8):c-a<n?(s|=e.view.getUint8(e.offset)<<c,e.offset++,c+=8):(i<f.length&&(f[i++]=s>>a&o),r--,a+=n);return i}function Ye(e,t,n,f){const i=At(n,f),r=new Uint8Array(t*i);for(let o=0;o<i;o++)for(let s=0;s<t;s++)r[s*i+o]=e.view.getUint8(e.offset++);if(n==="FLOAT")return new Float32Array(r.buffer);if(n==="DOUBLE")return new Float64Array(r.buffer);if(n==="INT32")return new Int32Array(r.buffer);if(n==="INT64")return new BigInt64Array(r.buffer);if(n==="FIXED_LEN_BYTE_ARRAY"){const o=new Array(t);for(let s=0;s<t;s++)o[s]=r.subarray(s*i,(s+1)*i);return o}throw new Error(`parquet byte_stream_split unsupported type: ${n}`)}function At(e,t){switch(e){case"INT32":case"FLOAT":return 4;case"INT64":case"DOUBLE":return 8;case"FIXED_LEN_BYTE_ARRAY":if(!t)throw new Error("parquet byteWidth missing type_length");return t;default:throw new Error(`parquet unsupported type: ${e}`)}}function ue(e,t,n,f){if(n===0)return[];if(t==="BOOLEAN")return yt(e,n);if(t==="INT32")return pt(e,n);if(t==="INT64")return Et(e,n);if(t==="INT96")return It(e,n);if(t==="FLOAT")return bt(e,n);if(t==="DOUBLE")return vt(e,n);if(t==="BYTE_ARRAY")return Rt(e,n);if(t==="FIXED_LEN_BYTE_ARRAY"){if(!f)throw new Error("parquet missing fixed length");return Nt(e,n,f)}else throw new Error(`parquet unhandled type: ${t}`)}function yt(e,t){const n=new Array(t);for(let f=0;f<t;f++){const i=e.offset+(f/8|0),r=f%8,o=e.view.getUint8(i);n[f]=(o&1<<r)!==0}return e.offset+=Math.ceil(t/8),n}function pt(e,t){const n=(e.view.byteOffset+e.offset)%4?new Int32Array(Q(e.view.buffer,e.view.byteOffset+e.offset,t*4)):new Int32Array(e.view.buffer,e.view.byteOffset+e.offset,t);return e.offset+=t*4,n}function Et(e,t){const n=(e.view.byteOffset+e.offset)%8?new BigInt64Array(Q(e.view.buffer,e.view.byteOffset+e.offset,t*8)):new BigInt64Array(e.view.buffer,e.view.byteOffset+e.offset,t);return e.offset+=t*8,n}function It(e,t){const n=new Array(t);for(let f=0;f<t;f++){const i=e.view.getBigInt64(e.offset+f*12,!0),r=e.view.getInt32(e.offset+f*12+8,!0);n[f]=BigInt(r)<<64n|i}return e.offset+=t*12,n}function bt(e,t){const n=(e.view.byteOffset+e.offset)%4?new Float32Array(Q(e.view.buffer,e.view.byteOffset+e.offset,t*4)):new Float32Array(e.view.buffer,e.view.byteOffset+e.offset,t);return e.offset+=t*4,n}function vt(e,t){const n=(e.view.byteOffset+e.offset)%8?new Float64Array(Q(e.view.buffer,e.view.byteOffset+e.offset,t*8)):new Float64Array(e.view.buffer,e.view.byteOffset+e.offset,t);return e.offset+=t*8,n}function Rt(e,t){const n=new Array(t);for(let f=0;f<t;f++){const i=e.view.getUint32(e.offset,!0);e.offset+=4,n[f]=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,i),e.offset+=i}return n}function Nt(e,t,n){const f=new Array(t);for(let i=0;i<t;i++)f[i]=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,n),e.offset+=n;return f}function Q(e,t,n){const f=new ArrayBuffer(n);return new Uint8Array(f).set(new Uint8Array(e,t,n)),f}const Lt=[0,255,65535,16777215,4294967295];function ye(e,t,n,f,i){for(let r=0;r<i;r++)n[f+r]=e[t+r]}function Ot(e,t){const n=e.byteLength,f=t.byteLength;let i=0,r=0;for(;i<n;){const o=e[i];if(i++,o<128)break}if(f&&i>=n)throw new Error("invalid snappy length header");for(;i<n;){const o=e[i];let s=0;if(i++,i>=n)throw new Error("missing eof marker");if((o&3)===0){let c=(o>>>2)+1;if(c>60){if(i+3>=n)throw new Error("snappy error literal pos + 3 >= inputLength");const a=c-60;c=e[i]+(e[i+1]<<8)+(e[i+2]<<16)+(e[i+3]<<24),c=(c&Lt[a])+1,i+=a}if(i+c>n)throw new Error("snappy error literal exceeds input length");ye(e,i,t,r,c),i+=c,r+=c}else{let c=0;switch(o&3){case 1:s=(o>>>2&7)+4,c=e[i]+(o>>>5<<8),i++;break;case 2:if(n<=i+1)throw new Error("snappy error end of input");s=(o>>>2)+1,c=e[i]+(e[i+1]<<8),i+=2;break;case 3:if(n<=i+3)throw new Error("snappy error end of input");s=(o>>>2)+1,c=e[i]+(e[i+1]<<8)+(e[i+2]<<16)+(e[i+3]<<24),i+=4;break}if(c===0||isNaN(c))throw new Error(`invalid offset ${c} pos ${i} inputLength ${n}`);if(c>r)throw new Error("cannot copy from before start of buffer");ye(t,r-c,t,r,s),r+=s}}if(r!==f)throw new Error("premature end of input")}function St(e,t,{type:n,element:f,schemaPath:i}){const r=new DataView(e.buffer,e.byteOffset,e.byteLength),o={view:r,offset:0};let s;const c=Bt(o,t,i),{definitionLevels:a,numNulls:l}=Dt(o,t,i),u=t.num_values-l;if(t.encoding==="PLAIN")s=ue(o,n,u,f.type_length);else if(t.encoding==="PLAIN_DICTIONARY"||t.encoding==="RLE_DICTIONARY"||t.encoding==="RLE"){const d=n==="BOOLEAN"?1:r.getUint8(o.offset++);d?(s=new Array(u),n==="BOOLEAN"?(L(o,d,s),s=s.map(w=>!!w)):L(o,d,s,r.byteLength-o.offset)):s=new Uint8Array(u)}else if(t.encoding==="BYTE_STREAM_SPLIT")s=Ye(o,u,n,f.type_length);else if(t.encoding==="DELTA_BINARY_PACKED")s=n==="INT32"?new Int32Array(u):new BigInt64Array(u),F(o,u,s);else if(t.encoding==="DELTA_LENGTH_BYTE_ARRAY")s=new Array(u),Ce(o,u,s);else throw new Error(`parquet unsupported encoding: ${t.encoding}`);return{definitionLevels:a,repetitionLevels:c,dataPage:s}}function Bt(e,t,n){if(n.length>1){const f=De(n);if(f){const i=new Array(t.num_values);return L(e,Z(f),i),i}}return[]}function Dt(e,t,n){const f=re(n);if(!f)return{definitionLevels:[],numNulls:0};const i=new Array(t.num_values);L(e,Z(f),i);let r=t.num_values;for(const o of i)o===f&&r--;return r===0&&(i.length=0),{definitionLevels:i,numNulls:r}}function ie(e,t,n,f){let i;const r=f==null?void 0:f[n];if(n==="UNCOMPRESSED")i=e;else if(r)i=r(e,t);else if(n==="SNAPPY")i=new Uint8Array(t),Ot(e,i);else throw new Error(`parquet unsupported compression codec: ${n}`);if((i==null?void 0:i.length)!==t)throw new Error(`parquet decompressed page length ${i==null?void 0:i.length} does not match header ${t}`);return i}function Ut(e,t,n){const i={view:new DataView(e.buffer,e.byteOffset,e.byteLength),offset:0},{type:r,element:o,schemaPath:s,codec:c,compressors:a}=n,l=t.data_page_header_v2;if(!l)throw new Error("parquet data page header v2 is undefined");const u=xt(i,l,s);i.offset=l.repetition_levels_byte_length;const d=Pt(i,l,s),w=t.uncompressed_page_size-l.definition_levels_byte_length-l.repetition_levels_byte_length;let h=e.subarray(i.offset);l.is_compressed!==!1&&(h=ie(h,w,c,a));const A=new DataView(h.buffer,h.byteOffset,h.byteLength),g={view:A,offset:0};let _;const y=l.num_values-l.num_nulls;if(l.encoding==="PLAIN")_=ue(g,r,y,o.type_length);else if(l.encoding==="RLE")_=new Array(y),L(g,1,_),_=_.map(m=>!!m);else if(l.encoding==="PLAIN_DICTIONARY"||l.encoding==="RLE_DICTIONARY"){const m=A.getUint8(g.offset++);_=new Array(y),L(g,m,_,w-1)}else if(l.encoding==="DELTA_BINARY_PACKED")_=r==="INT32"?new Int32Array(y):new BigInt64Array(y),F(g,y,_);else if(l.encoding==="DELTA_LENGTH_BYTE_ARRAY")_=new Array(y),Ce(g,y,_);else if(l.encoding==="DELTA_BYTE_ARRAY")_=new Array(y),ht(g,y,_);else if(l.encoding==="BYTE_STREAM_SPLIT")_=Ye(g,y,r,o.type_length);else throw new Error(`parquet unsupported encoding: ${l.encoding}`);return{definitionLevels:d,repetitionLevels:u,dataPage:_}}function xt(e,t,n){const f=De(n);if(!f)return[];const i=new Array(t.num_values);return L(e,Z(f),i,t.repetition_levels_byte_length),i}function Pt(e,t,n){const f=re(n);if(f){const i=new Array(t.num_values);return L(e,Z(f),i,t.definition_levels_byte_length),i}}function pe(e,{groupStart:t,selectStart:n,selectEnd:f},i,r){const{pathInSchema:o,schemaPath:s}=i,c=Ue(s),a=[];let l,u,d=0,w=0;const h=r&&(()=>{u&&r({pathInSchema:o,columnData:u,rowStart:t+d-u.length,rowEnd:t+d})});for(;(c?d<f:e.offset<e.view.byteLength-1)&&!(e.offset>=e.view.byteLength-1);){const A=Tt(e);if(A.type==="DICTIONARY_PAGE"){const{data:g}=Ee(e,A,i,l,void 0,0);g&&(l=Ne(g,i))}else{const g=(u==null?void 0:u.length)||0,_=Ee(e,A,i,l,u,n-d);_.skipped?(a.length||(w+=_.skipped),d+=_.skipped):_.data&&u===_.data?d+=_.data.length-g:_.data&&_.data.length&&(h==null||h(),a.push(_.data),d+=_.data.length,u=_.data)}}return h==null||h(),{data:a,skipped:w}}function Ee(e,t,n,f,i,r){const{type:o,element:s,schemaPath:c,codec:a,compressors:l}=n,u=new Uint8Array(e.view.buffer,e.view.byteOffset+e.offset,t.compressed_page_size);if(e.offset+=t.compressed_page_size,t.type==="DATA_PAGE"){const d=t.data_page_header;if(!d)throw new Error("parquet data page header is undefined");if(r>d.num_values&&Ue(c))return{skipped:d.num_values};const w=ie(u,Number(t.uncompressed_page_size),a,l),{definitionLevels:h,repetitionLevels:A,dataPage:g}=St(w,d,n),_=de(g,f,d.encoding,n),y=Array.isArray(i)?i:[];return{skipped:0,data:Ae(y,h,A,_,c)}}else if(t.type==="DATA_PAGE_V2"){const d=t.data_page_header_v2;if(!d)throw new Error("parquet data page header v2 is undefined");if(r>d.num_rows)return{skipped:d.num_values};const{definitionLevels:w,repetitionLevels:h,dataPage:A}=Ut(u,t,n),g=de(A,f,d.encoding,n),_=Array.isArray(i)?i:[];return{skipped:0,data:Ae(_,w,h,g,c)}}else if(t.type==="DICTIONARY_PAGE"){const d=t.dictionary_page_header;if(!d)throw new Error("parquet dictionary page header is undefined");const w=ie(u,Number(t.uncompressed_page_size),a,l),h={view:new DataView(w.buffer,w.byteOffset,w.byteLength),offset:0};return{skipped:0,data:ue(h,o,d.num_values,s.type_length)}}else throw new Error(`parquet unsupported page type: ${t.type}`)}function Tt(e){const t=se(e),n=ve[t.field_1],f=t.field_2,i=t.field_3,r=t.field_4,o=t.field_5&&{num_values:t.field_5.field_1,encoding:S[t.field_5.field_2],definition_level_encoding:S[t.field_5.field_3],repetition_level_encoding:S[t.field_5.field_4],statistics:t.field_5.field_5&&{max:t.field_5.field_5.field_1,min:t.field_5.field_5.field_2,null_count:t.field_5.field_5.field_3,distinct_count:t.field_5.field_5.field_4,max_value:t.field_5.field_5.field_5,min_value:t.field_5.field_5.field_6}},s=t.field_6,c=t.field_7&&{num_values:t.field_7.field_1,encoding:S[t.field_7.field_2],is_sorted:t.field_7.field_3},a=t.field_8&&{num_values:t.field_8.field_1,num_nulls:t.field_8.field_2,num_rows:t.field_8.field_3,encoding:S[t.field_8.field_4],definition_levels_byte_length:t.field_8.field_5,repetition_levels_byte_length:t.field_8.field_6,is_compressed:t.field_8.field_7===void 0?!0:t.field_8.field_7,statistics:t.field_8.field_8};return{type:n,uncompressed_page_size:f,compressed_page_size:i,crc:r,data_page_header:o,index_page_header:s,dictionary_page_header:c,data_page_header_v2:a}}function Mt(e,{metadata:t},n){const{file:f,compressors:i,utf8:r}=e,o=[],s={...H,...e.parsers};for(const c of n.chunks){const{columnMetadata:a}=c,l=Be(t.schema,a.path_in_schema),u={pathInSchema:a.path_in_schema,type:a.type,element:l[l.length-1].element,schemaPath:l,codec:a.codec,parsers:s,compressors:i,utf8:r};if(!("offsetIndex"in c)){o.push({pathInSchema:a.path_in_schema,data:Promise.resolve(f.slice(c.range.startByte,c.range.endByte)).then(d=>{const w={view:new DataView(d),offset:0};return pe(w,n,u,e.onPage)})});continue}o.push({pathInSchema:a.path_in_schema,data:Promise.resolve(f.slice(c.offsetIndex.startByte,c.offsetIndex.endByte)).then(async d=>{const w=it({view:new DataView(d),offset:0}),{selectStart:h,selectEnd:A}=n,g=w.page_locations;let _=NaN,y=NaN,m=0;for(let U=0;U<g.length;U++){const C=g[U],ce=Number(C.first_row_index),je=U+1<g.length?Number(g[U+1].first_row_index):n.groupRows;ce<A&&je>h&&(Number.isNaN(_)&&(_=Number(C.offset),m=ce),y=Number(C.offset)+C.compressed_page_size)}const p=await f.slice(_,y),I={view:new DataView(p),offset:0},v=m?{...n,groupStart:n.groupStart+m,selectStart:n.selectStart-m,selectEnd:n.selectEnd-m}:n,{data:O,skipped:b}=pe(I,v,u,e.onPage);return{data:O,skipped:m+b}})})}return{groupStart:n.groupStart,groupRows:n.groupRows,asyncColumns:o}}async function Ie({asyncColumns:e},t,n,f,i){const r=await Promise.all(e.map(async({data:u})=>{const d=await u;return{...d,data:z(d.data)}})),o=e.map(u=>u.pathInSchema[0]).filter(u=>!f||f.includes(u)),s=f??o,c=s.map(u=>e.findIndex(d=>d.pathInSchema[0]===u)),a=n-t;if(i==="object"){const u=Array(a);for(let d=0;d<a;d++){const w=t+d,h={};for(let A=0;A<e.length;A++){const{data:g,skipped:_}=r[A];h[e[A].pathInSchema[0]]=g[w-_]}u[d]=h}return u}const l=Array(a);for(let u=0;u<a;u++){const d=t+u,w=Array(e.length);for(let h=0;h<s.length;h++){const A=c[h];if(A>=0){const{data:g,skipped:_}=r[A];w[h]=g[d-_]}}l[u]=w}return l}function qe(e,t,n){const{asyncColumns:f}=e;n={...H,...n};const i=[];for(const r of t.children)if(r.children.length){const o=f.filter(a=>a.pathInSchema[0]===r.element.name);if(!o.length)continue;const s=new Map,c=Promise.all(o.map(a=>a.data.then(({data:l})=>{s.set(a.pathInSchema.join("."),z(l))}))).then(()=>{P(s,r,n);const a=s.get(r.path.join("."));if(!a)throw new Error("parquet column data not assembled");return{data:[a],skipped:0}});i.push({pathInSchema:r.path,data:c})}else{const o=f.find(s=>s.pathInSchema[0]===r.element.name);o&&i.push(o)}return{...e,asyncColumns:i}}async function $t(e){e.metadata??(e.metadata=await K(e.file,e));const{rowStart:t=0,rowEnd:n,columns:f,onChunk:i,onComplete:r,rowFormat:o,filter:s,filterStrict:c=!0}=e;if(s&&o!=="object")throw new Error('parquet filter requires rowFormat: "object"');const a=j(s);if(a.length){const g=M(e.metadata).children.map(y=>y.element.name),_=a.filter(y=>!g.includes(y));if(_.length)throw new Error(`parquet filter columns not found: ${_.join(", ")}`)}let l=f,u=!1;if(f&&s){const g=a.filter(_=>!f.includes(_));g.length&&(l=[...f,...g],u=!0)}const d=l!==f?{...e,columns:l}:e,w=ke(d);if(!r&&!i){for(const{asyncColumns:g}of w)for(const{data:_}of g)await _;return}const h=M(e.metadata),A=w.map(g=>qe(g,h,e.parsers));if(i)for(const g of A)for(const _ of g.asyncColumns)_.data.then(({data:y,skipped:m})=>{let p=g.groupStart+m;for(const I of y)i({columnName:_.pathInSchema[0],columnData:I,rowStart:p,rowEnd:p+I.length}),p+=I.length});if(r){const g=[];for(const _ of A){const y=Math.max(t-_.groupStart,0),m=Math.min((n??1/0)-_.groupStart,_.groupRows),p=o==="object"?await Ie(_,y,m,l,"object"):await Ie(_,y,m,f,"array");if(s){for(const I of p)if(x(I,s,c)){if(u&&f)for(const v of a)f.includes(v)||delete I[v];g.push(I)}}else Te(g,p)}r(g)}else for(const{asyncColumns:g}of A)for(const{data:_}of g)await _}function ke(e){if(!e.metadata)throw new Error("parquet requires metadata");const t=ct(e);return e.file=lt(e.file,t),t.groups.map(n=>Mt(e,t,n))}async function Ft(e){var r;if(((r=e.columns)==null?void 0:r.length)!==1)throw new Error("parquetReadColumn expected columns: [columnName]");e.metadata??(e.metadata=await K(e.file,e));const t=ke(e),n=M(e.metadata),f=t.map(o=>qe(o,n,e.parsers)),i=[];for(const o of f)i.push(z((await o.asyncColumns[0].data).data));return z(i)}function T(e){return new Promise((t,n)=>{$t({...e,rowFormat:"object",onComplete:t}).catch(n)})}async function qt(e){if(!e.file||!(e.file.byteLength>=0))throw new Error("parquet expected AsyncBuffer");e.metadata??(e.metadata=await K(e.file,e));const{metadata:t,rowStart:n=0,columns:f,orderBy:i,filter:r}=e;if(n<0)throw new Error("parquet rowStart must be positive");const o=e.rowEnd??Number(t.num_rows);if(i&&!M(e.metadata).children.map(c=>c.element.name).includes(i))throw new Error(`parquet orderBy column not found: ${i}`);if(r&&!i&&o<t.num_rows){const s=[];let c=0;for(const a of t.row_groups){const l=c+Number(a.num_rows),u=await T({...e,rowStart:c,rowEnd:l});if(s.push(...u),s.length>=o)break;c=l}return s.slice(n,o)}else if(r&&i){const s=f&&!f.includes(i)?[...f,i]:f,c=await T({...e,rowStart:void 0,rowEnd:void 0,columns:s});if(c.sort((a,l)=>be(a[i],l[i])),s!==f)for(const a of c)delete a[i];return c.slice(n,o)}else{if(r)return(await T({...e,rowStart:void 0,rowEnd:void 0})).slice(n,o);if(typeof i=="string"){const s=await Ft({...e,rowStart:void 0,rowEnd:void 0,columns:[i]}),c=Array.from(s,(u,d)=>d).sort((u,d)=>be(s[u],s[d])).slice(n,o),a=await Ct({...e,rows:c});return c.map(u=>a[u])}else return await T(e)}}async function Ct(e){const{file:t,rows:n}=e;e.metadata??(e.metadata=await K(t,e));const{row_groups:f}=e.metadata,i=Array(f.length).fill(!1);let r=0;const o=f.map(l=>r+=Number(l.num_rows));for(const l of n){const u=o.findIndex(d=>l<d);i[u]=!0}const s=[];let c;r=0;for(let l=0;l<i.length;l++){const u=r+Number(f[l].num_rows);i[l]?c===void 0&&(c=r):c!==void 0&&(s.push([c,u]),c=void 0),r=u}c!==void 0&&s.push([c,r]);const a=Array(Number(e.metadata.num_rows));for(const[l,u]of s){const d=await T({...e,rowStart:l,rowEnd:u});for(let w=l;w<u;w++)a[w]={__index__:w,...d[w-l]}}return a}function be(e,t){return e<t?-1:e>t?1:0}export{Yt as asyncBufferFromUrl,st as byteLengthFromUrl,z as flatten,_e as parquetMetadata,K as parquetMetadataAsync,qt as parquetQuery,$t as parquetRead,T as parquetReadObjects,M as parquetSchema,it as readOffsetIndex,Ot as snappyUncompress};
