const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./HUDMaterial.glsl-BpyXEYMr.js","./vec2-D0N3Bz89.js","./index-DzoQLc5A.js","./index-FMl8DCyv.css","./vec2f64-B08OqgY-.js","./NormalAttribute.glsl-B56U0yJ_.js","./VertexAttribute-C1eU-FcF.js","./DefaultMaterial-DhVdWTwX.js","./videoUtils-xf59qIHa.js","./basicInterfaces-N86vRvDz.js","./TextureFormat-1mYWTFa-.js","./enums-CIq3dAOf.js","./BufferView-6Wo0HYee.js","./vec32-LyzMesOw.js","./sphere-DVa6yVTZ.js","./mat3-D2DxLcs1.js","./mat3f64-B5o_lm6j.js","./vectorStacks-BcGsIGGR.js","./mat4f64-Busq8X2U.js","./quatf64-aQ5IuZRd.js","./lineSegment-BnQxKnu0.js","./orientedBoundingBox-CegL4iPR.js","./quat-CI_Qlf1a.js","./spatialReferenceEllipsoidUtils-DtwM3pvq.js","./computeTranslationToOriginAndRotation-Bgn1ecnn.js","./plane-BM5dy-fQ.js","./InterleavedLayout-DWIRiq9i.js","./types-BKo2foNY.js","./time-ClENgjgA.js","./QueryEngine-D_WWwzbx.js","./featureConversionUtils-4vS7e9DV.js","./OptimizedFeature-DdLiUxBt.js","./memoryEstimations-Cau39Oyv.js","./OptimizedFeatureSet-BR8EEvDc.js","./WhereClauseCache-DaRLeTPC.js","./WhereClause-C4sLVd4N.js","./FixedIntervalBinParameters-DX-Dxyp5.js","./normalizeUtils-PTTPU64I.js","./normalizeUtilsCommon-C_a4i1bY.js","./utils-DDykF6ND.js","./utils-BRuFmAg3.js","./json-Wa8cmqdu.js","./QueryEngineCapabilities-CsRUnGk7.js","./quantizationUtils-DJOt4u77.js","./utils-Cr3t4q4M.js","./utils-DfwSxgqQ.js","./utils-CeM4xVkE.js","./ClassBreaksDefinition-C0HjICjI.js","./signal-CCMhCnaC.js","./MeshLocalVertexSpace-Dm43RUlb.js","./projectVectorToVector-BrIfimJ2.js","./projectPointToVector-HiGkO6mN.js","./Indices-Die4BdlF.js","./floatRGBA-DFG_svH_.js","./vec3f32-WCVSSNPR.js","./IntersectorType-D_qF1tGO.js","./ReactiveMap-BD3qyxSB.js","./PooledRBush-BI1asDku.js","./quickselect-QQC62dOK.js","./query-BkjTHcYa.js","./pbfQueryUtils-Dt3eDkdS.js","./pbf-B-Qb_RCl.js"])))=>i.map(i=>d[i]);
import{kk as tn,gn as rn,bs as ft,kl as nn,gp as qe,km as an,ey as ht,kn as br,ko as sn,a6 as U,bU as on,kp as mt,kq as vr,kr as ln,ks as zt,bF as cn,dY as dn,dX as un,kt as fn,eR as hn,eI as mn,fy as pn,f$ as gn,bX as yn,hK as _n,c6 as jt,gu as bn,ku as vn,hZ as Cn,dU as pt,dV as gt,$ as Te,id as xn,L as Cr,n as Lt,B as S,F as N,J as xr,K as wn,kv as In,b_ as Sn,bC as wr,hq as An,s as On,c2 as $n,du as Pn,hO as Tn,iP as Rn,_ as En,kw as Bt,eU as tt,eA as $t,cp as Fn,bE as Ir,aB as Dn,dQ as Mn,eJ as Sr,eM as zn,hP as Ae,hh as Ar,kx as jn,d7 as Ln,dS as Bn,eh as Ut,aC as Vt,et as Nt,R as Un,cA as Vn,cB as Nn,bY as kn,fS as Gn}from"./index-DzoQLc5A.js";import{L as Hn}from"./QueryEngine-D_WWwzbx.js";import{e as we}from"./mat4f64-Busq8X2U.js";import{c as J,_ as nt,A as ge,o as Oe,E as ye,g as Z,s as Q,r as Re,p as Or,u as Pt,R as qn,N as Qn,P as Wn}from"./vec32-LyzMesOw.js";import"./MeshLocalVertexSpace-Dm43RUlb.js";import{r as Xn,o as Tt,I as Yn}from"./vec2-D0N3Bz89.js";import{r as k,n as Rt}from"./vec2f64-B08OqgY-.js";import{g as Jn,h as kt,d as Gt,e as Zn,H as Ht,b as Kn,Q as qt,j as $r,k as ea,l as ta,p as Et,q as yt,r as Qe,u as ra,w as na,x as Pr,y as Tr,z as aa,A as ia,B as Rr,C as sa,D as oa,E as la,F as ca,G as da,I as Qt,J as at,M as Wt,N as ua,O as K,P as fa,T as $e,U as ha,V as ma,X as pa,Y as ga,Z as ya,_ as _a,$ as ba,a0 as va,a1 as Ca,a2 as xa,a3 as wa,a4 as F,a5 as Ia,a6 as ae,a7 as Sa,a8 as Er,a9 as Fr,aa as Aa,ab as Oa,ac as $a,ad as Pa,ae as Ta,af as Ra,ag as Ea,ah as Fa,ai as Da,aj as Xt,ak as Yt,al as Ma,am as za,an as Jt,W as ja,o as La,ao as Ba,ap as Ua}from"./DefaultMaterial-DhVdWTwX.js";import{n as We}from"./projectVectorToVector-BrIfimJ2.js";import{e as Va,A as Na}from"./Indices-Die4BdlF.js";import{o as ka}from"./floatRGBA-DFG_svH_.js";import{P as Zt,R as Kt,C as Ga}from"./enums-CIq3dAOf.js";import{t as G,l as me}from"./orientedBoundingBox-CegL4iPR.js";import{e as y}from"./VertexAttribute-C1eU-FcF.js";import{m as Ha}from"./computeTranslationToOriginAndRotation-Bgn1ecnn.js";import{r as q,n as Fe}from"./vec3f32-WCVSSNPR.js";import{q as qa}from"./plane-BM5dy-fQ.js";import{V as Qa,f as Wa,u as Xa}from"./sphere-DVa6yVTZ.js";import{e as er}from"./basicInterfaces-N86vRvDz.js";import"./IntersectorType-D_qF1tGO.js";import{s as tr}from"./ReactiveMap-BD3qyxSB.js";import{s as xe,t as Ya,n as Dr,a as Ja}from"./memoryEstimations-Cau39Oyv.js";import{s as Za,E as Mr}from"./PooledRBush-BI1asDku.js";import{n as Ka,e as _t}from"./OptimizedFeature-DdLiUxBt.js";import{m as ei}from"./query-BkjTHcYa.js";import{a as ti}from"./pbf-B-Qb_RCl.js";import{u as ri}from"./quantizationUtils-DJOt4u77.js";import{b as ni,h as ai}from"./pbfQueryUtils-Dt3eDkdS.js";import{n as zr}from"./mat3-D2DxLcs1.js";import{e as jr}from"./mat3f64-B5o_lm6j.js";import{s as ii,g as si,o as rr,f as oi,y as li,T as nr}from"./BufferView-6Wo0HYee.js";import{O as ci}from"./InterleavedLayout-DWIRiq9i.js";import{n as _,b as di,c as H,t as z,u as Lr,w as it}from"./NormalAttribute.glsl-B56U0yJ_.js";import{a as ui}from"./spatialReferenceEllipsoidUtils-DtwM3pvq.js";import{i as fi}from"./projectPointToVector-HiGkO6mN.js";import{c as te}from"./vectorStacks-BcGsIGGR.js";function hi(a){a.code.add(_`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}`),a.code.add(_`const vec4 RGBA_TO_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgbaTofloat(vec4 rgba) {
return dot(rgba, RGBA_TO_FLOAT_FACTORS);
}`),a.code.add(_`const vec4 uninterpolatedRGBAToFloatFactors = vec4(
1.0 / 256.0,
1.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0 / 256.0
);
float uninterpolatedRGBAToFloat(vec4 rgba) {
return (dot(round(rgba * 255.0), uninterpolatedRGBAToFloatFactors) - 0.5) * 2.0;
}`)}let mi=class extends Jn{constructor(e,t){super(e,"vec4",di.Draw,((r,n,i)=>r.setUniform4fv(e,t(n,i))))}},W=class Br{constructor(e,t,r){this.renderCommandContext=e,this.renderCommandBuffer=t,this.pipelineStateCommands=r}append(e){this.appendRenderCommands(e.renderCommandBuffer),this.appendPipelineStateCommands(e.pipelineStateCommands)}appendRenderCommands(e){this.renderCommandBuffer.commands.push(...e.commands),this.renderCommandBuffer.transferList.push(...e.transferList)}appendPipelineStateCommand(e){this.pipelineStateCommands.push(e)}appendPipelineStateCommands(e){for(const t of e)this.appendPipelineStateCommand(t)}async execute(){for(const e of this.pipelineStateCommands)e();await this.renderCommandContext.dispatchRenderCommands(this.renderCommandBuffer)}static create(e,t=[]){return new Br(e,e.createRenderCommandBuffer(),t)}};function pi(a){return a.length===0?null:a.reduce(((e,t)=>(e.append(t),e)))}function Ur(){return new tn({material:new rn({color:new ft("red")})})}function gi(){return new nn}function yi(a,e,t=null){const r=an(br);return a!=null&&(r[0]=a[0],r[1]=a[1],r[2]=a[2]),e!=null?r[3]=e:a!=null&&a.length>3&&(r[3]=a[3]),t&&(r[0]*=t,r[1]*=t,r[2]*=t,r[3]*=t),r}function _i(a=qe,e,t,r=1){const n=new Array(3);if(e==null||t==null)n[0]=1,n[1]=1,n[2]=1;else{let i,s=0;for(let o=2;o>=0;o--){const l=a[o],d=l!=null,u=o===0&&!i&&!d,c=t[o];let f;l==="symbol-value"||u?f=c!==0?e[o]/c:1:d&&l!=="proportional"&&isFinite(l)&&(f=c!==0?l/c:1),f!=null&&(n[o]=f,i=f,s=Math.max(s,Math.abs(f)))}for(let o=2;o>=0;o--)n[o]==null?n[o]=i:n[o]===0&&(n[o]=.001*s)}for(let i=2;i>=0;i--)n[i]/=r;return ht(n)}var ar;(function(a){a[a.Left=0]="Left",a[a.Center=1]="Center",a[a.Right=2]="Right"})(ar||(ar={}));const bi=Object.freeze({"bottom-left":k(0,0),bottom:k(.5,0),"bottom-right":k(1,0),left:k(0,.5),center:k(.5,.5),right:k(1,.5),"top-left":k(0,1),top:k(.5,1),"top-right":k(1,1)});function Ft(a){const{featureCount:e}=a;if(e===0)return new Uint32Array;const t=new Uint32Array(e);return a.getObjectIdsArray(t),t}function bt(a){const{featureCount:e}=a;if(e===0)return new Float64Array;const t=new Float64Array(3*e);return a.getCoordinatesArray(t),t}function vi(a,e){const t=a.length/3,r=e.viewSpatialReference,n=e.renderSpatialReference,i=new Float64Array(3*t);if(!on(a,r,0,i,n,0,t))throw new Error("Failed to project coordinates");return i}function ir(a,e){const t=e.viewSpatialReference,r=e.renderSpatialReference,{extent:n}=a,i=sn(n),s=U();return We([i[0],i[1],0],t,s,r),s}function Vr(a){const e=new Map;for(const[t,r]of a)e.set(t,{...r,indices:Va(r.indices)});return e}const Nr=128,pe=.5,Ci=mt(pe/2,pe/2,1-pe/2,1-pe/2);function xi(a){return a==="x"}function wi(a,e=Nr,t=e*pe,r=0){return{data:Ii(a,e,t,r),parameters:{mipmap:!1,wrap:{s:Zt.CLAMP_TO_EDGE,t:Zt.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0}}}function Ii(a,e=Nr,t=e*pe,r=0){switch(a){case"circle":default:return Si(e,t);case"square":return Ai(e,t);case"cross":return $i(e,t,r);case"x":return Pi(e,t,r);case"kite":return Oi(e,t);case"triangle":return Ti(e,t);case"arrow":return Ri(e,t)}}function Si(a,e){const t=a/2-.5;return De(a,Hr(t,t,e/2))}function Ai(a,e){return kr(a,e,!1)}function Oi(a,e){return kr(a,e,!0)}function $i(a,e,t=0){return Gr(a,e,!1,t)}function Pi(a,e,t=0){return Gr(a,e,!0,t)}function Ti(a,e){return De(a,qr(a/2,e,e/2))}function Ri(a,e){const t=e,r=e/2,n=a/2,i=.8*t,s=Hr(n,(a-e)/2-i,Math.sqrt(i*i+r*r)),o=qr(n,t,r);return De(a,((l,d)=>Math.max(o(l,d),-s(l,d))))}function kr(a,e,t){return t&&(e/=Math.SQRT2),De(a,((r,n)=>{let i=r-.5*a+.25,s=.5*a-n-.75;if(t){const o=(i+s)/Math.SQRT2;s=(s-i)/Math.SQRT2,i=o}return Math.max(Math.abs(i),Math.abs(s))-.5*e}))}function Gr(a,e,t,r=0){e-=r,t&&(e*=Math.SQRT2);const n=.5*e;return De(a,((i,s)=>{let o,l=i-.5*a,d=.5*a-s-1;if(t){const u=(l+d)/Math.SQRT2;d=(d-l)/Math.SQRT2,l=u}return l=Math.abs(l),d=Math.abs(d),o=l>d?l>n?Math.sqrt((l-n)*(l-n)+d*d):d:d>n?Math.sqrt(l*l+(d-n)*(d-n)):l,o-=r/2,o}))}function Hr(a,e,t){return(r,n)=>{const i=r-a,s=n-e;return Math.sqrt(i*i+s*s)-t}}function qr(a,e,t){const r=Math.sqrt(e*e+t*t);return(n,i)=>{const s=Math.abs(n-a)-t,o=i-a+e/2+.75,l=(e*s+t*o)/r,d=-o;return Math.max(l,d)}}function De(a,e){const t=new Uint8Array(4*a*a);for(let r=0;r<a;r++)for(let n=0;n<a;n++){const i=n+a*r;let s=e(n,r);s=s/a+.5,ka(s,t,4*i)}return t}let vt=class{constructor(e,t){this._context=null,this._symbolLayer=null,this._draped=!1,this._loaded=!1,this._loadingPromise=null,this._iconTextureID=null,this._materialId=null,this._context=t,this._symbolLayer=e}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}_destroy(){this._iconTextureID=null}async _load(){const e=this._context.renderCommandContext,t=await e.createTexture((()=>wi("circle")));this._iconTextureID=t;const r={anchorPosition:bi.center,occlusionTest:!0,hasSlicePlane:!1,color:this._getFillColor(),outlineColor:this._getOutlineColor(),outlineSize:1,distanceFieldBoundingBox:Ci,textureId:t,textureIsSignedDistanceField:!0,sampleSignedDistanceFieldTexelCenter:xi("circle")};this._materialId=await e.createMaterial({type:"hud",parameters:r}),await e.createDirectRenderer(this._materialId),this._loaded=!0}async createAddCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:n}=r;if(t==null)throw new Error("expected material not to be null");const i=await this._createGeometry(e);if(i==null)return r.createPipelineCommand();const s=ir(e,r);return r.createPipelineCommand(n.addDirectRendererGeometry(e.id,i,s))}async _createGeometry(e){const{_materialId:t,_context:r}=this,{mainThreadDelegate:n}=r,{featureCount:i}=e;if(i===0||t==null)return null;const s=Ft(e),o=bt(e),l=await n.applyElevationAlignmentTo(o),d=vi(l,r),u=new Float64Array([0,0,1]),c=new Float64Array([255,255,255,255]),f=new Float64Array([24,24]),g=new Float64Array([0,0,0,1]),b=new Float64Array([0,0]),x=new Float64Array([0]),v=new Uint32Array(i);for(let P=0;P<i;++P)v[P]=P;const h=new Uint32Array(i);for(let P=0;P<i;++P)h[P]=0;const p=new G(d,v,3,!0),w=new G(u,h,3,!0),I=new G(b,h,2,!0),m=new G(c,h,4,!0),E=new G(x,h,1,!0),M=new G(f,h,2,!0),C=new G(g,h,4,!0),j=[[y.POSITION,p],[y.NORMAL,w],[y.UV0,I],[y.COLOR,m],[y.ROTATION,E],[y.SIZE,M],[y.CENTEROFFSETANDDISTANCE,C]],$=new Uint8Array(i);return e.getVisibilityArray($),{attributes:Vr(j),objectAndLayerIdColor:void 0,transformation:we(),materialId:t,objectIds:s,visibilities:$}}async createRemoveCommand(e){const{_materialId:t,_context:r}=this,n=r.renderCommandContext;return t==null?r.createPipelineCommand():r.createPipelineCommand(n.removeDirectRendererGeometryBuffer(t,e))}async createUpdateVisibilityCommand(e){const{_materialId:t,_context:r}=this,n=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const i=new Uint8Array(e.featureCount);return e.getVisibilityArray(i),r.createPipelineCommand(n.updateVisibility(t,e.id,i))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_materialId:r}=this,n=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(n.updateMaterial({type:"hud",materialId:r,parameters:{color:this._getFillColor(),outlineColor:this._getOutlineColor()}}))}async createUpdateElevationCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:n}=r,{featureCount:i,id:s}=e;if(t==null||i===0)return r.createPipelineCommand();const o=await this._createGeometry(e);if(o==null)return r.createPipelineCommand();const l=ir(e,r);return r.createPipelineCommand(n.updateDirectRendererGeometry(s,o,l))}async createDestroyCommand(){const{_iconTextureID:e,_context:t}=this,r=t.renderCommandContext;let n;return n=e!=null?await r.releaseTexture(e):W.create(r),n.appendPipelineStateCommand((()=>this._destroy())),n}_getOutlineColor(){var n;const e=this._getLayerOpacity(),t=this._symbolLayer,r=(n=t==null?void 0:t.outline)==null?void 0:n.color;if(r!=null){const i=ft.toUnitRGB(r),s=r.a*e;return[i[0],i[1],i[2],s]}return[0,0,0,0]}_getFillColor(){var r,n;if(Ei(this._getPrimitive()))return Di;const e=this._getPrimitive()==null,t=(n=(r=this._symbolLayer)==null?void 0:r.material)==null?void 0:n.color;return this._getCombinedOpacityAndColor(t,{hasIntrinsicColor:e})}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}_getCombinedOpacity(e,t=sr){const r=this._draped?1:this._getLayerOpacity();return e?r*e.a:t.hasIntrinsicColor?r:0}_getCombinedOpacityAndColor(e,t=sr){const r=this._getCombinedOpacity(e,t),n=e!=null?ft.toUnitRGB(e):qe;return yi(n,r)}_getPrimitive(){return Fi(this._symbolLayer)}};function Ei(a){return a!=null&&(a==="cross"||a==="x")}function Fi(a){var e,t;return(e=a.resource)!=null&&e.href?null:((t=a.resource)==null?void 0:t.primitive)??ln}const sr={hasIntrinsicColor:!1},Di=vr;let Mi=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._context=null,this._symbol=null,this._symbolLayerRenderers=[],this._context=t,this._symbol=e}_destroy(){}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_context:e,_symbol:t,_symbolLayerRenderers:r}=this,n=[];for(const i of t.symbolLayers){const s=e.symbolRendererFactory.createSymbolRendererFromSymbolLayer(i);s!=null&&(n.push(s.load()),r.push(s))}await Promise.all(n),this._loaded=!0}async createDestroyCommand(){const{_context:e,_symbolLayerRenderers:t}=this,r=[];for(const i of t)r.push(i.createDestroyCommand());const n=e.joinPipelineCommands(await Promise.all(r));return n.appendPipelineStateCommand((()=>this._destroy())),n}async createAddCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createAddCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createRemoveCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createRemoveCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateVisibilityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateVisibilityCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateLayerViewOpacityCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateElevationCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateElevationCommand(e));return t.joinPipelineCommands(await Promise.all(n))}},zi=class{constructor(e,t){this._symbol=null,this._featureData=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_renderer:e,_context:t}=this;this._symbol=t.symbolRendererFactory.createSymbolRendererFromSymbol(e.symbol),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=await this._provisionSymbol(),n=r==null?t.createPipelineCommand():await r.createAddCommand(e);return n.appendPipelineStateCommand((()=>this._featureData.set(e.id,e))),n}async createRemoveCommand(e){const t=this._context,r=await this._provisionSymbol(),n=r==null?t.createPipelineCommand():await r.createRemoveCommand(e);return n.appendPipelineStateCommand((()=>this._featureData.delete(e))),n}async createUpdateVisibilityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateVisibilityCommand(e)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateLayerViewOpacityCommand(e)}async createUpdateElevationCommand(){const{_featureData:e,_context:t}=this,r=await this._provisionSymbol();if(r==null)return t.createPipelineCommand();const n=[];for(const s of e.values())n.push(r.createUpdateElevationCommand(s));const i=await Promise.all(n);return t.joinPipelineCommands(i)}async createDestroyCommand(){const{_symbol:e,_context:t,_featureData:r}=this;if(!e)return t.createPipelineCommand();const n=[];for(const s of r.keys())n.push(this.createRemoveCommand(s));n.push(e.createDestroyCommand());const i=await Promise.all(n);return t.joinPipelineCommands(i)}async _provisionSymbol(){const e=this._symbol;return e?(e.loaded||await e.load(),e):null}};var Ct;(function(a){function e(s,o){const l=s[o],d=s[o+1],u=s[o+2];return Math.sqrt(l*l+d*d+u*u)}function t(s,o){const l=s[o],d=s[o+1],u=s[o+2],c=1/Math.sqrt(l*l+d*d+u*u);s[o]*=c,s[o+1]*=c,s[o+2]*=c}function r(s,o,l){s[o]*=l,s[o+1]*=l,s[o+2]*=l}function n(s,o,l,d,u,c=o){(u=u||s)[c]=s[o]+l[d],u[c+1]=s[o+1]+l[d+1],u[c+2]=s[o+2]+l[d+2]}function i(s,o,l,d,u,c=o){(u=u||s)[c]=s[o]-l[d],u[c+1]=s[o+1]-l[d+1],u[c+2]=s[o+2]-l[d+2]}a.length=e,a.normalize=t,a.scale=r,a.add=n,a.subtract=i})(Ct||(Ct={}));const ie=Ct,ji=new Array(36);for(let a=0;a<6;a++)for(let e=0;e<6;e++)ji[6*a+e]=a;const se=new Array(36);for(let a=0;a<6;a++)se[6*a]=0,se[6*a+1]=1,se[6*a+2]=2,se[6*a+3]=2,se[6*a+4]=3,se[6*a+5]=0;const st=q(-.5,0,-.5),ot=q(.5,0,-.5),lt=q(0,0,.5),ct=q(0,.5,0),oe=Fe(),le=Fe(),_e=Fe(),be=Fe(),ve=Fe();J(oe,st,ct),J(le,st,ot),nt(_e,oe,le),ge(_e,_e),J(oe,ot,ct),J(le,ot,lt),nt(be,oe,le),ge(be,be),J(oe,lt,ct),J(le,lt,st),nt(ve,oe,le),ge(ve,ve);_e[0],_e[1],_e[2],be[0],be[1],be[2],ve[0],ve[1],ve[2];function Li(a,e,t){let r,n;r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],n=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];for(let l=0;l<r.length;l+=3)ie.scale(r,l,a/ie.length(r,l));let i={};function s(l,d){l>d&&([l,d]=[d,l]);const u=l.toString()+"."+d.toString();if(i[u])return i[u];let c=r.length;return r.length+=3,ie.add(r,3*l,r,3*d,r,c),ie.scale(r,c,a/ie.length(r,c)),c/=3,i[u]=c,c}for(let l=0;l<e;l++){const d=n.length,u=new Array(4*d);for(let c=0;c<d;c+=3){const f=n[c],g=n[c+1],b=n[c+2],x=s(f,g),v=s(g,b),h=s(b,f),p=4*c;u[p]=f,u[p+1]=x,u[p+2]=h,u[p+3]=g,u[p+4]=v,u[p+5]=x,u[p+6]=b,u[p+7]=h,u[p+8]=v,u[p+9]=x,u[p+10]=v,u[p+11]=h}n=u,i={}}const o=kt(r);for(let l=0;l<o.length;l+=3)ie.normalize(o,l);return[[y.POSITION,new G(kt(r),n,3,!0)],[y.NORMAL,new G(o,n,3,!0)]]}function Bi(a,e,t,r,n=!0,i=!0){let s=0;const o=e,l=a;let d=q(0,s,0),u=q(0,s+l,0),c=q(0,-1,0),f=q(0,1,0);const g=[u,d],b=[c,f],x=t+2,v=Math.sqrt(l*l+o*o);for(let m=0;m<t;m++){const E=m*(2*Math.PI/t),M=q(Math.cos(E)*o,s,Math.sin(E)*o);g.push(M);const C=q(l*Math.cos(E)/v,o/v,l*Math.sin(E)/v);b.push(C)}const h=new Array,p=new Array;if(n){for(let m=3;m<g.length;m++)h.push(1),h.push(m-1),h.push(m),p.push(0),p.push(0),p.push(0);h.push(g.length-1),h.push(2),h.push(1),p.push(0),p.push(0),p.push(0)}if(i){for(let m=3;m<g.length;m++)h.push(m),h.push(m-1),h.push(0),p.push(m),p.push(m-1),p.push(1);h.push(0),h.push(2),h.push(g.length-1),p.push(1),p.push(2),p.push(b.length-1)}const w=Gt(3*x);for(let m=0;m<x;m++)w[3*m]=g[m][0],w[3*m+1]=g[m][1],w[3*m+2]=g[m][2];const I=Gt(3*x);for(let m=0;m<x;m++)I[3*m]=b[m][0],I[3*m+1]=b[m][1],I[3*m+2]=b[m][2];return[[y.POSITION,new G(w,h,3,!0)],[y.NORMAL,new G(I,p,3,!0)]]}function Ui(a){switch(a){case"sphere":case"cube":case"diamond":case"cylinder":case"cone":case"inverted-cone":case"tetrahedron":return!0}return!1}function Vi(a,e){const t=(r,n,i=!1)=>({levels:r.map((s=>{const o=Vr(n(s.tesselation));return i&&Ni(o),{components:[{attributes:o,objectAndLayerIdColor:void 0,transformation:null,materialId:e,visibilities:new Uint8Array([1]),objectIds:new Uint32Array([-1])}],minScreenSpaceRadius:s.minScreenSpaceRadius}}))});switch(a){case"cone":return t(ki,(r=>Bi(1,.5,r)),!0);case"sphere":return t([{tesselation:0,minScreenSpaceRadius:0},{tesselation:1,minScreenSpaceRadius:8},{tesselation:2,minScreenSpaceRadius:16},{tesselation:3,minScreenSpaceRadius:50},{tesselation:4,minScreenSpaceRadius:250}],(r=>Li(.5,r)));case"cube":case"inverted-cone":case"cylinder":case"tetrahedron":case"diamond":throw new Error("not implemented");default:return}}function Ni(a){const e=a,t=e.get(y.POSITION).data,r=e.get(y.NORMAL).data;if(r){const n=or(a,y.NORMAL).data;for(let i=0;i<r.length;i+=3){const s=r[i+1];n[i+1]=-r[i+2],n[i+2]=s}}if(t){const n=or(a,y.POSITION).data;for(let i=0;i<t.length;i+=3){const s=t[i+1];n[i+1]=-t[i+2],n[i+2]=s}}}function or(a,e){let t=a.get(e);return t&&!t.exclusive&&(t={...t,exclusive:!0,data:Zn(t.data)},a.set(e,t)),t}const ki=[{tesselation:6,minScreenSpaceRadius:0},{tesselation:18,minScreenSpaceRadius:7},{tesselation:64,minScreenSpaceRadius:65}];let Gi=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._primitiveMaterialId=null,this._lodRendererId=null,this._context=null,this._symbolLayer=null,this._primitive=null,this._context=t,this._symbolLayer=e}_destroy(){this._lodRendererId=null,this._primitiveMaterialId=null}get loaded(){return this._loaded}get _isPrimitive(){return this._primitive!=null}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const e=this._context.renderCommandContext,t={physicalBasedRenderingEnabled:!0,slicePlaneEnabled:!1,castShadows:!0},r=this._getLayerOpacity();let n={usePBR:t.physicalBasedRenderingEnabled,isSchematic:!0,mrrFactors:Kn,ambient:qe,diffuse:qe,hasSlicePlane:t.slicePlaneEnabled,castShadows:t.castShadows,layerOpacity:r,offsetTransparentBackfaces:!1,screenSizePerspective:{}};if(n.externalColor=br,n.isInstanced=!0,this._isPrimitive){const l=new Ht;l.layerOpacity=r,n={...n,cullFace:lr(qt(l))}}const i=await e.createMaterial({type:"default",parameters:n}),s=this._symbolLayer.resource;this._primitive=s&&Ui(s==null?void 0:s.primitive)?s.primitive:zt;const o=Vi(this._primitive,i);this._lodRendererId=await e.createLodRenderer(o),this._primitiveMaterialId=i,this._loaded=!0}async createDestroyCommand(){const{_lodRendererId:e,_primitiveMaterialId:t,_context:r}=this,n=r.renderCommandContext,i=[];return e!=null&&i.push(n.destroyLodRenderer(e)),t!=null&&i.push(n.destroyMaterial(t)),new W(n,n.mergeRenderCommandBuffers(i),[()=>this._destroy()])}async createAddCommand(e){const t=this._context,{renderCommandContext:r,mainThreadDelegate:n}=t;if(this._lodRendererId==null)throw new Error("expected lod renderer id to not be null");const{featureCount:i}=e;if(i===0)return t.createPipelineCommand();const s=this._isPrimitive,o=this._primitive||zt,l=cn(dn(o)),d=ht(un(l)),u=ht(fn(d,{isPrimitive:s,width:100,depth:null,height:null})),c=new Float64Array(16*i),f=new Float64Array(16*i),g=bt(e),b=await n.applyElevationAlignmentTo(g);for(let p=0;p<i;++p){const w=p,I=b[3*p+0],m=b[3*p+1],E=b[3*p+2],M=this._computeGlobalTransform(I,m,E,this._context.viewSpatialReference,cr),C=this._computeLocalTransform(u,d,Hi);this._writeMatrixToTypedBuffer(c,w,C),this._writeMatrixToTypedBuffer(f,w,M)}const x=Ft(e),v=new Uint8Array(i);e.getVisibilityArray(v);const h={featureIds:new Uint32Array(x),visibility:v,localTransforms:c,globalTransforms:f};return t.createPipelineCommand(r.addLodInstances(this._lodRendererId,e.id,h))}async createRemoveCommand(e){const{_context:t,_lodRendererId:r}=this,n=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(n.removeLodInstances(r,e))}async createUpdateVisibilityCommand(e){const{_lodRendererId:t,_context:r}=this,n=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const i=new Uint8Array(e.featureCount);return e.getVisibilityArray(i),r.createPipelineCommand(n.updateVisibility(t,e.id,i))}async createUpdateLayerViewOpacityCommand(e){const{_context:t}=this,r=t.renderCommandContext,n=this._primitiveMaterialId;if(n==null)return t.createPipelineCommand();const i=this._getLayerOpacity();let s={layerOpacity:i};if(this._isPrimitive){const o=new Ht;o.layerOpacity=i,s={...s,cullFace:lr(qt(o))}}return t.createPipelineCommand(r.updateMaterial({type:"default",materialId:n,parameters:s}))}async createUpdateElevationCommand(e){const{_context:t,_lodRendererId:r}=this,{renderCommandContext:n,mainThreadDelegate:i}=t,{featureCount:s,id:o}=e;if(r==null||s===0)return t.createPipelineCommand();const l=new Float64Array(16*s),d=bt(e),u=await i.applyElevationAlignmentTo(d);for(let c=0;c<s;++c){const f=c,g=u[3*c+0],b=u[3*c+1],x=u[3*c+2],v=this._computeGlobalTransform(g,b,x,this._context.viewSpatialReference,cr);this._writeMatrixToTypedBuffer(l,f,v)}return t.createPipelineCommand(n.updateLodInstancesData(r,o,l))}_writeMatrixToTypedBuffer(e,t,r){let n=16*t;for(let i=0;i<16;i++)e[n++]=r[i]}_computeGlobalTransform(e,t,r,n,i){return je[0]=e,je[1]=t,je[2]=r,Ha(n,je,i,this._context.renderSpatialReference),i}_computeLocalTransform(e,t,r){return hn(r),this._applyObjectScale(e,t,r),r}_applyObjectScale(e,t,r){const n=_i(e,e,t,this._context.renderCoordsHelper.unitInMeters);n[0]===1&&n[1]===1&&n[2]===1||mn(r,r,n)}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}};function lr(a){return a?er.None:er.Back}const je=U(),Hi=we(),cr=we();let qi=class{constructor(e,t){this._symbols=new Array,this._featureDataPartitioning=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){this._symbols[0]=new vt(Ur(),this._context),this._symbols[1]=new Gi(gi(),this._context),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=this._partition(e),n=await Promise.all(r.map((async({index:s,features:o})=>{const l=await this._provisionSymbol(s);return await(l==null?void 0:l.createAddCommand(o))}))),i=t.joinPipelineCommands(n);return i.appendPipelineStateCommand((()=>this._featureDataPartitioning.set(e.id,r))),i}async createRemoveCommand(e){const{_featureDataPartitioning:t,_context:r}=this,n=r.renderCommandContext,i=t.get(e);if(i==null)return new W(n,n.createRenderCommandBuffer(),[]);const s=await Promise.all(i.map((async({index:l,features:d})=>{const u=this._getLoadedSymbol(l);return await(u==null?void 0:u.createRemoveCommand(d.id))}))),o=r.joinPipelineCommands(s);return o.appendPipelineStateCommand((()=>t.delete(e))),o}async createUpdateVisibilityCommand(e){const{_featureDataPartitioning:t,_context:r}=this,n=r.renderCommandContext,i=t.get(e.id);if(i==null)return new W(n,n.createRenderCommandBuffer(),[]);const s=await Promise.all(i.map((async({index:o,features:l})=>{const d=this._getLoadedSymbol(o);return await(d==null?void 0:d.createUpdateVisibilityCommand(l))})));return r.joinPipelineCommands(s)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=[];for(let i=0;i<this._symbols.length;++i){const s=this._symbols[i];s!=null&&s.loaded&&r.push(s.createUpdateLayerViewOpacityCommand(e))}const n=await Promise.all(r);return t.joinPipelineCommands(n)}async createUpdateElevationCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const i of e.values()){const s=i.map((async({index:o,features:l})=>{const d=this._getLoadedSymbol(o);return await(d==null?void 0:d.createUpdateElevationCommand(l))}));r.push(...s)}const n=await Promise.all(r);return t.joinPipelineCommands(n)}async createDestroyCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const i of e.keys())r.push(this.createRemoveCommand(i));for(const i of this._symbols)r.push(i.createDestroyCommand());const n=await Promise.all(r);return t.joinPipelineCommands(n)}async _provisionSymbol(e){if(e==null)return null;const t=this._symbols[e];return t?(t.loaded||await t.load(),t):null}_getLoadedSymbol(e){if(e==null)return null;const t=this._symbols[e];return t!=null&&t.loaded?t:null}_partition(e){const t=Ft(e);if(t==null)throw new Error("unable to fetch objectIds");const{featureCount:r}=e,n=[[],[]];for(let i=0;i<r;++i)n[t[i]%2].push(i);return n.map(((i,s)=>new Qi(s,e.subset(new Uint32Array(i))))).filter((i=>i.features.featureCount>0))}},Qi=class{constructor(e,t){this.index=e,this.features=t}},Wi=class{constructor(e,t,r,n,i,s,o){this.viewSpatialReference=e,this.renderSpatialReference=t,this.mainThreadDelegate=r,this.renderCoordsHelper=n,this.renderCommandContext=i,this.layerInfo=s,this.layerViewInfo=o,this.symbolRendererFactory=new Xi(this)}createPipelineCommand(e=this.renderCommandContext.createRenderCommandBuffer(),t=[]){return new W(this.renderCommandContext,e,t)}joinPipelineCommands(e){return e.length===0?this.createPipelineCommand():e.filter((t=>t!=null)).reduce(((t,r)=>(t.append(r),t)))}},Xi=class{constructor(e){this.context=e}createSymbolRendererFromJSON(e){const t=pn(e??dr)??void 0;if(!t)throw new Error("Failed to create renderer");const r=t.type;switch(r){case"simple":return new zi(t,this.context);case"unique-value":return new qi(t,this.context);default:return console.warn(`Unable to create symbolrenderer for renderer of ${r}`),this.createSymbolRendererFromJSON(dr)}}createSymbolRendererFromSymbol(e){const t=e==null?void 0:e.type;switch(t){case"point-3d":return new Mi(e,this.context);case"picture-marker":case"simple-marker":return new vt(Ur(),this.context);default:return console.warn(`Unable to create symbolrenderer for symbol of ${t}`),null}}createSymbolRendererFromSymbolLayer(e){const t=e.type;return t==="icon"?new vt(e,this.context):(console.warn(`Unable to create symbolrenderer for symbolLayer of ${t}`),null)}};const dr={type:"simple"};function Xe(a=""){return`${a}${gn()}`}let Yi=class Qr{constructor(e,t){this._parent=e,this._subsetIndices=t,this.id=Xe(`featureDataSubset-${e.id}-`)}get tileId(){return this._parent.tileId}get extent(){return this._parent.extent}get featureCount(){return this._subsetIndices.length}get usedMemory(){return this._parent.usedMemory+xe+this._subsetIndices.byteLength}get isFullyEnabled(){for(const e of this._subsetIndices)if(!this._parent.getEnabled(e))return!1;return!0}getObjectId(e){return this._parent.getObjectId(this._subsetIndices[e])}getAttribute(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributeAsTimestamp(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributes(e){return this._parent.getAttributes(this._subsetIndices[e])}getCoordinates(e,t,r){return this._parent.getCoordinates(this._subsetIndices[e],t,r)}getOptimizedGeometry(e){return this._parent.getOptimizedGeometry(this._subsetIndices[e])}getCentroid(e,t){return this._parent.getCentroid(this._subsetIndices[e],t)}getBounds(e){return this._parent.getBounds(this._subsetIndices[e])}getBoundingBox(e){return this._parent.getBoundingBox(this._subsetIndices[e])}getObjectIdsArray(e,t,r){return this._parent.getObjectIdsArray(e,this._translatedIndices(t),r)}getCoordinatesArray(e,t,r){return this._parent.getCoordinatesArray(e,this._translatedIndices(t),r)}objectIds(e){return this._parent.objectIds(this._translatedIndices(e))}subset(e){const{_subsetIndices:t}=this,r=new Uint32Array(e.length);for(let n=0;n<r.length;++n)r[n]=t[e[n]];return new Qr(this._parent,r)}disableObjectIds(e){if(e.size===0)return;const{featureCount:t}=this,r=new Array;for(let n=0;n<t;++n)this.getEnabled(n)&&e.has(this.getObjectId(n))&&r.push(n);if(r.length!==0)for(const n of r)this.setEnabled(n,!1)}setEnabled(e,t){this._parent.setEnabled(this._subsetIndices[e],t)}getEnabled(e){return this._parent.getEnabled(this._subsetIndices[e])}enableAll(){const{_subsetIndices:e,_parent:t}=this;for(const r of e)t.setEnabled(r,!0)}getVisibilityArray(e,t,r){return this._parent.getVisibilityArray(e,this._translatedIndices(t),r)}enabledObjectIds(e){return this._parent.enabledObjectIds(this._translatedIndices(e))}*_translatedIndices(e){const{_subsetIndices:t}=this;if(e!=null)for(const r of e)yield t[r];else yield*t}};class Ji{constructor(e){this._tile=e,this.id=Xe(`featureData-${e.id}-`),this._enabled=new Array(e.featureCount).fill(!0)}get tileId(){return this._tile.id}get featureCount(){return this._tile.featureCount}get usedMemory(){return xe+Ya(this.id)}get extent(){return this._tile.descriptor.extent}get isFullyEnabled(){return this._enabled.every((e=>e))}getObjectId(e){return this._tile.getObjectId(e)}getAttribute(e,t){return this._tile.getAttribute(e,t)}getAttributeAsTimestamp(e,t){return this._tile.getAttribute(e,t)}getAttributes(e){return this._tile.getAttributes(e)}getCoordinates(e,t,r){return this._tile.getCoordinates(e,t,r)}getOptimizedGeometry(e){return this._tile.getOptimizedGeometry(e)}getCentroid(e,t){return this._tile.getCentroid(e,t)}getBounds(e){return this._tile.getBounds(e)}getBoundingBox(e){return this._tile.getBoundingBox(e)}getObjectIdsArray(e,t,r){return this._tile.getObjectIdsArray(e,t,r)}getCoordinatesArray(e,t,r){return this._tile.getCoordinatesArray(e,t,r)}objectIds(e){return this._tile.objectIds(e)}subset(e){return new Yi(this,e)}disableObjectIds(e){if(e.size===0)return;const{_enabled:t}=this,r=new Array;for(const n of this._allFeatureIndices())t[n]&&e.has(this.getObjectId(n))&&r.push(n);if(r.length!==0)for(const n of r)t[n]=!1}setEnabled(e,t){this._enabled[e]=t}getEnabled(e){return this._enabled[e]}enableAll(){this._enabled.fill(!0)}getVisibilityArray(e,t=this._allFeatureIndices(),r=0){const{_enabled:n}=this;for(const i of t)e[r++]=Number(n[i]);return r}*enabledObjectIds(e=this._allFeatureIndices()){const{_enabled:t}=this;for(const r of e)t[r]&&(yield this.getObjectId(r))}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}}let B=class extends yn{constructor(e){super(e),this.extent=null,this._tileHandles=new tr,this._wanted=new tr,this._updateRequested=!1,this._synchronizationTask=null,this._requestedTiles=new Array}destroy(){this._tileHandles.clear(),this._wanted.clear()}get updating(){var e;return this._updateRequested||!(((e=this._synchronizationTask)==null?void 0:e.finished)??1)}get _boundingRect(){const{extent:e}=this;return e==null?null:_n(e)}get _missingTiles(){var n;const e=new Array,t=this._wanted,r=this._tileHandles;for(const i of t.values())((n=r.get(i.id))==null?void 0:n.featureData)==null&&e.push(i);return e}onTileTreeChange({tiles:e}){this._requestedTiles=e,this._scheduleTilesSync()}_scheduleTilesSync(){if(this._updateRequested)return;this._updateRequested=!0;const e=this._synchronizationTask,t=jt((async()=>{try{await bn((()=>(e==null?void 0:e.finished)??!0)),await vn(),this._updateRequested=!1,await this._synchronizeTiles()}finally{this._synchronizationTask===t&&(this._synchronizationTask=null)}}));this._synchronizationTask=t}async _synchronizeTiles(){const e=this._requestedTiles,t=this._tileHandles,r=new Array;for(const f of e)t.has(f.id)||r.push(f);const n=new Array;for(const f of t.values()){const{id:g}=f;e.every((b=>b.id!==g))&&n.push(f.descriptor)}const i=this._tileHandles,{_boundingRect:s}=this,o=s!=null?r.filter((f=>Cn(s,f.extent))):r,l=this._wanted,d=new Array;for(const{id:f}of n)l.delete(f);for(const f of o)l.set(f.id,f);const u=this._missingTiles;for(const f of n){const{id:g}=f;if(u.some((x=>ce(x,f)||ce(f,x))))continue;const b=i.get(g);b!=null&&d.push(this._removeTile(b))}for(const f of o)d.push(this._addTile(f));const c=await Promise.allSettled(d);for(const f of c)f.status==="rejected"&&console.error(f.reason)}forEachTile(e){for(const t of this._tileHandles.values()){const r=t.featureData;r!=null&&e(r)}}*loadedTiles(){for(const e of this._tileHandles.values()){const t=e.featureData;t!=null&&(yield t)}}async _removeTile(e){e.loadTask.abort(),this._tileHandles.delete(e.id),this._validate();const{featureData:t}=e;if(t!=null){const r={stack:[],error:void 0,hasError:!1};try{pt(r,await this.tileLocks.lock([t.tileId]),!1);const n=await this.createRemoveCommand(t.id);await(n==null?void 0:n.execute())}catch(n){r.error=n,r.hasError=!0}finally{gt(r)}}}async _addTile(e){const{_tileHandles:t}=this,r=t.get(e.id);if(r!=null)return!Ne(r)||r.featureData.isFullyEnabled?void 0:(r.featureData.enableAll(),void await this._onTileLoad(r));const n=new Zi(e,jt((async i=>{const s=await this.loadTile(e,i);return Te(i),new Ji(s)})));this._tileHandles.set(n.id,n);try{await n.loadTask.promise}catch(i){return void xn(i)}Ki(n),await this._onTileLoad(n)}async _onTileLoad(e){const t={stack:[],error:void 0,hasError:!1};try{const{_wanted:r,_tileHandles:n,_missingTiles:i}=this,s=e.descriptor,o=new Array,l=new Array,d=new Array,u=new Set;for(const h of n.values()){if(h===e)continue;const{descriptor:p,id:w}=h;if(r.has(w)||i.some((I=>ce(I,p)||ce(p,I)))){if(Ne(h)){if(ce(s,p)){const I=h.featureData;for(const m of I.objectIds())u.add(m)}if(ce(p,s)){const{featureData:I}=h;l.push(I)}}}else{n.delete(w),h.loadTask.abort();const{featureData:I}=h;I!=null&&o.push(I)}}u.size>0&&(e.featureData.disableObjectIds(u),this._validateRemoval(e.featureData,u)),this._validate(),d.push(e.featureData);const c=[...d,...o,...l].map((h=>h.tileId));if(pt(t,await this.tileLocks.lock(c),!1),l.length!==0){const h=e.featureData,p=new Set(h.objectIds());for(const w of l)w.disableObjectIds(p),this._validateRemoval(w,p)}const f=o.map((h=>this.createRemoveCommand(h.id))),g=d.map((h=>this.createAddCommand(h))),b=l.map((h=>this.createUpdateCommand(h))),x=await Promise.all([...f,...g,...b]),v=pi(x.filter(Cr));await(v==null?void 0:v.execute())}catch(r){t.error=r,t.hasError=!0}finally{gt(t)}}_validate(){if(!Lt("feature-pipeline-3d-test-validation"))return;const e=new Array;for(const t of this._tileHandles.values()){if(!Ne(t))continue;const{featureData:r}=t;e.push({featureData:r,objectIds:new Set(r.enabledObjectIds())})}for(let t=0;t<e.length;++t){const{featureData:r,objectIds:n}=e[t];for(let i=t+1;i<e.length;++i){const{featureData:s,objectIds:o}=e[i];for(const l of o)if(n.has(l))throw new Error(`${r.id} and ${s.id} both contain ${l}.`)}}}_validateRemoval(e,t){if(Lt("feature-pipeline-3d-test-validation")){for(const r of e.enabledObjectIds())if(t.has(r))throw new Error(`Failed to remove ${r} from ${e.id}!`)}}};function ce({lij:[a,e,t]},{lij:[r,n,i]}){const s=r-a;return s>=0&&e===n>>s&&t===i>>s}S([N()],B.prototype,"updating",null),S([N({constructOnly:!0})],B.prototype,"loadTile",void 0),S([N({constructOnly:!0})],B.prototype,"createAddCommand",void 0),S([N({constructOnly:!0})],B.prototype,"createRemoveCommand",void 0),S([N({constructOnly:!0})],B.prototype,"createUpdateCommand",void 0),S([N({constructOnly:!0})],B.prototype,"tileLocks",void 0),S([N()],B.prototype,"extent",void 0),S([N()],B.prototype,"_boundingRect",null),S([N()],B.prototype,"_missingTiles",null),S([N()],B.prototype,"_updateRequested",void 0),S([N()],B.prototype,"_synchronizationTask",void 0),B=S([xr("esri.views.3d.layers.graphics.pipeline.Tile3DManager")],B);class Zi{constructor(e,t){this.descriptor=e,this.loadTask=t}get id(){return this.descriptor.id}get featureData(){return this.loadTask.value}}function Ne(a){return a.featureData!=null}function Ki(a){if(!Ne(a))throw new Error}class es{constructor(){this._previousActions=new Map}async lock(e){const{_previousActions:t}=this,r=e.map((l=>t.get(l))).filter(Cr),n=Promise.allSettled(r),i=wn(),s=Sn((()=>i.resolve())),o=i.promise.finally((()=>{for(const l of e)t.get(l)===o&&t.delete(l)}));for(const l of e)t.set(l,o);return await n,In(s)}}let xt=class{constructor(e,t){this._index=e,this._view=t}get usedMemory(){return xe+Dr}getObjectId(){return this._view.getObjectId(this._index)}getAttribute(e){return this._view.getAttribute(this._index,e)}getAttributeAsTimestamp(e){return this._view.getAttributeAsTimestamp(this._index,e)}getAttributes(){return this._view.getAttributes(this._index)}getOptimizedGeometry(){return this._view.getOptimizedGeometry(this._index)}getCentroid(e){return this._view.getCentroid(this._index,e)}getBounds(){return this._view.getBounds(this._index)}getBoundingBox(){return this._view.getBoundingBox(this._index)}cloneWithGeometry(e){return new ts(this._index,this._view,e)}},ts=class extends xt{constructor(e,t,r){super(e,t),this._geometryOverride=r}getOptimizedGeometry(){return this._geometryOverride}getCentroid(e){return Ka(new _t,this._geometryOverride,e.hasZ,e.hasM)}},rs=class{constructor(e,t){this.featureData=e,this.bounds=t}},ns=class{constructor(){this._tileBounds=new Map,this.events=new wr,this.featureAdapter=as.shared}get usedMemory(){return xe+xe*this._tileBounds.size}addTile(e){const{featureCount:t}=e;if(t===0)return;const r=new Za(9,(i=>e.getBounds(i))),n=new Array;for(let i=0;i<t;++i)n[i]=i;r.load(n),this._tileBounds.set(e.id,new rs(e,r)),this.events.emit("changed")}removeTile(e){this._tileBounds.delete(e),this.events.emit("changed")}clear(){this._tileBounds.clear(),this.events.emit("changed")}forEach(e){for(const{featureData:t,bounds:r}of this._tileBounds.values())r.all((n=>{t.getEnabled(n)&&e(new xt(n,t))}))}forEachInBounds(e,t){Ie.minX=e[0],Ie.minY=e[1],Ie.maxX=e[2],Ie.maxY=e[3];for(const{featureData:r,bounds:n}of this._tileBounds.values())n.search(Ie,(i=>{r.getEnabled(i)&&t(new xt(i,r))}))}forEachBounds(e,t){for(const r of e)t(r.getBoundingBox())}getFullExtent(e){let t=1/0,r=1/0,n=-1/0,i=-1/0;for(const{bounds:s}of this._tileBounds.values()){const{minX:o,minY:l,maxX:d,maxY:u}=s.toJSON();t=Math.min(t,o),r=Math.min(r,l),n=Math.min(n,d),i=Math.min(i,u)}return{xmin:t,ymin:r,xmax:n,ymax:i,spatialReference:e}}};var ne;let as=(ne=class{getObjectId(e){return e.getObjectId()}getAttribute(e,t){return e.getAttribute(t)}getAttributeAsTimestamp(e,t){return e.getAttributeAsTimestamp(t)}getAttributes(e){return e.getAttributes()}getGeometry(e){return e.getOptimizedGeometry()}getCentroid(e,t){return e.getCentroid(t)}cloneWithGeometry(e,t){return e.cloneWithGeometry(t)}},ne.shared=new ne,ne);const Ie=new Mr;let is=class{constructor(e,t,r){this.descriptor=e,this._pages=t,this._pageSize=r;const n=Ja+t.reduce(((s,{usedMemory:o})=>s+o),0),i=3*Dr;this.usedMemory=xe+n+i,this.featureCount=t.reduce(((s,o)=>s+o.featureCount),0)}get id(){return this.descriptor.id}getObjectId(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getObjectId(r)}getAttribute(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getAttribute(n,t)}getAttributeAsTimestamp(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getAttributeAsTimestamp(n,t)}getAttributes(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getAttributes(r)}getCoordinates(e,t,r){const{pageIndex:n,featurePageIndex:i}=this._translateIndex(e);this._pages[n].getCoordinates(i,t,r)}getOptimizedGeometry(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getOptimizedGeometry(r)}getCentroid(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getCentroid(n,t)}getBounds(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBounds(r)}getBoundingBox(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBoundingBox(r)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){let n=r;for(const{page:i,indices:s}of this._batchPageIndices(t))n=i.getObjectIdsArray(e,s,n);return n}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){let n=r;for(const{page:i,indices:s}of this._batchPageIndices(t))n=i.getCoordinatesArray(e,s,n);return n}*objectIds(e=this._allFeatureIndices()){for(const{page:t,indices:r}of this._batchPageIndices(e))for(const n of t.objectIds(r))yield n}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_translateIndex(e){const{_pageSize:t}=this;return{pageIndex:Math.floor(e/t),featurePageIndex:e%t}}*_batchPageIndices(e){const t=new Array;{let n=0,i=new Array;for(const s of e){const{pageIndex:o,featurePageIndex:l}=this._translateIndex(s);n!==o&&(i.length!==0&&t.push({pageIndex:n,indices:i}),n=o,i=[]),i.push(l)}i.length!==0&&t.push({pageIndex:n,indices:i})}const{_pages:r}=this;for(const{pageIndex:n,indices:i}of t)yield{page:r[n],indices:i}}},ss=class{constructor(e){this._reader=new ti(new Uint8Array(e),new DataView(e)),this._index=os(this._reader)}get featureCount(){return this._index.featureIndices.length}get exceededTransferLimit(){return this._index.exceededTransferLimit}get usedMemory(){return this._reader.usedMemory}getObjectId(e){return this.getAttribute(e,this._index.objectIdFieldName)}getAttribute(e,t){var l;const{_index:{fieldsIndex:r,attributeIndices:n}}=this,i=(l=r.get(t))==null?void 0:l.index;if(i==null)return;const s=n[e*r.fields.length+i],o=this._reader;return o.move(s),Le(o)}getAttributeAsTimestamp(e,t){const r=this.getAttribute(e,t);return typeof r=="string"?new Date(r).getTime():typeof r=="number"||r==null?r:null}getAttributes(e){const{_index:{fieldsIndex:t,attributeIndices:r}}=this,n=e*t.fields.length,i=this._reader,s={};for(const o of t.fields){const l=r[n+o.index];i.move(l),s[o.name]=Le(i)}return s}getCoordinates(e,t,r=0){const n=this._reader,{transform:i,featureIndices:s}=this._index,{scale:o,translate:l}=i;n.move(s[e]),this._readCoordinates(o,l,t,r)}getOptimizedGeometry(e){const t=U();return this.getCoordinates(e,t),new _t([],t)}getCentroid(e,{hasZ:t,hasM:r}){this.getCoordinates(e,de);const[n,i,s]=de,o=[n,i];return t&&(o[3]=s),r&&(o[t?4:3]=0),new _t([],o)}getBounds(e){this.getCoordinates(e,de);const[t,r]=de,n=new Mr;return n.minX=t,n.minY=r,n.maxX=t,n.maxY=r,n}getBoundingBox(e){this.getCoordinates(e,de);const[t,r,n]=de;return An(t,r,n,t,r,n)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){const n=this._reader,{objectIdFieldName:i,attributeIndices:s,fieldsIndex:o}=this._index,l=o.get(i).index,d=o.fields.length;for(const u of t){const c=s[u*d+l];n.move(c),e[r++]=Le(n)}return r}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){const n=this._reader,{transform:i,featureIndices:s}=this._index,{scale:o,translate:l}=i;for(const d of t){const u=s[d];n.move(u),r=this._readCoordinates(o,l,e,r)}return r}*objectIds(e=this._allFeatureIndices()){const t=this._reader,{objectIdFieldName:r,attributeIndices:n,fieldsIndex:i}=this._index,s=i.get(r).index,o=i.fields.length;for(const l of e){const d=n[l*o+s];t.move(d),yield Le(t)}}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_readCoordinates([e,t,r],[n,i,s],o,l){const c=this._reader,f=c.getLength(),g=c.pos()+f;for(;c.pos()<g&&c.next();)switch(c.tag()){case 2:{const b=c.getLength(),x=c.pos()+b;for(;c.pos()<x&&c.next();)c.tag()===3?(c.getUInt32(),o[l++]=n+e*c.getSInt64(),o[l++]=i+t*c.getSInt64(),o[l++]=s+r*c.getSInt64()):c.skip();break}default:c.skip()}return l}};function os(a){for(;a.next();){if(a.tag()===2)return ls(a.getMessage());a.skip()}Ye()}function ls(a){for(;a.next();){if(a.tag()===1)return cs(a.getMessage());a.skip()}Ye()}function cs(a){let u,c,f=!1,g=!1,b=0;const x=new Array,v=new Array,h=new Array;for(;a.next();)switch(a.tag()){case 1:c=a.getString();break;case 7:a.getEnum()!==0&&Ye();break;case 9:f=a.getBool()??!1;break;case 12:u=ri(a.processMessage(ai));break;case 13:{const w=a.processMessage(ni);w.index=b++,x.push(w);break}case 15:{v.push(a.pos());const w=a.getUInt32(),I=a.pos()+w;for(;a.pos()<I&&a.next();)a.tag()===1&&h.push(a.pos()),a.skip();break}case 10:g=a.getBool()??!1;break;default:a.skip()}const p=new $n(x);return u!=null&&g&&c!=null&&p.has(c)||Ye(),{transform:u,exceededTransferLimit:f,fieldsIndex:p,objectIdFieldName:c,featureIndices:v,attributeIndices:h}}function Ye(){const a=new On("pbf-parsing-failed","Error while parsing PBF",new Error);throw console.error(a),a}function Le(a){const u=a.getLength(),c=a.pos()+u;for(;a.pos()<c&&a.next();)switch(a.tag()){case 1:return a.getString();case 2:return a.getFloat();case 3:return a.getDouble();case 4:return a.getSInt32();case 5:return a.getUInt32();case 6:return a.getInt64();case 7:return a.getUInt64();case 8:return a.getSInt64();case 9:return a.getBool();default:return a.skip(),null}return null}const de=U(),ur=8e3,ds=4,us=4;let fs=class{constructor(e,t,r,n,i){this.spatialReference=e,this.url=r,this.objectIdField=n,this.capabilities=i;const{supportsMaxRecordCountFactor:s,maxRecordCount:o}=this.capabilities.query,l=s?ds:1,d=(o??ur)*l;this._pageSize=Math.min(ur,d);const u=t.clone();u.cacheHint=!0,u.resultType="tile",u.outSpatialReference=e,u.returnGeometry=!0,u.returnZ=!0,u.maxRecordCountFactor=l,u.num=this._pageSize,u.outFields=[n],this._baseQuery=u}async fetch(e,t){const{spatialReference:r,_pageSize:n}=this,i=Pn(e.extent,r),s=this._baseQuery.clone();s.geometry=i;const o=new Array;let l=0,d=!1,u=1;for(;!d;){const c=[];for(let g=0;g<u;++g)c.push(this._fetchPage(s,l++,t));const f=await Promise.all(c);Te(t);for(const g of f){const b=g.featureCount!==0;d||(d=!g.exceededTransferLimit||!b),b&&o.push(g)}u=Math.min(u+1,us)}return new is(e,o,n)}async _fetchPage(e,t,r){const n=e.clone();n.start=t*this._pageSize;const i=(await ei(this.url,n,{signal:r})).data;return Te(r),new ss(i)}};function hs(a){return a instanceof Float32Array&&a.length>=16}function ms(a){return Array.isArray(a)&&a.length>=16}function ps(a){return hs(a)||ms(a)}const Wr=.5;function gs(a,e){a.include($r),a.attributes.add(y.POSITION,"vec3"),a.attributes.add(y.NORMAL,"vec3"),a.attributes.add(y.CENTEROFFSETANDDISTANCE,"vec4");const t=a.vertex;ea(t,e),ta(t,e),t.uniforms.add(new Et("viewport",(r=>r.camera.fullViewport)),new yt("polygonOffset",(r=>r.shaderPolygonOffset)),new Qe("cameraGroundRelative",(r=>r.camera.aboveGround?1:-1))),e.hasVerticalOffset&&ra(t),t.code.add(_`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),t.code.add(_`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.terrainDepthTest?_.float(0):_`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||na(t),e.draped||(t.uniforms.add(new Qe("perDistancePixelRatio",(r=>Math.tan(r.camera.fovY/2)/(r.camera.fullViewport[2]/2)))),t.code.add(_`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${_.float(Wr)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&Pr(t),e.hasScreenSizePerspective&&Tr(t),t.code.add(_`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?_`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":_`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}let ys=class{constructor(){this.factor=new fr,this.factorAlignment=new fr}},fr=class{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}};function Dt(a){a.uniforms.add(new aa("alignPixelEnabled",(e=>e.alignPixelEnabled))),a.code.add(_`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),a.code.add(_`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function _s(a,e){const{vertex:t,fragment:r}=a;a.include(ia,e),t.include(Dt),t.main.add(_`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),r.main.add(_`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}var Je;(function(a){a[a.Occluded=0]="Occluded",a[a.NotOccluded=1]="NotOccluded",a[a.Both=2]="Both",a[a.COUNT=3]="COUNT"})(Je||(Je={}));function bs(a){a.vertex.uniforms.add(new Qe("renderTransparentlyOccludedHUD",(e=>e.hudRenderStyle===Je.Occluded?1:e.hudRenderStyle===Je.NotOccluded?0:.75)),new Et("viewport",(e=>e.camera.fullViewport)),new Rr("hudVisibilityTexture",(e=>{var t;return(t=e.hudVisibility)==null?void 0:t.getTexture()}))),a.vertex.include(Dt),a.vertex.code.add(_`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}function vs(a){const e=new sa,{signedDistanceFieldEnabled:t,occlusionTestEnabled:r,horizonCullingEnabled:n,pixelSnappingEnabled:i,hasScreenSizePerspective:s,debugDrawLabelBorder:o,vvSize:l,vvColor:d,hasRotation:u,occludedFragmentFade:c,sampleSignedDistanceFieldTexelCenter:f}=a;e.include(gs,a),e.vertex.include(oa,a);const{occlusionPass:g,output:b,oitPass:x}=a;if(g)return e.include(_s,a),e;const{vertex:v,fragment:h}=e;e.include($r),e.include(la,a),e.include(ca,a),r&&e.include(bs),h.include(hi),h.include(da),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const p=b===H.Highlight,w=p&&r;w&&e.varyings.add("voccluded","float"),v.uniforms.add(new Et("viewport",(C=>C.camera.fullViewport)),new Qt("screenOffset",((C,j)=>Tt(ke,2*C.screenOffset[0]*j.camera.pixelRatio,2*C.screenOffset[1]*j.camera.pixelRatio))),new Qt("anchorPosition",(C=>Ee(C))),new at("materialColor",(C=>C.color)),new yt("materialRotation",(C=>C.rotation)),new Wt("tex",(C=>C.texture))),Pr(v),t&&(v.uniforms.add(new at("outlineColor",(C=>C.outlineColor))),h.uniforms.add(new at("outlineColor",(C=>hr(C)?C.outlineColor:vr)),new yt("outlineSize",(C=>hr(C)?C.outlineSize:0)))),n&&v.uniforms.add(new mi("pointDistanceSphere",((C,j)=>{const $=j.camera.eye,P=C.origin;return Tn(P[0]-$[0],P[1]-$[1],P[2]-$[2],Rn.radius)}))),i&&v.include(Dt),s&&(ua(v),Tr(v)),o&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(y.UVI,"vec2"),e.attributes.add(y.COLOR,"vec4"),e.attributes.add(y.SIZE,"vec2"),e.attributes.add(y.ROTATION,"float"),(l||d)&&e.attributes.add(y.FEATUREATTRIBUTE,"vec4"),v.code.add(n?_`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return b > 0.0 && b < a && b * b  > a * c;
}`:_`bool behindHorizon(vec3 posModel) { return false; }`),v.main.add(_`
    ProjectHUDAux projectAux;
    vec4 posProj = projectPositionHUD(projectAux);
    forwardObjectAndLayerIdColor();

    if (rejectBySlice(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    if (behindHorizon(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec2 inputSize;
    ${z(s,_`
        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,_`
        inputSize = size;
        vec2 screenOffsetScaled = screenOffset;`)}
    ${z(l,_`inputSize *= vvScale(featureAttribute).xx;`)}

    vec2 combinedSize = inputSize * pixelRatio;
    vec4 quadOffset = vec4(0.0);

    ${z(r,_`
    bool visible = testHUDVisibility(posProj);
    if (!visible) {
      vtc = vec2(0.0);
      ${z(o,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
      return;
    }`)}
    ${z(w,_`voccluded = visible ? 0.0 : 1.0;`)}
  `);const I=_`
      vec2 uvi1 = vec2(uvi.x < 0.0 ? 1.0 : 0.0, uvi.y < 0.0 ? 1.0 : 0.0);
      vec2 uv = abs(uvi + uvi1);
      vec2 texSize = vec2(textureSize(tex, 0));
      uv.x = uv.x >= ${mr} ? 1.0 : uv.x / texSize.x;
      uv.y = uv.y >= ${mr} ? 1.0 : uv.y / texSize.y;
      quadOffset.xy = (uvi1 - anchorPosition) * 2.0 * combinedSize;

      ${z(u,_`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,m=i?t?_`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:_`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:_`posProj += quadOffset;`;v.main.add(_`
    ${I}
    ${d?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${z(b===H.ObjectAndLayerIdColor,_`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${_.float(K)};
    ${z(t,`alphaDiscard = alphaDiscard && outlineColor.a < ${_.float(K)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${m}
      gl_Position = posProj;
    }

    vtc = uv;

    ${z(o,_`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),h.uniforms.add(new Wt("tex",(C=>C.texture))),c&&!p&&h.uniforms.add(new Rr("depthMap",(C=>C.mainDepth)),new Qe("occludedOpacity",(C=>C.hudOccludedFragmentOpacity)));const E=o?_`(isBorder > 0.0 ? 0.0 : ${_.float(K)})`:_.float(K),M=_`
    ${z(o,_`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    vec2 samplePos = vtc;

    ${z(f,_`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;`)}

    ${t?_`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${E} ||
          fillPixelColor.a + outlinePixelColor.a < ${_.float(K)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${z(!p,_`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${E}) {
          discard;
        }

        ${z(!p,_`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:_`
          vec4 texColor = texture(tex, samplePos, -0.5);
          if (texColor.a < ${E}) {
            discard;
          }
          ${z(!p,_`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${z(c&&!p,_`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${z(!p&&o,_`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(b){case H.Color:case H.ColorEmission:e.outputs.add("fragColor","vec4",0),b===H.ColorEmission&&e.outputs.add("fragEmission","vec4",1),x===$e.ColorAlpha&&e.outputs.add("fragAlpha","float",b===H.ColorEmission?2:1),h.main.add(_`
        ${M}
        ${z(x===$e.FrontFace,_`fragColor.rgb /= fragColor.a;`)}
        ${z(b===H.ColorEmission,_`fragEmission = vec4(0.0);`)}
        ${z(x===$e.ColorAlpha,_`fragAlpha = fragColor.a;`)}`);break;case H.ObjectAndLayerIdColor:h.main.add(_`
        ${M}
        outputObjectAndLayerIdColor();`);break;case H.Highlight:e.include(fa,a),h.main.add(_`
        ${M}
        outputHighlight(${z(w,_`voccluded == 1.0`,_`false`)});`)}return e}function hr(a){return a.outlineColor[3]>0&&a.outlineSize>0}function Ee(a){return a.textureIsSignedDistanceField?Cs(a.anchorPosition,a.distanceFieldBoundingBox,ke):Xn(ke,a.anchorPosition),ke}function Cs(a,e,t){Tt(t,a[0]*(e[2]-e[0])+e[0],a[1]*(e[3]-e[1])+e[1])}const ke=Rt(),Ze=32e3,mr=_.float(Ze),xs=Object.freeze(Object.defineProperty({__proto__:null,build:vs,calculateAnchorPosition:Ee,fullUV:Ze},Symbol.toStringTag,{value:"Module"}));let ws=class extends ha{constructor(e,t){super(e,t,new ma(xs,(()=>En(()=>import("./HUDMaterial.glsl-BpyXEYMr.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]),import.meta.url)))),this.primitiveType=t.occlusionPass?Kt.POINTS:Kt.TRIANGLES}initializePipeline(e){const{oitPass:t,hasPolygonOffset:r,draped:n,output:i,depthTestEnabled:s,occlusionPass:o}=e,l=t===$e.NONE,d=t===$e.ColorAlpha,u=i===H.Highlight,c=s&&!n&&!d&&!o&&!u;return pa({blending:Lr(i)?l?ya:_a(t):null,depthTest:s&&!n?{func:Ga.LEQUAL}:null,depthWrite:c?va:null,drawBuffers:ga(t,i),colorWrite:ba,polygonOffset:r?Is:null})}};const Is={factor:0,units:-4};class R extends Ca{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=xa.None,this.emissionSource=wa.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1,this.snowCover=!1}}S([F()],R.prototype,"screenCenterOffsetUnitsEnabled",void 0),S([F()],R.prototype,"occlusionTestEnabled",void 0),S([F()],R.prototype,"signedDistanceFieldEnabled",void 0),S([F()],R.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),S([F()],R.prototype,"vvSize",void 0),S([F()],R.prototype,"vvColor",void 0),S([F()],R.prototype,"hasVerticalOffset",void 0),S([F()],R.prototype,"hasScreenSizePerspective",void 0),S([F()],R.prototype,"hasRotation",void 0),S([F()],R.prototype,"debugDrawLabelBorder",void 0),S([F()],R.prototype,"hasPolygonOffset",void 0),S([F()],R.prototype,"depthTestEnabled",void 0),S([F()],R.prototype,"pixelSnappingEnabled",void 0),S([F()],R.prototype,"draped",void 0),S([F()],R.prototype,"terrainDepthTest",void 0),S([F()],R.prototype,"cullAboveTerrain",void 0),S([F()],R.prototype,"occlusionPass",void 0),S([F()],R.prototype,"occludedFragmentFade",void 0),S([F()],R.prototype,"objectAndLayerIdColorInstanced",void 0),S([F()],R.prototype,"horizonCullingEnabled",void 0),S([F()],R.prototype,"isFocused",void 0);class Ss extends Ia{constructor(e,t){super(e,Es),this.produces=new Map([[ae.HUD_MATERIAL,r=>it(r)&&!this.parameters.drawAsLabel],[ae.LABEL_MATERIAL,r=>it(r)&&this.parameters.drawAsLabel],[ae.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[ae.DRAPED_MATERIAL,r=>this.parameters.draped&&it(r)]]),this._visible=!0,this._configuration=new R(t)}getConfiguration(e,t){const r=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=r,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===ae.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=!r&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||t.slot===ae.OCCLUSION_PIXELS,Lr(e)&&(this._configuration.debugDrawLabelBorder=!!Sa.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,r,n,i,s){const{options:{selectionMode:o,hud:l,excludeLabels:d},point:u,camera:c}=r,{parameters:f}=this;if(!o||!l||d&&f.isLabel||!e.visible||!u||!c)return;const g=e.attributes.get(y.FEATUREATTRIBUTE),b=g==null?null:Bt(g.data,St),{scaleX:x,scaleY:v}=At(b,f,c.pixelRatio);zr(Ge,t),e.attributes.has(y.FEATUREATTRIBUTE)&&$s(Ge);const h=e.attributes.get(y.POSITION),p=e.attributes.get(y.SIZE),w=e.attributes.get(y.NORMAL),I=e.attributes.get(y.ROTATION),m=e.attributes.get(y.CENTEROFFSETANDDISTANCE);ii(h.size>=3);const E=Ee(f),M=this.parameters.centerOffsetUnits==="screen";for(let C=0;C<h.data.length/h.size;C++){const j=C*h.size;Oe(A,h.data[j],h.data[j+1],h.data[j+2]),ye(A,A,t),ye(A,A,c.viewMatrix);const $=C*m.size;if(Oe(T,m.data[$],m.data[$+1],m.data[$+2]),!M&&(A[0]+=T[0],A[1]+=T[1],T[2]!==0)){const V=T[2];ge(T,A),J(A,A,Z(T,T,V))}const P=C*w.size;if(Oe(re,w.data[P],w.data[P+1],w.data[P+2]),wt(re,Ge,c,Pe),Ot(this.parameters,A,Pe,c,Ce),c.applyProjection(A,O),O[0]>-1){M&&(T[0]||T[1])&&(O[0]+=T[0]*c.pixelRatio,T[1]!==0&&(O[1]+=Er(T[1],Ce.factorAlignment)*c.pixelRatio),c.unapplyProjection(O,A)),O[0]+=this.parameters.screenOffset[0]*c.pixelRatio,O[1]+=this.parameters.screenOffset[1]*c.pixelRatio,O[0]=Math.floor(O[0]),O[1]=Math.floor(O[1]);const V=C*p.size;D[0]=p.data[V],D[1]=p.data[V+1],Fr(D,Ce.factor,D);const ee=Jr*c.pixelRatio;let Me=0;f.textureIsSignedDistanceField&&(Me=Math.min(f.outlineSize,.5*D[0])*c.pixelRatio/2),D[0]*=x,D[1]*=v;const rt=C*I.size,ze=f.rotation+I.data[rt];if(It(u,O[0],O[1],D,ee,Me,ze,f,E)){const X=r.ray;if(ye(Ke,A,$t(Yr,c.viewMatrix)),O[0]=u[0],O[1]=u[1],c.unprojectFromRenderScreen(O,A)){const Y=U();Q(Y,X.direction);const Mt=1/Re(Y);Z(Y,Y,Mt),s(Or(X.origin,A)*Mt,Y,-1,Ke)}}}}}intersectDraped(e,t,r,n,i){const s=e.attributes.get(y.POSITION),o=e.attributes.get(y.SIZE),l=e.attributes.get(y.ROTATION),d=this.parameters,u=Ee(d),c=e.attributes.get(y.FEATUREATTRIBUTE),f=c==null?null:Bt(c.data,St),{scaleX:g,scaleY:b}=At(f,d,e.screenToWorldRatio),x=Ts*e.screenToWorldRatio;for(let v=0;v<s.data.length/s.size;v++){const h=v*s.size,p=s.data[h],w=s.data[h+1],I=v*o.size;D[0]=o.data[I],D[1]=o.data[I+1];let m=0;d.textureIsSignedDistanceField&&(m=Math.min(d.outlineSize,.5*D[0])*e.screenToWorldRatio/2),D[0]*=g,D[1]*=b;const E=v*l.size,M=d.rotation+l.data[E];It(r,p,w,D,x,m,M,d,u)&&n(i.distance,i.normal,-1)}}createBufferWriter(){return new Ds}applyShaderOffsetsView(e,t,r,n,i,s,o){const l=wt(t,r,i,Pe);return this._applyVerticalGroundOffsetView(e,l,i,o),Ot(this.parameters,o,l,i,s),this._applyPolygonOffsetView(o,l,n[3],i,o),this._applyCenterOffsetView(o,n,o),o}applyShaderOffsetsNDC(e,t,r,n,i){return this._applyCenterOffsetNDC(e,t,r,n),i!=null&&Q(i,n),this._applyPolygonOffsetNDC(n,t,r,n),n}_applyPolygonOffsetView(e,t,r,n,i){const s=n.aboveGround?1:-1;let o=Math.sign(r);o===0&&(o=s);const l=s*o;if(this.parameters.shaderPolygonOffset<=0)return Q(i,e);const d=Fn(Math.abs(t.cosAngle),.01,1),u=1-Math.sqrt(1-d*d)/d/n.viewport[2];return Z(i,e,l>0?u:1/u),i}_applyVerticalGroundOffsetView(e,t,r,n){const i=Re(e),s=r.aboveGround?1:-1,o=r.computeRenderPixelSizeAtDist(i)*Wr,l=Z(A,t.normal,s*o);return Pt(n,e,l),n}_applyCenterOffsetView(e,t,r){const n=this.parameters.centerOffsetUnits!=="screen";return r!==e&&Q(r,e),n&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(ge(re,r),qn(r,r,Z(re,re,t[2])))),r}_applyCenterOffsetNDC(e,t,r,n){const i=this.parameters.centerOffsetUnits!=="screen";return n!==e&&Q(n,e),i||(n[0]+=t[0]/r.fullWidth*2,n[1]+=t[1]/r.fullHeight*2),n}_applyPolygonOffsetNDC(e,t,r,n){const i=this.parameters.shaderPolygonOffset;if(e!==n&&Q(n,e),i){const s=r.aboveGround?1:-1,o=s*Math.sign(t[3]);n[2]-=(o||s)*i}return n}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:r}=this.parameters,n=e[3]>=K||t>=K&&r[3]>=K;return this._visible&&n}createGLMaterial(e){return new As(e)}calculateRelativeScreenBounds(e,t,r=Ir()){return Os(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class As extends za{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(ws,e)}}function Os(a,e,t,r){r[0]=a.anchorPosition[0]*-e[0]+a.screenOffset[0]*t,r[1]=a.anchorPosition[1]*-e[1]+a.screenOffset[1]*t}function wt(a,e,t,r){return ps(e)&&(e=zr(Ps,e)),Qn(r.normal,a,e),ye(r.normal,r.normal,t.viewInverseTransposeMatrix),r.cosAngle=Wn(Xr,Rs),r}function $s(a){const e=a[0],t=a[1],r=a[2],n=a[3],i=a[4],s=a[5],o=a[6],l=a[7],d=a[8],u=1/Math.sqrt(e*e+t*t+r*r),c=1/Math.sqrt(n*n+i*i+s*s),f=1/Math.sqrt(o*o+l*l+d*d);return a[0]=e*u,a[1]=t*u,a[2]=r*u,a[3]=n*c,a[4]=i*c,a[5]=s*c,a[6]=o*f,a[7]=l*f,a[8]=d*f,a}function It(a,e,t,r,n,i,s,o,l){let d=e-n-r[0]*l[0],u=d+r[0]+2*n,c=t-n-r[1]*l[1],f=c+r[1]+2*n;const g=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&g!=null&&(d+=r[0]*g[0],c+=r[1]*g[1],u-=r[0]*(1-g[2]),f-=r[1]*(1-g[3]),d-=i,u+=i,c-=i,f+=i),Tt(pr,e,t),Yn(Se,a,pr,Mn(s)),Se[0]>d&&Se[0]<u&&Se[1]>c&&Se[1]<f}const Ce=new ys,A=U(),re=U(),O=tt(),Xr=U(),Ke=U(),Se=Rt(),pr=Rt(),Ge=jr(),Ps=jr(),Yr=we(),Be=tt(),T=U(),dt=U(),St=tt(),Pe={normal:Xr,cosAngle:0},Jr=1,Ts=2,D=k(0,0),L=6,Rs=Dn(0,0,1);class Es extends Aa{constructor(){super(...arguments),this.renderOccluded=Oa.Occlude,this.isDecoration=!1,this.color=mt(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=k(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=mt(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=tt(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}}const Zr=ci().vec3f(y.POSITION).vec3f(y.NORMAL).vec2i16(y.UVI).vec4u8(y.COLOR).vec2f(y.SIZE).f32(y.ROTATION).vec4f(y.CENTEROFFSETANDDISTANCE).vec4f(y.FEATUREATTRIBUTE),Fs=Zr.clone().vec4u8(y.OLIDCOLOR);class Ds{constructor(){this.vertexBufferLayout=Ta()?Fs:Zr}elementCount(e){return e.get(y.POSITION).indices.length*L}write(e,t,r,n,i,s){var C,j;const{position:o,normal:l,uvi:d,color:u,size:c,rotation:f,centerOffsetAndDistance:g,featureAttribute:b}=i;Ra(r.get(y.POSITION),e,o,s,L),Ea(r.get(y.NORMAL),t,l,s,L);const x=(C=r.get(y.UVI))==null?void 0:C.data;let v=0,h=0,p=-1-Ze,w=-1-Ze;x&&x.length>=4&&(v=x[0],h=x[1],p=-1-x[2],w=-1-x[3]);let I=r.get(y.POSITION).indices.length,m=s;for(let $=0;$<I;++$)d.set(m,0,v),d.set(m,1,h),m++,d.set(m,0,p),d.set(m,1,h),m++,d.set(m,0,p),d.set(m,1,w),m++,d.set(m,0,p),d.set(m,1,w),m++,d.set(m,0,v),d.set(m,1,w),m++,d.set(m,0,v),d.set(m,1,h),m++;Fa(r.get(y.COLOR),4,u,s,L);const{data:E,indices:M}=r.get(y.SIZE);I=M.length,m=s;for(let $=0;$<I;++$){const P=E[2*M[$]],V=E[2*M[$]+1];for(let ee=0;ee<L;++ee)c.set(m,0,P),c.set(m,1,V),m++}if(Da(r.get(y.ROTATION),f,s,L),r.get(y.CENTEROFFSETANDDISTANCE)?Xt(r.get(y.CENTEROFFSETANDDISTANCE),g,s,L):Yt(g,s,I*L),r.get(y.FEATUREATTRIBUTE)?Xt(r.get(y.FEATUREATTRIBUTE),b,s,L):Yt(b,s,I*L),n!=null){const $=(j=r.get(y.POSITION))==null?void 0:j.indices;if($){const P=$.length,V=i.getField(y.OLIDCOLOR,si);Ma(n,V,P,s,L)}}return{numVerticesPerItem:L,numItems:I}}intersect(e,t,r,n,i,s,o){const{options:{selectionMode:l,hud:d,excludeLabels:u},point:c,camera:f}=n;if(!l||!d||u&&t.isLabel||!c)return;const g=this.vertexBufferLayout.createView(e),b=g.getField(y.POSITION,rr),x=g.getField(y.NORMAL,rr),v=g.getField(y.ROTATION,oi),h=g.getField(y.SIZE,li),p=g.getField(y.FEATUREATTRIBUTE,nr),w=g.getField(y.CENTEROFFSETANDDISTANCE,nr),I=t.centerOffsetUnits==="screen",m=Ee(t);if(b==null||x==null||v==null||h==null||w==null||f==null)return;const E=p==null?null:p.getVec(0,St),{scaleX:M,scaleY:C}=At(E,t,f.pixelRatio),j=b.count/L;for(let $=0;$<j;$++){const P=$*L;if(b.getVec(P,A),r!=null&&Pt(A,A,r),ye(A,A,f.viewMatrix),w.getVec(P,Be),Oe(T,Be[0],Be[1],Be[2]),!I&&(A[0]+=T[0],A[1]+=T[1],T[2]!==0)){const V=T[2];ge(T,A),J(A,A,Z(T,T,V))}if(x.getVec(P,re),wt(re,Ge,f,Pe),Ot(t,A,Pe,f,Ce),f.applyProjection(A,O),O[0]>-1){I&&(T[0]||T[1])&&(O[0]+=T[0]*f.pixelRatio,T[1]!==0&&(O[1]+=Er(T[1],Ce.factorAlignment)*f.pixelRatio),f.unapplyProjection(O,A)),O[0]+=t.screenOffset[0]*f.pixelRatio,O[1]+=t.screenOffset[1]*f.pixelRatio,O[0]=Math.floor(O[0]),O[1]=Math.floor(O[1]),h.getVec(P,D),Fr(D,Ce.factor,D);const V=Jr*f.pixelRatio;let ee=0;t.textureIsSignedDistanceField&&(ee=Math.min(t.outlineSize,.5*D[0])*f.pixelRatio/2),D[0]*=M,D[1]*=C;const Me=v.get(P),rt=t.rotation+Me;if(It(c,O[0],O[1],D,V,ee,rt,t,m)){const ze=n.ray;if(ye(Ke,A,$t(Yr,f.viewMatrix)),O[0]=c[0],O[1]=c[1],f.unprojectFromRenderScreen(O,A)){const X=U();Q(X,ze.direction);const Y=1/Re(X);Z(X,X,Y),o(Or(ze.origin,A)*Y,X,$,Ke)}}}}}}function At(a,e,t){return a==null||e.vvSize==null?{scaleX:t,scaleY:t}:($a(dt,e,a),{scaleX:dt[0]*t,scaleY:dt[1]*t})}function Ot(a,e,t,r,n){var l;if(!((l=a.verticalOffset)!=null&&l.screenLength))return a.screenSizePerspective||a.screenSizePerspectiveAlignment?gr(a,n,Re(e),t.cosAngle):(n.factor.scale=1,n.factorAlignment.scale=1),e;const i=Re(e),s=a.screenSizePerspectiveAlignment??a.screenSizePerspective,o=Pa(r,i,a.verticalOffset,t.cosAngle,s);return gr(a,n,i,t.cosAngle),Z(t.normal,t.normal,o),Pt(e,e,t.normal)}function gr(a,e,t,r){a.screenSizePerspective!=null?Jt(r,t,a.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),a.screenSizePerspectiveAlignment!=null?Jt(r,t,a.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}class Ms{constructor(e,t){this._mainThreadDelegate=t,this._bufferWriters=new Map,this.globalViewingMode=e===me.Global}createRenderCommandBuffer(e=[],t=[]){return{commands:e,transferList:t}}mergeRenderCommandBuffers(e){const t=this.createRenderCommandBuffer();for(const r of e)r!=null&&(t.commands.push(...r.commands),t.transferList.push(...r.transferList));return t}async createTexture(e){const{data:t,parameters:r}=e();return await this._mainThreadDelegate.createTexture(t,r)}async releaseTexture(e){const t=this._destroyTexture(e);return new W(this,t,[])}_destroyTexture(e){return{commands:[{id:"destroy-texture",textureId:e}],transferList:[]}}async createMaterial(e){const{type:t,parameters:r}=e,n=Xe("material");let i,s;switch(t){case"default":i=new ja(e.parameters,{spherical:this.globalViewingMode}),s={type:t,materialId:n,parameters:e.parameters};break;case"hud":i=new Ss(r,this.globalViewingMode),s={type:t,materialId:n,parameters:e.parameters}}return this._bufferWriters.set(n,i.createBufferWriter()),await this._mainThreadDelegate.createMaterial(s),n}destroyMaterial(e){return{commands:[{id:"destroy-material",materialId:e}],transferList:[]}}updateMaterial(e){return{commands:[{...e,id:"update-material"}],transferList:[]}}async createDirectRenderer(e){return await this._mainThreadDelegate.createDirectRenderer(e),e}async destroyDirectRenderer(e){await this._mainThreadDelegate.destroyDirectRenderer(e)}addDirectRendererGeometry(e,t,r){const{materialId:n}=t;if(this._bufferWriters.get(n)==null)throw new Error(`no bufferwriter found for material ${n}`);const{renderGeometryBuffer:i,renderGeometryBufferItems:s}=this.createRenderGeometryBuffer(t,r);return this.addDirectRendererGeometryBuffer(n,e,i,s,r)}updateDirectRendererGeometry(e,t,r){const{materialId:n}=t;if(this._bufferWriters.get(n)==null)throw new Error(`no bufferwriter found for material ${n}`);const{renderGeometryBuffer:i,renderGeometryBufferItems:s}=this.createRenderGeometryBuffer(t,r);return this.updateDirectRendererGeometryBuffer(n,e,i,s,r)}addDirectRendererGeometryBuffer(e,t,r,n,i){const{objectIds:s,visibilities:o}=n;return{commands:[{id:"add-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:n,localOrigin:i}],transferList:[r.data,s.buffer,o.buffer]}}updateDirectRendererGeometryBuffer(e,t,r,n,i){const{objectIds:s,visibilities:o}=n;return{commands:[{id:"update-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:n,localOrigin:i}],transferList:[r.data,s.buffer,o.buffer]}}removeDirectRendererGeometryBuffer(e,t){return{commands:[{id:"remove-direct-renderer-geometry-buffer",rendererId:e,groupId:t}],transferList:[]}}async createLodRenderer(e){const t=Xe("lod-renderer"),r=new Set,n={levels:e.levels.map((i=>({components:i.components.map((s=>{const o=s.attributes.get(y.POSITION);if(!o||o.indices.length===0)throw new Error("positions attribute expected");const l=3,d=Na(o.indices.length/l),u=new La(d,l,o);if(this._bufferWriters.get(s.materialId)==null)throw new Error("writer not found");const{renderGeometryBuffer:c}=this.createRenderGeometryBuffer(s,null);return r.add(c.data),{materialId:s.materialId,renderGeometryBuffer:c,boundingInfo:{bbMax:u.bbMax,bbMin:u.bbMin}}})),minScreenSpaceRadius:i.minScreenSpaceRadius})))};return await this._mainThreadDelegate.createLodRenderer(t,n,Array.from(r)),t}destroyLodRenderer(e){return{commands:[{id:"destroy-lod-renderer",rendererId:e}],transferList:[]}}addLodInstances(e,t,r){return{commands:[{id:"add-lod-instances",rendererId:e,groupId:t,data:r}],transferList:[r.featureIds.buffer,r.globalTransforms.buffer,r.localTransforms.buffer,r.visibility.buffer]}}removeLodInstances(e,t){return{commands:[{id:"remove-lod-instances",rendererId:e,groupId:t}],transferList:[]}}updateLodInstancesData(e,t,r){return{commands:[{id:"update-lod-instance-data",rendererId:e,groupId:t,globalTransforms:r}],transferList:[r.buffer]}}updateVisibility(e,t,r){return{commands:[{id:"update-visibility",rendererId:e,groupId:t,visibility:r}],transferList:[r.buffer]}}async dispatchRenderCommands(e){e.commands.length!==0&&await this._mainThreadDelegate.executeRenderCommands(e)}createRenderGeometryBuffer(e,t){const{materialId:r,visibilities:n,objectIds:i}=e,s=this._bufferWriters.get(r);if(s==null)throw new Error("no registered bufferWriter for material found");let o=null;if(e.transformation&&t)Sr(ue,e.transformation),ue[12]-=t[0],ue[13]-=t[1],ue[14]-=t[2],o=ue;else{if(t)throw new Error("not implemented");e.transformation&&(o=e.transformation)}let l=null;o&&($t(Ue,ue),zn(Ue,Ue),l=Ue);const d=e.attributes,u=s.elementCount(d),c=s.vertexBufferLayout.stride/4;u>Math.floor(zs/c)&&console.warn("geometry with very large number of elements encountered");const f=s.vertexBufferLayout.createBuffer(u),g=0,b=s.write(o,l,d,e.objectAndLayerIdColor,f,g);if(b==null)throw new Error("Bufferwriter.write does not provide item information.");if(n.length!==b.numItems||i.length!==b.numItems)throw new Error("Unexpected mismatch between number of RenderGeometryBufferItems and provided objectIds/visibility flags.");return{renderGeometryBuffer:{data:f.buffer,elementCount:u},renderGeometryBufferItems:{objectIds:i,visibilities:n,ranges:{numVertices:b.numVerticesPerItem,numItems:b.numItems}}}}}const ue=we(),Ue=we(),zs=16777216/4;function js(a,e,t){return!!We(a,e,Ve,t.spatialReference)&&(t.x=Ve[0],t.y=Ve[1],t.z=Ve[2],!0)}const Ve=U();function Ls(a){const{value:e,operations:t}=a;return{operations:t,value:t.create(e)}}function Bs(a,e,t){return a.operations.setExtent(a.value,e,t.value),t}function Us(a,e){return a.operations.getExtent(a.value,e),e}function Vs(a){return{operations:a,value:a.create()}}function Kr(a,e,t=Vs(a)){return t.operations=a,a.copy(e,t.value),t}function Ns(a){return Kr(Wa,Qa(0,0,0,Ar(a).radius))}const yr=2**50;function ks(){return Kr(Ua,Ba([0,0,0],[yr,0,0],[0,yr,0]))}function Gs(a,e,t){return a.operations.axisAt(a.value,e,Ae.Z,t)}function Hs(a,e,t,r){return a.operations.axisAt(a.value,e,t,r)}function qs(a,e,t){return a.operations.intersectRay(a.value,e,t)}function Qs(a,e,t){return a.operations.intersectRayClosestSilhouette(a.value,e,t)}function Ws(a,e){return a.operations.altitudeAt(a.value,e)}function en(a,e,t,r){return a.operations.setAltitudeAt(a.value,e,t,r)}function Xs(a,e,t,r){return e!==r&&Sr(r,e),Oe(fe,r[12],r[13],r[14]),en(a,fe,t,fe),r[12]=fe[0],r[13]=fe[1],r[14]=fe[2],r}function ut(a,e,t){return a.operations.elevate(a.value,e,t.value)}const fe=U();function _r(a){return a.type==="point"}class et{constructor(e,t,r,n){this.viewingMode=e,this.spatialReference=t,this.unitInMeters=r,this._coordinateSystem=n,this._tmpCoordinateSystem=Ls(n),this.referenceEllipsoid=Ar(t),this.sphericalPCPF=ui(t)}set extent(e){e&&Bs(this._coordinateSystem,e,this._coordinateSystem)}get extent(){return Us(this._coordinateSystem,Ir())}getAltitude(e){return Ws(this._coordinateSystem,e)}setAltitude(e,t,r=e){return en(this._coordinateSystem,r,t,e)}setAltitudeOfTransformation(e,t){Xs(this._coordinateSystem,t,e,t)}worldUpAtPosition(e,t){return Gs(this._coordinateSystem,e,t)}worldBasisAtPosition(e,t,r){return Hs(this._coordinateSystem,e,t,r)}basisMatrixAtPosition(e,t){const r=this.worldBasisAtPosition(e,Ae.X,te.get()),n=this.worldBasisAtPosition(e,Ae.Y,te.get()),i=this.worldBasisAtPosition(e,Ae.Z,te.get());return jn(t,r[0],r[1],r[2],0,n[0],n[1],n[2],0,i[0],i[1],i[2],0,0,0,0,1),t}headingAtPosition(e,t){const r=this.worldUpAtPosition(e,te.get()),n=this.worldBasisAtPosition(e,Ae.Y,te.get()),i=Xa(t,n,r);return Ln(i)}intersectManifoldClosestSilhouette(e,t,r){return ut(this._coordinateSystem,t,this._tmpCoordinateSystem),Qs(this._tmpCoordinateSystem,e,r),r}intersectManifold(e,t,r){ut(this._coordinateSystem,t,this._tmpCoordinateSystem);const n=te.get();return qs(this._tmpCoordinateSystem,e,n)?Q(r,n):null}intersectInfiniteManifold(e,t,r){if(this.viewingMode===me.Global)return this.intersectManifold(e,t,r);ut(this._coordinateSystem,t,this._tmpCoordinateSystem);const n=this._tmpCoordinateSystem.value,i=te.get();return qa(n.plane,e,i)?Q(r,i):null}toRenderCoords(e,t,r){return _r(e)?fi(e,t,this.spatialReference):We(e,t,r,this.spatialReference)}fromRenderCoords(e,t,r=null){return _r(t)?(r!=null&&(t.spatialReference=r),js(e,this.spatialReference,t)?t:null):We(e,this.spatialReference,t,r)?t:null}static create(e,t){switch(e){case me.Local:return new et(me.Local,t,Bn(t),ks());case me.Global:return new et(me.Global,t,1,Ns(t))}}static renderUnitScaleFactor(e,t){return Ut(e)/Ut(t)}}let He=class extends wr.EventedAccessor{constructor(){super(...arguments),this.remoteClient=null,this._featureStore=new ns,this._tileLocks=new es,this._tileManager=null,this._renderer=null,this._fetcher=null,this._queryEngine=null,this._defaultQueryJSON=null,this._mainThreadDelegate=null,this._viewSpatialReference=null,this._renderCommandContext=null,this._context=null}get updating(){return this._tileManager.updating}destroy(){var a;this._featureStore.clear(),(a=this._tileManager)==null||a.destroy()}async setup({viewSpatialReference:a,renderSpatialReference:e,viewingMode:t,layerInfo:r,layerViewInfo:n}){const i=Vt.fromJSON(a);this._viewSpatialReference=i;const s=Vt.fromJSON(e);this._fetcher=new fs(this._viewSpatialReference,Nt.fromJSON(r.baseQuery),r.url,r.objectIdField,r.capabilities),this._queryEngine=new Hn({hasZ:!0,hasM:!1,geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:r.objectIdField},fieldsIndex:r.fieldIndex,availableFields:[r.objectIdField],spatialReference:a,featureStore:this._featureStore,timeInfo:r.timeInfo}),this._mainThreadDelegate={createTexture:async(c,f)=>{const g={data:c,parameters:f};return await this.remoteClient.invoke("createTexture",g,{transferList:[c.buffer]})},releaseTexture:async c=>{const f={uid:c};await this.remoteClient.invoke("releaseTexture",f)},createMaterial:async c=>{const f={materialJSON:c};await this.remoteClient.invoke("createMaterial",f)},destroyMaterial:async c=>{const f={materialId:c};await this.remoteClient.invoke("destroyMaterial",f)},createDirectRenderer:async c=>{const f={materialId:c};await this.remoteClient.invoke("createDirectRenderer",f)},destroyDirectRenderer:async c=>{const f={materialId:c};await this.remoteClient.invoke("destroyDirectRenderer",f)},createLodRenderer:async(c,f,g)=>{const b={rendererId:c,lodRenderGeometry:f};await this.remoteClient.invoke("createLoDRenderer",b,{transferList:g})},destroyLodRenderer:async c=>{const f={rendererId:c};await this.remoteClient.invoke("destroyLoDRenderer",f)},executeRenderCommands:async c=>{const f={commands:c.commands};await this.remoteClient.invoke("dispatchRenderCommands",f,{transferList:c.transferList})},applyElevationAlignmentTo:async c=>{const f={mapPoints:c};return await this.remoteClient.invoke("applyElevationAlignment",f,{transferList:[c.buffer]})}};const o=et.create(t,s),l=new Ms(t,this._mainThreadDelegate);this._renderCommandContext=l;const d=new Wi(i,s,this._mainThreadDelegate,o,l,r,n);this._context=d,this._renderer=d.symbolRendererFactory.createSymbolRendererFromJSON(r.renderer),this._defaultQueryJSON=new Nt({outSpatialReference:i}).toJSON();let u=null;if(r.fullExtent!=null){const c=Un.fromJSON(r.fullExtent);await Vn(c.spatialReference,i),u=Nn(c,i)}return this._tileManager=new B({loadTile:(c,f)=>this._fetcher.fetch(c,f),createAddCommand:(c,f)=>this._createAddFeatureDataCommand(c,f),createRemoveCommand:c=>this._createRemoveFeatureDataCommand(c),createUpdateCommand:(c,f)=>this._createUpdateFeatureDataVisibilityCommand(c,f),tileLocks:this._tileLocks,extent:u}),this.addHandles(kn((()=>this.updating),(c=>{this.emit("notify-updating",{updating:c})})),Gn),this._renderer!=null&&await this._renderer.load(),he}async executeQuery(a,e){return{result:await this._queryEngine.executeQuery(this._ensureQuery(a),e)}}async executeQueryForIds(a,e){const t=await this._queryEngine.executeQueryForIdSet(this._ensureQuery(a),e);return{result:Array.from(t)}}async executeQueryForCount(a,e){return{result:await this._queryEngine.executeQueryForCount(this._ensureQuery(a),e)}}async executeQueryForExtent(a,e){return{result:await this._queryEngine.executeQueryForExtent(this._ensureQuery(a),e)}}async executeQueryForLatestObservations(a,e){return{result:await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(a),e)}}onTileTreeChange(a){return this._tileManager.onTileTreeChange(a),Promise.resolve(he)}async onElevationChange(a){return he}async onLayerViewOpacityChange(a){const{_context:e,_renderer:t}=this;return e.layerViewInfo.fullOpacity=a,t==null||await(await t.createUpdateLayerViewOpacityCommand(a)).execute(),he}async onRendererChange(a){const{_context:e}=this,t=e.symbolRendererFactory.createSymbolRendererFromJSON(a);await t.load();const r=this._renderer;this._renderer=t;const n=[...this._tileManager.loadedTiles()],i=n.map((o=>o.tileId));{const o={stack:[],error:void 0,hasError:!1};try{pt(o,await this._tileLocks.lock(i),!1);const l=n.flatMap((c=>[r.createRemoveCommand(c.id),t.createAddCommand(c)])),d=await Promise.all(l);await e.joinPipelineCommands(d).execute()}catch(l){o.error=l,o.hasError=!0}finally{gt(o)}}return await(await r.createDestroyCommand()).execute(),he}async _createAddFeatureDataCommand(a,e){const t=this._featureStore,r=this._renderer;let n;return n=r!=null?await r.createAddCommand(a):W.create(this._renderCommandContext),Te(e),n.appendPipelineStateCommand((()=>{t.addTile(a)})),n}async _createRemoveFeatureDataCommand(a){const e=this._featureStore,t=this._renderer;let r;return r=t!=null?await t.createRemoveCommand(a):W.create(this._renderCommandContext),r.appendPipelineStateCommand((()=>{e.removeTile(a)})),r}async _createUpdateFeatureDataVisibilityCommand(a,e){const t=this._renderer;let r;return r=t!=null?await t.createUpdateVisibilityCommand(a):W.create(this._renderCommandContext),Te(e),r}_ensureQuery(a){return a??this._defaultQueryJSON}};S([N()],He.prototype,"updating",null),He=S([xr("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")],He);const Ys=He,he={result:void 0},el=Object.freeze(Object.defineProperty({__proto__:null,default:Ys},Symbol.toStringTag,{value:"Module"}));export{vs as B,el as F,Ee as M,Ze as V};
