import{an as C,s as I,hl as O,hm as b,hn as x,aG as M,ho as S,ew as k,hp as g,hq as N,hr as P,hs as w,cc as T}from"./index-Bdk4Sca1.js";import{i as G}from"./colorUtils-CZMGde11.js";import{B as $,H as E,D as A,C as F}from"./quantizationUtils-DYQAh1iP.js";function h(p,e,r,t,a,s){if(p==null)return null;const i=p.references("geometry")&&s?L(e,t,s):e,n=p.repurposeFeature(i,a);try{return p.evaluate(n,r)}catch(c){return C.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",c),null}}const u=new Map;function L(p,e,r){const{transform:t,hasZ:a,hasM:s}=r;u.has(e)||u.set(e,D(e));const i=u.get(e)(p.geometry,t,a,s);return{...p,geometry:i}}function D(p){const e={};switch(p){case"esriGeometryPoint":return(r,t,a,s)=>F(t,e,r,a,s);case"esriGeometryPolygon":return(r,t,a,s)=>A(t,e,r,a,s);case"esriGeometryPolyline":return(r,t,a,s)=>E(t,e,r,a,s);case"esriGeometryMultipoint":return(r,t,a,s)=>$(t,e,r,a,s);default:return C.getLogger("esri.views.2d.support.arcadeOnDemand").error(new I("mapview-arcade",`Unable to handle geometryType: ${p}`)),r=>r}}const z=Object.freeze(Object.defineProperty({__proto__:null,default:h},Symbol.toStringTag,{value:"Module"})),R=p=>{if(!p)return[0,0,0,0];const{r:e,g:r,b:t,a}=p;return[e,r,t,255*a]},o=class o{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let a=!1;for(const s of t)if(s.primitiveName===e.primitiveName){a=!0;break}if(!a)for(const s of r)s.primitiveName===e.primitiveName&&t.push(s)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const a of e.effects)o.findApplicableOverrides(a,r,t);if(e.symbolLayers)for(const a of e.symbolLayers)o.findApplicableOverrides(a,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const a of e.effects)o.findApplicableOverrides(a,r,t);if(e.markerPlacement&&o.findApplicableOverrides(e.markerPlacement,r,t),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const a of e.markerGraphics)o.findApplicableOverrides(a,r,t),o.findApplicableOverrides(a.symbol,r,t)}else e.type==="CIMCharacterMarker"?o.findApplicableOverrides(e.symbol,r,t):e.type==="CIMHatchFill"?o.findApplicableOverrides(e.lineSymbol,r,t):e.type==="CIMPictureMarker"&&o.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&O(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=b(e),a=e.primitiveName,s=[];for(const i of r)i.primitiveName===a&&s.push(b(i));return{type:"cim-effect-param",effect:t,overrides:x(s)}}static async resolveSymbolOverrides(e,r,t,a,s,i,n){if(!(e!=null&&e.symbol))return null;let{symbol:c,primitiveOverrides:l}=e;const y=!!l;if(!y&&!a)return c;c=M(c),l=M(l);let v=!0;if(r||(r={attributes:{}},v=!1),y){if(v||(l=l.filter((m=>{var f;return!((f=m.valueExpressionInfo)!=null&&f.expression.includes("$feature"))}))),n||(l=l.filter((m=>{var f;return!((f=m.valueExpressionInfo)!=null&&f.expression.includes("$view"))}))),l.length>0){const m=S(r.attributes),f={spatialReference:t,fields:m,geometryType:s};await o.createRenderExpressions(l,f),o.evaluateOverrides(l,r,s??"esriGeometryPoint",i,n,new k(m))}o.applyOverrides(c,l)}return a&&o.applyDictionaryTextOverrides(c,r,a,null),c}static async createRenderExpressions(e,r){const t=[];for(const a of e){const s=a.valueExpressionInfo;if(!s||o._expressionToRenderExpression.has(s.expression))continue;const i=g(s.expression,r.spatialReference);t.push(i),i.then((n=>o._expressionToRenderExpression.set(s.expression,n)))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,r,t,a,s,i){const n={$view:{scale:s==null?void 0:s.scale}};for(const c of e){c.value&&typeof c.value=="object"&&G(c.value)&&(c.propertyName==="Color"||c.propertyName==="StrokeColor")&&(c.value=R(c.value));const l=c.valueExpressionInfo;if(!l)continue;const y=o._expressionToRenderExpression.get(l.expression);y&&(c.value=h(y,r,n,t,i,a))}}static applyDictionaryTextOverrides(e,r,t,a,s="Normal"){if(e!=null&&e.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const i=e.symbolLayers;if(!i)return;for(const n of i)n&&n.type==="CIMVectorMarker"&&o.applyDictionaryTextOverrides(n,r,t,a,e.type==="CIMTextSymbol"?e.textCase:s)}break;case"CIMVectorMarker":{const i=e.markerGraphics;if(!i)return;for(const n of i)n&&o.applyDictionaryTextOverrides(n,r,t,a)}break;case"CIMMarkerGraphic":{const i=e.textString;if(i&&i.includes("[")){const n=N(i,t);e.textString=P(r,n,a,s)}}}}static applyOverrides(e,r,t,a){if(e.primitiveName){for(const s of r)if(s.primitiveName===e.primitiveName){const i=w(s.propertyName);if(a&&a.push({cim:e,nocapPropertyName:i,value:e[i]}),t){let n=!1;for(const c of t)c.primitiveName===e.primitiveName&&(n=!0);n||t.push(s)}s.value!=null&&(e[i]=s.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)o.applyOverrides(s,r,t,a);if(e.symbolLayers)for(const s of e.symbolLayers)o.applyOverrides(s,r,t,a);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const s of e.effects)o.applyOverrides(s,r,t,a);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const s of e.markerGraphics)o.applyOverrides(s,r,t,a),o.applyOverrides(s.symbol,r,t,a)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)t.value!==void 0&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map((t=>Number(t)));if(e==="Color"){const t=new T(r).toRgba();return t[3]*=255,t}return r}};o._expressionToRenderExpression=new Map;let d=o;const Z=Object.freeze(Object.defineProperty({__proto__:null,OverrideHelper:d},Symbol.toStringTag,{value:"Module"}));export{Z as O,z as c,d as v};
