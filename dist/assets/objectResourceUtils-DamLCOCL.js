const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./loader-CfZlTzwp.js","./index-DzoQLc5A.js","./index-FMl8DCyv.css","./mat4f64-Busq8X2U.js","./enums-CIq3dAOf.js","./quat-CI_Qlf1a.js","./mat3f64-B5o_lm6j.js","./quatf64-aQ5IuZRd.js","./vec32-LyzMesOw.js","./BufferView-6Wo0HYee.js","./vec2-D0N3Bz89.js","./vec2f64-B08OqgY-.js","./resourceUtils-BJt-aYVq.js","./basicInterfaces-N86vRvDz.js"])))=>i.map(i=>d[i]);
import{a6 as U,f$ as pe,ht as xe,ey as oe,bh as be,v as Se,b7 as ye,j as Be,ir as Te,hr as Z,s as Ee,_ as Ce,eA as Le,bW as we,eC as ae}from"./index-DzoQLc5A.js";import{a as Ne}from"./devEnvironmentUtils-BfO8ai13.js";import{i as ue,j as je,n as Fe}from"./mat3-D2DxLcs1.js";import{n as se,e as ve}from"./mat3f64-B5o_lm6j.js";import{r as le,t as ke,e as Ue}from"./mat4f64-Busq8X2U.js";import{a as qe}from"./vec2f64-B08OqgY-.js";import{o as j,u as E,g as F,W as ze,E as ne,c as De,i as ce,r as He,A as Ve,I as We}from"./vec32-LyzMesOw.js";import{S as Ge,n as G,e as Qe,c as Ke,o as Ye,L as $e,W as J,t as Ze,a as Je,b as Xe,d as Q,s as et,f as tt}from"./DefaultMaterial-DhVdWTwX.js";import{s as rt,o as _e,T as Ie,g as st,M as nt,O as it,V as ot}from"./BufferView-6Wo0HYee.js";import{r as at,n as ut,d as he,l as me}from"./vec3-BftouXos.js";import{o as lt,d as de}from"./vec4-Bab8Omiu.js";import{n as ct,o as ht,b as mt}from"./indexUtils-BwRXdBcY.js";import{n as K}from"./resourceUtils-BJt-aYVq.js";import{a as dt,i as ft}from"./vec2f32-CaVKkSa6.js";import{u as gt}from"./memoryEstimations-Cau39Oyv.js";import{e as pt,A as Ae}from"./Indices-Die4BdlF.js";import{t as z}from"./orientedBoundingBox-CegL4iPR.js";import{t as xt,e as ie,i as M,n as bt}from"./basicInterfaces-N86vRvDz.js";import{e as _}from"./VertexAttribute-C1eU-FcF.js";import{P as fe}from"./enums-CIq3dAOf.js";import{a as ge}from"./NormalAttribute.glsl-B56U0yJ_.js";import"https://js.arcgis.com/map-components/4.33/arcgis-map-components.esm.js";import"./videoUtils-xf59qIHa.js";import"./TextureFormat-1mYWTFa-.js";import"./sphere-DVa6yVTZ.js";import"./vectorStacks-BcGsIGGR.js";import"./quatf64-aQ5IuZRd.js";import"./lineSegment-BnQxKnu0.js";import"./InterleavedLayout-DWIRiq9i.js";import"./types-BKo2foNY.js";import"./plane-BM5dy-fQ.js";import"./time-ClENgjgA.js";import"./vec2-D0N3Bz89.js";import"./quat-CI_Qlf1a.js";import"./spatialReferenceEllipsoidUtils-DtwM3pvq.js";import"./computeTranslationToOriginAndRotation-Bgn1ecnn.js";function yt(s,e){if(!s)return!1;const{size:t,data:r,indices:a}=s;j(e,0,0,0),j($,0,0,0);let u=0,i=0;for(let o=0;o<a.length-2;o+=3){const c=a[o]*t,n=a[o+1]*t,l=a[o+2]*t;j(x,r[c],r[c+1],r[c+2]),j(C,r[n],r[n+1],r[n+2]),j(Y,r[l],r[l+1],r[l+2]);const h=Ge(x,C,Y);h?(E(x,x,C),E(x,x,Y),F(x,x,1/3*h),E(e,e,x),u+=h):(E($,$,x),E($,$,C),E($,$,Y),i+=3)}return(i!==0||u!==0)&&(u!==0?(F(e,e,1/u),!0):i!==0&&(F(e,$,1/i),!0))}function Tt(s,e){if(!s)return!1;const{size:t,data:r,indices:a}=s;j(e,0,0,0);let u=-1,i=0;for(let o=0;o<a.length;o++){const c=a[o]*t;u!==c&&(e[0]+=r[c],e[1]+=r[c+1],e[2]+=r[c+2],i++),u=c}return i>1&&F(e,e,1/i),i>0}function wt(s,e,t){if(!s)return!1;j(t,0,0,0),j($,0,0,0);let r=0,a=0;const{size:u,data:i,indices:o}=s,c=o.length-1,n=c+(e?2:0);for(let l=0;l<n;l+=2){const h=l<c?l+1:0,m=o[l<c?l:c]*u,d=o[h]*u;x[0]=i[m],x[1]=i[m+1],x[2]=i[m+2],C[0]=i[d],C[1]=i[d+1],C[2]=i[d+2],F(x,E(x,x,C),.5);const g=ze(x,C);g>0?(E(t,t,F(x,x,g)),r+=g):r===0&&(E($,$,x),a++)}return r!==0?(F(t,t,1/r),!0):a!==0&&(F(t,$,1/a),!0)}const x=U(),C=U(),Y=U(),$=U();class vt{constructor(){this.uid=pe()}}class $t extends vt{constructor(e){super(),this.highlightName=e,this.channel=xt.Highlight}}class X{constructor(e,t,r=null,a=G.Mesh,u=null,i=-1){this.material=e,this.mapPositions=r,this.type=a,this.objectAndLayerIdColor=u,this.edgeIndicesLength=i,this.highlights=new Set,this._highlightOptionsCounts=new Map,this.id=pe(),this.visible=!0,this._attributes=new Map,this._boundingInfo=null;for(const[o,c]of t)this._attributes.set(o,{...c,indices:pt(c.indices)}),o===_.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._attributes.get(o).indices.length:this.edgeIndicesLength)}instantiate(e={}){const t=new X(e.material||this.material,[],this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._attributes.forEach(((r,a)=>{r.exclusive=!1,t._attributes.set(a,r)})),t._boundingInfo=this._boundingInfo,t.transformation=e.transformation||this.transformation,t}get attributes(){return this._attributes}getMutableAttribute(e){let t=this._attributes.get(e);return t&&!t.exclusive&&(t={...t,exclusive:!0,data:Qe(t.data)},this._attributes.set(e,t)),t}setAttributeData(e,t){const r=this._attributes.get(e);r?this._attributes.set(e,{...r,exclusive:!0,data:t}):Ke()&&console.warn(`Setting undefined attribute ${e} data`)}get indexCount(){var t;const e=(t=this._attributes.values().next().value)==null?void 0:t.indices;return(e==null?void 0:e.length)??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return this._boundingInfo??(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return!!(this.type===G.Mesh?this._computeAttachmentOriginTriangles(e):this.type===G.Line?this._computeAttachmentOriginLines(e):this._computeAttachmentOriginPoints(e))&&(this._transformation!=null&&ne(e,e,this._transformation),!0)}_computeAttachmentOriginTriangles(e){const t=this.attributes.get(_.POSITION);return yt(t,e)}_computeAttachmentOriginLines(e){const t=this.attributes.get(_.POSITION);return wt(t,_t(this.material.parameters,t),e)}_computeAttachmentOriginPoints(e){const t=this.attributes.get(_.POSITION);return Tt(t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.attributes.get(_.POSITION);if(!e||e.indices.length===0)return null;const t=this.type===G.Mesh?3:1;rt(e.indices.length%t===0,"Indexing error: "+e.indices.length+" not divisible by "+t);const r=Ae(e.indices.length/t);return new Ye(r,t,e)}get transformation(){return this._transformation??le}set transformation(e){this._transformation=e&&e!==le?ke(e):null}get highlightNames(){return this._highlightOptionsCounts}get hasHighlights(){return this._highlightOptionsCounts.size>0}foreachHighlightOptions(e){this._highlightOptionsCounts.forEach(((t,r)=>e(r)))}allocateIdAndHighlight(e){const t=new $t(e);return this.addHighlight(t)}addHighlight(e){this.highlights.add(e);const{highlightName:t}=e,r=(this._highlightOptionsCounts.get(t)??0)+1;return this._highlightOptionsCounts.set(t,r),e}removeHighlight(e){if(this.highlights.delete(e)){const{highlightName:t}=e,r=this._highlightOptionsCounts.get(t)??0;r<=1?this._highlightOptionsCounts.delete(t):this._highlightOptionsCounts.set(t,r-1)}}}function _t(s,e){return!(!("isClosed"in s)||!s.isClosed)&&e.indices.length>2}function D(s){if(s==null)return null;const e=s.offset!=null?s.offset:dt,t=s.rotation!=null?s.rotation:0,r=s.scale!=null?s.scale:ft,a=se(1,0,0,0,1,0,e[0],e[1],1),u=se(Math.cos(t),-Math.sin(t),0,Math.sin(t),Math.cos(t),0,0,0,1),i=se(r[0],0,0,0,r[1],0,0,0,1),o=ve();return ue(o,u,i),ue(o,a,o),o}class It{constructor(){this.geometries=new Array,this.materials=new Array,this.textures=new Array}}let At=class{constructor(e,t,r){this.name=e,this.lodThreshold=t,this.pivotOffset=r,this.stageResources=new It,this.numberOfVertices=0}};class Ot{constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return this._outer.size===0}get outerSize(){return this._outer.size}get(e,t){var r;return(r=this._outer.get(e))==null?void 0:r.get(t)}getInner(e){return this._outer.get(e)}set(e,t,r){const a=this._outer.get(e);a?a.set(t,r):this._outer.set(e,new Map([[t,r]]))}delete(e,t){const r=this._outer.get(e);r&&(r.delete(t),r.size===0&&this._outer.delete(e))}forEach(e){this._outer.forEach(((t,r)=>e(t,r)))}forAll(e){this._outer.forEach(((t,r)=>t.forEach(((a,u)=>e(a,r,u)))))}}const B=()=>Be.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class Mt{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}async function Rt(s,e){const t=await Pt(s,e),r=await Lt(t.textureDefinitions??{},e);let a=0;for(const u in r)if(r.hasOwnProperty(u)){const i=r[u];a+=i!=null&&i.image?i.image.width*i.image.height*4:0}return new Mt(t,r,a+gt(t))}async function Pt(s,e){const t=e==null?void 0:e.streamDataRequester;if(t)return St(s,t,e);const r=await be(Se(s,e));if(r.ok===!0)return r.value.data;ye(r.error),Oe(r.error)}async function St(s,e,t){const r=await be(e.request(s,"json",t));if(r.ok===!0)return r.value;ye(r.error),Oe(r.error.details.url)}function Oe(s){throw new Ee("",`Request for object resource failed: ${s}`)}function Bt(s){const e=s.params,t=e.topology;let r=!0;switch(e.vertexAttributes||(B().warn("Geometry must specify vertex attributes"),r=!1),e.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const u=e.faces;if(u){if(e.vertexAttributes)for(const i in e.vertexAttributes){const o=u[i];o!=null&&o.values?(o.valueType!=null&&o.valueType!=="UInt32"&&(B().warn(`Unsupported indexed geometry indices type '${o.valueType}', only UInt32 is currently supported`),r=!1),o.valuesPerElement!=null&&o.valuesPerElement!==1&&(B().warn(`Unsupported indexed geometry values per element '${o.valuesPerElement}', only 1 is currently supported`),r=!1)):(B().warn(`Indexed geometry does not specify face indices for '${i}' attribute`),r=!1)}}else B().warn("Indexed geometries must specify faces"),r=!1;break}default:B().warn(`Unsupported topology '${t}'`),r=!1}s.params.material||(B().warn("Geometry requires material"),r=!1);const a=s.params.vertexAttributes;for(const u in a)a[u].values||(B().warn("Geometries with externally defined attributes are not yet supported"),r=!1);return r}function Et(s,e){var g,p;const t=new Array,r=new Array,a=new Array,u=new Ot,i=s.resource,o=xe.parse(i.version||"1.0","wosr");jt.validate(o);const c=i.model.name,n=i.model.geometries,l=i.materialDefinitions??{},h=s.textures;let m=0;const d=new Map;for(let w=0;w<n.length;w++){const b=n[w];if(!Bt(b))continue;const I=Nt(b),v=b.params.vertexAttributes,O=[],T=f=>{if(b.params.topology==="PerAttributeArray")return null;const A=b.params.faces;for(const y in A)if(y===f)return A[y].values;return null},L=v[_.POSITION],H=L.values.length/L.valuesPerElement;for(const f in v){const A=v[f],y=A.values,te=T(f)??Ae(H);O.push([f,new z(y,te,A.valuesPerElement,!0)])}const R=I.texture,P=h&&h[R];if(P&&!d.has(R)){const{image:f,parameters:A}=P,y=new $e(f,A);r.push(y),d.set(R,y)}const V=d.get(R),ee=V?V.id:void 0,S=I.material;let N=u.get(S,R);if(N==null){const f=l[S.slice(S.lastIndexOf("/")+1)].params;f.transparency===1&&(f.transparency=0);const A=P?Me(P.alphaChannelUsage):void 0,y={ambient:oe(f.diffuse),diffuse:oe(f.diffuse),opacity:1-(f.transparency||0),textureAlphaMode:A,textureAlphaCutoff:.33,textureId:ee,doubleSided:!0,cullFace:ie.None,colorMixMode:f.externalColorMixMode||"tint",textureAlphaPremultiplied:(P==null?void 0:P.parameters.preMultiplyAlpha)??!1};e!=null&&e.materialParameters&&Object.assign(y,e.materialParameters),N=new J(y,e),u.set(S,R,N)}a.push(N);const W=new X(N,O);m+=((p=(g=O.find((f=>f[0]===_.POSITION)))==null?void 0:g[1])==null?void 0:p.indices.length)??0,t.push(W)}return{engineResources:[{name:c,stageResources:{textures:r,materials:a,geometries:t},pivotOffset:i.model.pivotOffset,numberOfVertices:m,lodThreshold:null}],referenceBoundingBox:Ct(t)}}function Ct(s){const e=Te();return s.forEach((t=>{const r=t.boundingInfo;r!=null&&(Z(e,r.bbMin),Z(e,r.bbMax))})),e}async function Lt(s,e){const t=new Array;for(const u in s){const i=s[u],o=i.images[0].data;if(!o){B().warn("Externally referenced texture data is not yet supported");continue}const c=i.encoding+";base64,"+o,n="/textureDefinitions/"+u,l=i.channels==="rgba"?i.alphaChannelUsage||"transparency":"none",h={noUnpackFlip:!0,wrap:{s:fe.REPEAT,t:fe.REPEAT},preMultiplyAlpha:Me(l)!==M.Opaque},m=e!=null&&e.disableTextures?Promise.resolve(null):Ze(c,e);t.push(m.then((d=>({refId:n,image:d,parameters:h,alphaChannelUsage:l}))))}const r=await Promise.all(t),a={};for(const u of r)a[u.refId]=u;return a}function Me(s){switch(s){case"mask":return M.Mask;case"maskAndTransparency":return M.MaskBlend;case"none":return M.Opaque;default:return M.Blend}}function Nt(s){const e=s.params;return{id:1,material:e.material,texture:e.texture,region:e.texture}}const jt=new xe(1,2,"wosr");async function Or(s,e){var h;const t=Ft(Ne(s));if(t.fileType==="wosr"){const m=await(e.cache?e.cache.loadWOSR(t.url,e):Rt(t.url,e)),{engineResources:d,referenceBoundingBox:g}=Et(m,e);return{lods:d,referenceBoundingBox:g,isEsriSymbolResource:!1,isWosr:!0}}let r;if(e.cache)r=await e.cache.loadGLTF(t.url,e,!!e.usePBR);else{const{loadGLTF:m}=await Ce(()=>import("./loader-CfZlTzwp.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]),import.meta.url);r=await m(new ct(e.streamDataRequester),t.url,e,e.usePBR)}const a=(h=r.model.meta)==null?void 0:h.ESRI_proxyEllipsoid,u=r.meta.isEsriSymbolResource&&a!=null&&r.meta.ESRI_webstyle==="EsriRealisticTreesStyle";u&&!r.customMeta.esriTreeRendering&&(r.customMeta.esriTreeRendering=!0,Dt(r,a));const i=!!e.usePBR,o=r.meta.isEsriSymbolResource?{usePBR:i,isSchematic:!1,treeRendering:u,mrrFactors:et}:{usePBR:i,isSchematic:!1,treeRendering:!1,mrrFactors:tt},c={...e.materialParameters,treeRendering:u},{engineResources:n,referenceBoundingBox:l}=kt(r,o,c,e,t.specifiedLodIndex,u);return{lods:n,referenceBoundingBox:l,isEsriSymbolResource:r.meta.isEsriSymbolResource,isWosr:!1}}function Ft(s){const e=s.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return e?{fileType:"gltf",url:e[1],specifiedLodIndex:e[4]!=null?Number(e[4]):null}:s.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:s,specifiedLodIndex:null}:{fileType:"unknown",url:s,specifiedLodIndex:null}}function kt(s,e,t,r,a,u){const i=s.model,o=new Array,c=new Map,n=new Map,l=i.lods.length,h=Te();return i.lods.forEach(((m,d)=>{const g=r.skipHighLods===!0&&(l>1&&d===0||l>3&&d===1)||r.skipHighLods===!1&&a!=null&&d!==a;if(g&&d!==0)return;const p=new At(m.name,m.lodThreshold,[0,0,0]);m.parts.forEach((w=>{const b=g?new J({},r):Ut(i,w,p,e,t,c,n,r,u),{geometry:I,vertexCount:v}=qt(w,b??new J({},r)),O=I.boundingInfo;O!=null&&d===0&&(Z(h,O.bbMin),Z(h,O.bbMax)),b!=null&&(p.stageResources.geometries.push(I),p.numberOfVertices+=v)})),g||o.push(p)})),{engineResources:o,referenceBoundingBox:h}}function Ut(s,e,t,r,a,u,i,o,c){var v,O;const n=s.materials.get(e.material);if(n==null)return null;const{normal:l,color:h,texCoord0:m,tangent:d}=e.attributes,g=e.material+(l?"_normal":"")+(h?"_color":"")+(m?"_texCoord0":"")+(d?"_tangent":""),p=e.attributes.texCoord0!=null,w=e.attributes.normal!=null,b=zt(n.alphaMode);if(!u.has(g)){if(p){const f=(y,te=!1,Re=!1)=>{if(y!=null&&!i.has(y)){const re=s.textures.get(y);if(re){const k=re.data,Pe=te&&!K(k)?o.compressionOptions:void 0;i.set(y,new $e(K(k)?k.data:k,{...re.parameters,preMultiplyAlpha:!K(k)&&Re,encoding:K(k)?k.encoding:void 0,compressionOptions:Pe}))}}},A=b!==M.Opaque&&!c;f(n.colorTexture,A,b!==M.Opaque),f(n.normalTexture),f(n.occlusionTexture,!0),f(n.emissiveTexture),f(n.metallicRoughnessTexture,!0)}const T=1/we,L=n.color[0]**T,H=n.color[1]**T,R=n.color[2]**T,P=n.emissiveFactor[0]**T,V=n.emissiveFactor[1]**T,ee=n.emissiveFactor[2]**T,S=n.colorTexture!=null&&p?i.get(n.colorTexture):null,N=Je(n),W=((v=n.normalTextureTransform)==null?void 0:v.scale)!=null?(O=n.normalTextureTransform)==null?void 0:O.scale:qe;u.set(g,new J({...r,customDepthTest:bt.Lequal,textureAlphaMode:b,textureAlphaCutoff:n.alphaCutoff,diffuse:[L,H,R],ambient:[L,H,R],opacity:n.alphaMode==="OPAQUE"?1:n.opacity,doubleSided:n.doubleSided,doubleSidedType:"winding-order",cullFace:n.doubleSided?ie.None:ie.Back,hasVertexColors:!!e.attributes.color,hasVertexTangents:!!e.attributes.tangent,normalType:w?ge.Attribute:ge.ScreenDerivative,castShadows:!0,receiveShadows:n.receiveShadows,receiveAmbientOcclusion:n.receiveAmbientOcclusion,textureId:S!=null?S.id:void 0,colorMixMode:n.colorMixMode,normalTextureId:n.normalTexture!=null&&p?i.get(n.normalTexture).id:void 0,textureAlphaPremultiplied:S!=null&&!!S.parameters.preMultiplyAlpha,occlusionTextureId:n.occlusionTexture!=null&&p?i.get(n.occlusionTexture).id:void 0,emissiveTextureId:n.emissiveTexture!=null&&p?i.get(n.emissiveTexture).id:void 0,metallicRoughnessTextureId:n.metallicRoughnessTexture!=null&&p?i.get(n.metallicRoughnessTexture).id:void 0,emissiveBaseColor:[P,V,ee],mrrFactors:N?Xe:[n.metallicFactor,n.roughnessFactor,r.mrrFactors[2]],isSchematic:N,colorTextureTransformMatrix:D(n.colorTextureTransform),normalTextureTransformMatrix:D(n.normalTextureTransform),scale:[W[0],W[1]],occlusionTextureTransformMatrix:D(n.occlusionTextureTransform),emissiveTextureTransformMatrix:D(n.emissiveTextureTransform),metallicRoughnessTextureTransformMatrix:D(n.metallicRoughnessTextureTransform),...a},o))}const I=u.get(g);if(t.stageResources.materials.push(I),p){const T=L=>{L!=null&&t.stageResources.textures.push(i.get(L))};T(n.colorTexture),T(n.normalTexture),T(n.occlusionTexture),T(n.emissiveTexture),T(n.metallicRoughnessTexture)}return I}function qt(s,e){const t=s.attributes.position.count,r=ht(s.indices||t,s.primitiveType),a=Q(3*t),{typedBuffer:u,typedBufferStride:i}=s.attributes.position;at(a,u,s.transform,3,i);const o=[[_.POSITION,new z(a,r,3,!0)]];if(s.attributes.normal!=null){const n=Q(3*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.normal;je(q,s.transform),ut(n,l,q,3,h),ae(q)&&he(n,n),o.push([_.NORMAL,new z(n,r,3,!0)])}if(s.attributes.tangent!=null){const n=Q(4*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.tangent;Fe(q,s.transform),lt(n,l,q,4,h),ae(q)&&he(n,n,4),o.push([_.TANGENT,new z(n,r,4,!0)])}if(s.attributes.texCoord0!=null){const n=Q(2*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.texCoord0;mt(n,l,2,h),o.push([_.UV0,new z(n,r,2,!0)])}const c=s.attributes.color;if(c!=null){const n=new Uint8Array(4*t);c.elementCount===4?c instanceof Ie?de(n,c,1,255):(c instanceof st||c instanceof nt)&&de(n,c,1/255,255):(n.fill(255),c instanceof _e?me(n,c.typedBuffer,1,255,4,c.typedBufferStride):(s.attributes.color instanceof it||s.attributes.color instanceof ot)&&me(n,c.typedBuffer,1/255,255,4,s.attributes.color.typedBufferStride)),o.push([_.COLOR,new z(n,r,4,!0)])}return{geometry:new X(e,o),vertexCount:t}}const q=ve();function zt(s){switch(s){case"BLEND":return M.Blend;case"MASK":return M.Mask;case"OPAQUE":case null:case void 0:return M.Opaque}}function Dt(s,e){for(let t=0;t<s.model.lods.length;++t){const r=s.model.lods[t];for(const a of r.parts){const u=a.attributes.normal;if(u==null)return;const i=a.attributes.position,o=i.count,c=U(),n=U(),l=U(),h=new Float32Array(4*o),m=new Float32Array(3*o),d=Le(Ue(),a.transform);let g=0,p=0;for(let w=0;w<o;w++){i.getVec(w,n),u.getVec(w,c),ne(n,n,a.transform),De(l,n,e.center),ce(l,l,e.radius);const b=l[2],I=He(l),v=Math.min(.45+.55*I*I,1)**we;ce(l,l,e.radius),d!==null&&ne(l,l,d),Ve(l,l),t+1!==s.model.lods.length&&s.model.lods.length>1&&We(l,l,c,b>-1?.2:Math.min(-4*b-3.8,1)),m[g]=l[0],m[g+1]=l[1],m[g+2]=l[2],g+=3,h[p]=v,h[p+1]=v,h[p+2]=v,h[p+3]=1,p+=4}a.attributes.normal=new _e(m),a.attributes.color=new Ie(h)}}}export{Or as fetch,Ft as parseUrl};
